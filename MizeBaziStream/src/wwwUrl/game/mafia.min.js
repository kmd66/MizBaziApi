var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __publicField = (obj, key, value2) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value2);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value2) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value2);
var __privateSet = (obj, member, value2, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value2) : member.set(obj, value2), value2);
globalModel = {};
function reset$1() {
  main.reset();
}
function initShare() {
  globalModel = {
    gameName: "mafia",
    khorojHadseNaghsh: false,
    isChaos: false,
    isNightEvent: false
  };
  vm = {};
  globalModel.connection;
  globalModel.reset = reset$1;
  globalModel.room = {};
  globalModel.users = [];
  globalModel.user = {};
  sticker = {};
  itemclick = {};
  socketHandler = {};
  main = {};
  help = {};
  chaos = {};
  gameresponse = {};
}
initShare();
globalModel.infoRoomReceive = function(model) {
  socketHandler.closelObj();
  if (model.room.state) {
    vm.changeState(model.room.state);
  }
  model.users.map((x) => {
    if (x.type && x.type > 20) {
      x.nightIcon = "imgStatus " + help.find(x.type).icon;
    } else {
      x.nightIcon = "imgStatus icon-mask";
    }
    x.row = x.index + 1;
  });
  globalModel.users = model.users;
  globalModel.room = model.room;
  globalModel.groupItem = model.groupItem;
  main.topTimeProgress(-100);
  globalModel.userStatusReceive(model.status);
  setDoor(model.room);
  setNightMode(model.room.doorType);
  if (model.isChaos) chaos.chaosReceive({ type: "chaos", wait: 10 });
};
globalModel.userStatusReceive = function(model) {
  if (!model || !model.length) return;
  model.map((x) => {
    const i = globalModel.users.findIndex((u) => u.id == x.id);
    if (i > -1) {
      globalModel.users[i].userInGameStatus = x.userInGameStatus;
    }
  });
  main.setUsers();
};
globalModel.infoMainReceive = function(room) {
  reset$1();
  globalModel.room = room;
  main.topTimeProgress(-100);
  setDoor(room);
  setNightMode(room.doorType);
};
globalModel.nightUpdate = function(model) {
  globalModel.userStatusReceive(model.status);
  const { status, ...newModel } = model;
  globalModel.infoMainReceive(newModel);
};
function setDoor(room) {
  if (room.door == 1)
    vm.$refs.childmain.door = "معارفه";
  else if (room.doorType == 2)
    vm.$refs.childmain.door = "رای‌گیری";
  else
    vm.$refs.childmain.door = room.doorType == 3 ? `شب ${room.door}` : `روز ${room.door}`;
}
function setNightMode(doorType) {
  main.nightAlert();
  if (doorType == 3 && globalModel.user.type > 20 && globalModel.user.userInGameStatus == 1) {
    vm.$refs.childmain.isChat = true;
  }
  if (doorType == 3 && globalModel.user.type > 20 && globalModel.user.userInGameStatus == 1) {
    vm.$refs.childmain.isChat = true;
  } else {
    if (vm.$refs.childmain.isChat) {
      vm.$refs.childmain.chatList = [];
      vm.$refs.childmain.isChat = false;
    }
  }
  if (doorType == 3) {
    if (!vm.appModel.nightMode)
      vm.appModel.nightMode = true;
  } else {
    if (vm.appModel.nightMode)
      vm.appModel.nightMode = false;
  }
  main.nightAlert();
}
const PACKET_TYPES = /* @__PURE__ */ Object.create(null);
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
const PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
Object.keys(PACKET_TYPES).forEach((key) => {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
const ERROR_PACKET = { type: "error", data: "parser error" };
const withNativeBlob$1 = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
const withNativeArrayBuffer$2 = typeof ArrayBuffer === "function";
const isView$1 = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};
const encodePacket = ({ type, data }, supportsBinary, callback2) => {
  if (withNativeBlob$1 && data instanceof Blob) {
    if (supportsBinary) {
      return callback2(data);
    } else {
      return encodeBlobAsBase64(data, callback2);
    }
  } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {
    if (supportsBinary) {
      return callback2(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback2);
    }
  }
  return callback2(PACKET_TYPES[type] + (data || ""));
};
const encodeBlobAsBase64 = (data, callback2) => {
  const fileReader = new FileReader();
  fileReader.onload = function() {
    const content = fileReader.result.split(",")[1];
    callback2("b" + (content || ""));
  };
  return fileReader.readAsDataURL(data);
};
function toArray(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
  }
}
let TEXT_ENCODER;
function encodePacketToBinary(packet, callback2) {
  if (withNativeBlob$1 && packet.data instanceof Blob) {
    return packet.data.arrayBuffer().then(toArray).then(callback2);
  } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {
    return callback2(toArray(packet.data));
  }
  encodePacket(packet, false, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback2(TEXT_ENCODER.encode(encoded));
  });
}
const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
const lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (let i = 0; i < chars.length; i++) {
  lookup$1[chars.charCodeAt(i)] = i;
}
const encode$1 = (arraybuffer) => {
  let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};
const decode$1 = (base64) => {
  let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base64[base64.length - 1] === "=") {
    bufferLength--;
    if (base64[base64.length - 2] === "=") {
      bufferLength--;
    }
  }
  const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base64.charCodeAt(i)];
    encoded2 = lookup$1[base64.charCodeAt(i + 1)];
    encoded3 = lookup$1[base64.charCodeAt(i + 2)];
    encoded4 = lookup$1[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
const withNativeArrayBuffer$1 = typeof ArrayBuffer === "function";
const decodePacket = (encodedPacket, binaryType) => {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }
  const type = encodedPacket.charAt(0);
  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }
  const packetType = PACKET_TYPES_REVERSE[type];
  if (!packetType) {
    return ERROR_PACKET;
  }
  return encodedPacket.length > 1 ? {
    type: PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: PACKET_TYPES_REVERSE[type]
  };
};
const decodeBase64Packet = (data, binaryType) => {
  if (withNativeArrayBuffer$1) {
    const decoded = decode$1(data);
    return mapBinary(decoded, binaryType);
  } else {
    return { base64: true, data };
  }
};
const mapBinary = (data, binaryType) => {
  switch (binaryType) {
    case "blob":
      if (data instanceof Blob) {
        return data;
      } else {
        return new Blob([data]);
      }
    case "arraybuffer":
    default:
      if (data instanceof ArrayBuffer) {
        return data;
      } else {
        return data.buffer;
      }
  }
};
const SEPARATOR = String.fromCharCode(30);
const encodePayload = (packets, callback2) => {
  const length = packets.length;
  const encodedPackets = new Array(length);
  let count = 0;
  packets.forEach((packet, i) => {
    encodePacket(packet, false, (encodedPacket) => {
      encodedPackets[i] = encodedPacket;
      if (++count === length) {
        callback2(encodedPackets.join(SEPARATOR));
      }
    });
  });
};
const decodePayload = (encodedPayload, binaryType) => {
  const encodedPackets = encodedPayload.split(SEPARATOR);
  const packets = [];
  for (let i = 0; i < encodedPackets.length; i++) {
    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
    packets.push(decodedPacket);
    if (decodedPacket.type === "error") {
      break;
    }
  }
  return packets;
};
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
let TEXT_DECODER;
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j = 0;
  for (let i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
const protocol$2 = 4;
function Emitter(obj) {
  if (obj) return mixin(obj);
}
function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
  return this;
};
Emitter.prototype.once = function(event, fn) {
  function on2() {
    this.off(event, on2);
    fn.apply(this, arguments);
  }
  on2.fn = fn;
  this.on(event, on2);
  return this;
};
Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
  this._callbacks = this._callbacks || {};
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }
  var callbacks = this._callbacks["$" + event];
  if (!callbacks) return this;
  if (1 == arguments.length) {
    delete this._callbacks["$" + event];
    return this;
  }
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  if (callbacks.length === 0) {
    delete this._callbacks["$" + event];
  }
  return this;
};
Emitter.prototype.emit = function(event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }
  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }
  return this;
};
Emitter.prototype.emitReserved = Emitter.prototype.emit;
Emitter.prototype.listeners = function(event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks["$" + event] || [];
};
Emitter.prototype.hasListeners = function(event) {
  return !!this.listeners(event).length;
};
const nextTick = (() => {
  const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
  if (isPromiseAvailable) {
    return (cb) => Promise.resolve().then(cb);
  } else {
    return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
  }
})();
const globalThisShim = (() => {
  if (typeof self !== "undefined") {
    return self;
  } else if (typeof window !== "undefined") {
    return window;
  } else {
    return Function("return this")();
  }
})();
const defaultBinaryType = "arraybuffer";
function createCookieJar() {
}
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
const NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
const NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
const BASE64_OVERHEAD = 1.33;
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length += 1;
    } else if (c < 2048) {
      length += 2;
    } else if (c < 55296 || c >= 57344) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length)
        str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length; i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
class TransportError extends Error {
  constructor(reason, description, context) {
    super(reason);
    this.description = description;
    this.context = context;
    this.type = "TransportError";
  }
}
let Transport$1 = class Transport extends Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(opts) {
    super();
    this.writable = false;
    installTimerFunctions(this, opts);
    this.opts = opts;
    this.query = opts.query;
    this.socket = opts.socket;
    this.supportsBinary = !opts.forceBase64;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(reason, description, context) {
    super.emitReserved("error", new TransportError(reason, description, context));
    return this;
  }
  /**
   * Opens the transport.
   */
  open() {
    this.readyState = "opening";
    this.doOpen();
    return this;
  }
  /**
   * Closes the transport.
   */
  close() {
    if (this.readyState === "opening" || this.readyState === "open") {
      this.doClose();
      this.onClose();
    }
    return this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(packets) {
    if (this.readyState === "open") {
      this.write(packets);
    } else {
    }
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open";
    this.writable = true;
    super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(data) {
    const packet = decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(packet) {
    super.emitReserved("packet", packet);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(details) {
    this.readyState = "closed";
    super.emitReserved("close", details);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(onPause) {
  }
  createUri(schema, query = {}) {
    return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
  }
  _hostname() {
    const hostname = this.opts.hostname;
    return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
  }
  _port() {
    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
      return ":" + this.opts.port;
    } else {
      return "";
    }
  }
  _query(query) {
    const encodedQuery = encode(query);
    return encodedQuery.length ? "?" + encodedQuery : "";
  }
};
class Polling extends Transport$1 {
  constructor() {
    super(...arguments);
    this._polling = false;
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this._poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(onPause) {
    this.readyState = "pausing";
    const pause = () => {
      this.readyState = "paused";
      onPause();
    };
    if (this._polling || !this.writable) {
      let total = 0;
      if (this._polling) {
        total++;
        this.once("pollComplete", function() {
          --total || pause();
        });
      }
      if (!this.writable) {
        total++;
        this.once("drain", function() {
          --total || pause();
        });
      }
    } else {
      pause();
    }
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  _poll() {
    this._polling = true;
    this.doPoll();
    this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(data) {
    const callback2 = (packet) => {
      if ("opening" === this.readyState && packet.type === "open") {
        this.onOpen();
      }
      if ("close" === packet.type) {
        this.onClose({ description: "transport closed by the server" });
        return false;
      }
      this.onPacket(packet);
    };
    decodePayload(data, this.socket.binaryType).forEach(callback2);
    if ("closed" !== this.readyState) {
      this._polling = false;
      this.emitReserved("pollComplete");
      if ("open" === this.readyState) {
        this._poll();
      } else {
      }
    }
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const close = () => {
      this.write([{ type: "close" }]);
    };
    if ("open" === this.readyState) {
      close();
    } else {
      this.once("open", close);
    }
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(packets) {
    this.writable = false;
    encodePayload(packets, (data) => {
      this.doWrite(data, () => {
        this.writable = true;
        this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "https" : "http";
    const query = this.query || {};
    if (false !== this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary && !query.sid) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
let value = false;
try {
  value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
} catch (err) {
}
const hasCORS = value;
function empty() {
}
class BaseXHR extends Polling {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(opts) {
    super(opts);
    if (typeof location !== "undefined") {
      const isSSL = "https:" === location.protocol;
      let port = location.port;
      if (!port) {
        port = isSSL ? "443" : "80";
      }
      this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
    }
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(data, fn) {
    const req = this.request({
      method: "POST",
      data
    });
    req.on("success", fn);
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr post error", xhrStatus, context);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    const req = this.request();
    req.on("data", this.onData.bind(this));
    req.on("error", (xhrStatus, context) => {
      this.onError("xhr poll error", xhrStatus, context);
    });
    this.pollXhr = req;
  }
}
class Request extends Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(createRequest, uri, opts) {
    super();
    this.createRequest = createRequest;
    installTimerFunctions(this, opts);
    this._opts = opts;
    this._method = opts.method || "GET";
    this._uri = uri;
    this._data = void 0 !== opts.data ? opts.data : null;
    this._create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  _create() {
    var _a;
    const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    opts.xdomain = !!this._opts.xd;
    const xhr = this._xhr = this.createRequest(opts);
    try {
      xhr.open(this._method, this._uri, true);
      try {
        if (this._opts.extraHeaders) {
          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
          for (let i in this._opts.extraHeaders) {
            if (this._opts.extraHeaders.hasOwnProperty(i)) {
              xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
            }
          }
        }
      } catch (e) {
      }
      if ("POST" === this._method) {
        try {
          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch (e) {
        }
      }
      try {
        xhr.setRequestHeader("Accept", "*/*");
      } catch (e) {
      }
      (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);
      if ("withCredentials" in xhr) {
        xhr.withCredentials = this._opts.withCredentials;
      }
      if (this._opts.requestTimeout) {
        xhr.timeout = this._opts.requestTimeout;
      }
      xhr.onreadystatechange = () => {
        var _a2;
        if (xhr.readyState === 3) {
          (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(
            // @ts-ignore
            xhr.getResponseHeader("set-cookie")
          );
        }
        if (4 !== xhr.readyState)
          return;
        if (200 === xhr.status || 1223 === xhr.status) {
          this._onLoad();
        } else {
          this.setTimeoutFn(() => {
            this._onError(typeof xhr.status === "number" ? xhr.status : 0);
          }, 0);
        }
      };
      xhr.send(this._data);
    } catch (e) {
      this.setTimeoutFn(() => {
        this._onError(e);
      }, 0);
      return;
    }
    if (typeof document !== "undefined") {
      this._index = Request.requestsCount++;
      Request.requests[this._index] = this;
    }
  }
  /**
   * Called upon error.
   *
   * @private
   */
  _onError(err) {
    this.emitReserved("error", err, this._xhr);
    this._cleanup(true);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  _cleanup(fromError) {
    if ("undefined" === typeof this._xhr || null === this._xhr) {
      return;
    }
    this._xhr.onreadystatechange = empty;
    if (fromError) {
      try {
        this._xhr.abort();
      } catch (e) {
      }
    }
    if (typeof document !== "undefined") {
      delete Request.requests[this._index];
    }
    this._xhr = null;
  }
  /**
   * Called upon load.
   *
   * @private
   */
  _onLoad() {
    const data = this._xhr.responseText;
    if (data !== null) {
      this.emitReserved("data", data);
      this.emitReserved("success");
      this._cleanup();
    }
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this._cleanup();
  }
}
Request.requestsCount = 0;
Request.requests = {};
if (typeof document !== "undefined") {
  if (typeof attachEvent === "function") {
    attachEvent("onunload", unloadHandler);
  } else if (typeof addEventListener === "function") {
    const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
    addEventListener(terminationEvent, unloadHandler, false);
  }
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
const hasXHR2 = function() {
  const xhr = newRequest({
    xdomain: false
  });
  return xhr && xhr.responseType !== null;
}();
class XHR extends BaseXHR {
  constructor(opts) {
    super(opts);
    const forceBase64 = opts && opts.forceBase64;
    this.supportsBinary = hasXHR2 && !forceBase64;
  }
  request(opts = {}) {
    Object.assign(opts, { xd: this.xd }, this.opts);
    return new Request(newRequest, this.uri(), opts);
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
const isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
class BaseWS extends Transport$1 {
  get name() {
    return "websocket";
  }
  doOpen() {
    const uri = this.uri();
    const protocols = this.opts.protocols;
    const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    if (this.opts.extraHeaders) {
      opts.headers = this.opts.extraHeaders;
    }
    try {
      this.ws = this.createSocket(uri, protocols, opts);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this.ws.binaryType = this.socket.binaryType;
    this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      if (this.opts.autoUnref) {
        this.ws._socket.unref();
      }
      this.onOpen();
    };
    this.ws.onclose = (closeEvent) => this.onClose({
      description: "websocket connection closed",
      context: closeEvent
    });
    this.ws.onmessage = (ev) => this.onData(ev.data);
    this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      encodePacket(packet, this.supportsBinary, (data) => {
        try {
          this.doWrite(packet, data);
        } catch (e) {
        }
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    if (typeof this.ws !== "undefined") {
      this.ws.onerror = () => {
      };
      this.ws.close();
      this.ws = null;
    }
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const schema = this.opts.secure ? "wss" : "ws";
    const query = this.query || {};
    if (this.opts.timestampRequests) {
      query[this.opts.timestampParam] = randomString();
    }
    if (!this.supportsBinary) {
      query.b64 = 1;
    }
    return this.createUri(schema, query);
  }
}
const WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
class WS extends BaseWS {
  createSocket(uri, protocols, opts) {
    return !isReactNative ? protocols ? new WebSocketCtor(uri, protocols) : new WebSocketCtor(uri) : new WebSocketCtor(uri, protocols, opts);
  }
  doWrite(_packet, data) {
    this.ws.send(data);
  }
}
class WT extends Transport$1 {
  get name() {
    return "webtransport";
  }
  doOpen() {
    try {
      this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
    } catch (err) {
      return this.emitReserved("error", err);
    }
    this._transport.closed.then(() => {
      this.onClose();
    }).catch((err) => {
      this.onError("webtransport error", err);
    });
    this._transport.ready.then(() => {
      this._transport.createBidirectionalStream().then((stream) => {
        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
        const reader = stream.readable.pipeThrough(decoderStream).getReader();
        const encoderStream = createPacketEncoderStream();
        encoderStream.readable.pipeTo(stream.writable);
        this._writer = encoderStream.writable.getWriter();
        const read = () => {
          reader.read().then(({ done, value: value2 }) => {
            if (done) {
              return;
            }
            this.onPacket(value2);
            read();
          }).catch((err) => {
          });
        };
        read();
        const packet = { type: "open" };
        if (this.query.sid) {
          packet.data = `{"sid":"${this.query.sid}"}`;
        }
        this._writer.write(packet).then(() => this.onOpen());
      });
    });
  }
  write(packets) {
    this.writable = false;
    for (let i = 0; i < packets.length; i++) {
      const packet = packets[i];
      const lastPacket = i === packets.length - 1;
      this._writer.write(packet).then(() => {
        if (lastPacket) {
          nextTick(() => {
            this.writable = true;
            this.emitReserved("drain");
          }, this.setTimeoutFn);
        }
      });
    }
  }
  doClose() {
    var _a;
    (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();
  }
}
const transports = {
  websocket: WS,
  webtransport: WT,
  polling: XHR
};
const re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
const parts = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function parse$1(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
const withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
const OFFLINE_EVENT_LISTENERS = [];
if (withEventListeners) {
  addEventListener("offline", () => {
    OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
  }, false);
}
class SocketWithoutUpgrade extends Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(uri, opts) {
    super();
    this.binaryType = defaultBinaryType;
    this.writeBuffer = [];
    this._prevBufferLen = 0;
    this._pingInterval = -1;
    this._pingTimeout = -1;
    this._maxPayload = -1;
    this._pingTimeoutTime = Infinity;
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = null;
    }
    if (uri) {
      const parsedUri = parse$1(uri);
      opts.hostname = parsedUri.host;
      opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
      opts.port = parsedUri.port;
      if (parsedUri.query)
        opts.query = parsedUri.query;
    } else if (opts.host) {
      opts.hostname = parse$1(opts.host).host;
    }
    installTimerFunctions(this, opts);
    this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
    if (opts.hostname && !opts.port) {
      opts.port = this.secure ? "443" : "80";
    }
    this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
    this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
    this.transports = [];
    this._transportsByName = {};
    opts.transports.forEach((t) => {
      const transportName = t.prototype.name;
      this.transports.push(transportName);
      this._transportsByName[transportName] = t;
    });
    this.opts = Object.assign({
      path: "/engine.io",
      agent: false,
      withCredentials: false,
      upgrade: true,
      timestampParam: "t",
      rememberUpgrade: false,
      addTrailingSlash: true,
      rejectUnauthorized: true,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: false
    }, opts);
    this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
    if (typeof this.opts.query === "string") {
      this.opts.query = decode(this.opts.query);
    }
    if (withEventListeners) {
      if (this.opts.closeOnBeforeunload) {
        this._beforeunloadEventListener = () => {
          if (this.transport) {
            this.transport.removeAllListeners();
            this.transport.close();
          }
        };
        addEventListener("beforeunload", this._beforeunloadEventListener, false);
      }
      if (this.hostname !== "localhost") {
        this._offlineEventListener = () => {
          this._onClose("transport close", {
            description: "network connection lost"
          });
        };
        OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
      }
    }
    if (this.opts.withCredentials) {
      this._cookieJar = createCookieJar();
    }
    this._open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(name) {
    const query = Object.assign({}, this.opts.query);
    query.EIO = protocol$2;
    query.transport = name;
    if (this.id)
      query.sid = this.id;
    const opts = Object.assign({}, this.opts, {
      query,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[name]);
    return new this._transportsByName[name](opts);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  _open() {
    if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    }
    const transportName = this.opts.rememberUpgrade && SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
    this.readyState = "opening";
    const transport = this.createTransport(transportName);
    transport.open();
    this.setTransport(transport);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(transport) {
    if (this.transport) {
      this.transport.removeAllListeners();
    }
    this.transport = transport;
    transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    this.readyState = "open";
    SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
    this.emitReserved("open");
    this.flush();
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  _onPacket(packet) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.emitReserved("packet", packet);
      this.emitReserved("heartbeat");
      switch (packet.type) {
        case "open":
          this.onHandshake(JSON.parse(packet.data));
          break;
        case "ping":
          this._sendPacket("pong");
          this.emitReserved("ping");
          this.emitReserved("pong");
          this._resetPingTimeout();
          break;
        case "error":
          const err = new Error("server error");
          err.code = packet.data;
          this._onError(err);
          break;
        case "message":
          this.emitReserved("data", packet.data);
          this.emitReserved("message", packet.data);
          break;
      }
    } else {
    }
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(data) {
    this.emitReserved("handshake", data);
    this.id = data.sid;
    this.transport.query.sid = data.sid;
    this._pingInterval = data.pingInterval;
    this._pingTimeout = data.pingTimeout;
    this._maxPayload = data.maxPayload;
    this.onOpen();
    if ("closed" === this.readyState)
      return;
    this._resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  _resetPingTimeout() {
    this.clearTimeoutFn(this._pingTimeoutTimer);
    const delay = this._pingInterval + this._pingTimeout;
    this._pingTimeoutTime = Date.now() + delay;
    this._pingTimeoutTimer = this.setTimeoutFn(() => {
      this._onClose("ping timeout");
    }, delay);
    if (this.opts.autoUnref) {
      this._pingTimeoutTimer.unref();
    }
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  _onDrain() {
    this.writeBuffer.splice(0, this._prevBufferLen);
    this._prevBufferLen = 0;
    if (0 === this.writeBuffer.length) {
      this.emitReserved("drain");
    } else {
      this.flush();
    }
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const packets = this._getWritablePackets();
      this.transport.send(packets);
      this._prevBufferLen = packets.length;
      this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  _getWritablePackets() {
    const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
    if (!shouldCheckPayloadSize) {
      return this.writeBuffer;
    }
    let payloadSize = 1;
    for (let i = 0; i < this.writeBuffer.length; i++) {
      const data = this.writeBuffer[i].data;
      if (data) {
        payloadSize += byteLength(data);
      }
      if (i > 0 && payloadSize > this._maxPayload) {
        return this.writeBuffer.slice(0, i);
      }
      payloadSize += 2;
    }
    return this.writeBuffer;
  }
  /**
   * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
   *
   * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
   * `write()` method then the message would not be buffered by the Socket.IO client.
   *
   * @return {boolean}
   * @private
   */
  /* private */
  _hasPingExpired() {
    if (!this._pingTimeoutTime)
      return true;
    const hasExpired = Date.now() > this._pingTimeoutTime;
    if (hasExpired) {
      this._pingTimeoutTime = 0;
      nextTick(() => {
        this._onClose("ping timeout");
      }, this.setTimeoutFn);
    }
    return hasExpired;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  write(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a message. Alias of {@link Socket#write}.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @return {Socket} for chaining.
   */
  send(msg, options, fn) {
    this._sendPacket("message", msg, options, fn);
    return this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  _sendPacket(type, data, options, fn) {
    if ("function" === typeof data) {
      fn = data;
      data = void 0;
    }
    if ("function" === typeof options) {
      fn = options;
      options = null;
    }
    if ("closing" === this.readyState || "closed" === this.readyState) {
      return;
    }
    options = options || {};
    options.compress = false !== options.compress;
    const packet = {
      type,
      data,
      options
    };
    this.emitReserved("packetCreate", packet);
    this.writeBuffer.push(packet);
    if (fn)
      this.once("flush", fn);
    this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const close = () => {
      this._onClose("forced close");
      this.transport.close();
    };
    const cleanupAndClose = () => {
      this.off("upgrade", cleanupAndClose);
      this.off("upgradeError", cleanupAndClose);
      close();
    };
    const waitForUpgrade = () => {
      this.once("upgrade", cleanupAndClose);
      this.once("upgradeError", cleanupAndClose);
    };
    if ("opening" === this.readyState || "open" === this.readyState) {
      this.readyState = "closing";
      if (this.writeBuffer.length) {
        this.once("drain", () => {
          if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        });
      } else if (this.upgrading) {
        waitForUpgrade();
      } else {
        close();
      }
    }
    return this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  _onError(err) {
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
      this.transports.shift();
      return this._open();
    }
    this.emitReserved("error", err);
    this._onClose("transport error", err);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  _onClose(reason, description) {
    if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
      this.clearTimeoutFn(this._pingTimeoutTimer);
      this.transport.removeAllListeners("close");
      this.transport.close();
      this.transport.removeAllListeners();
      if (withEventListeners) {
        if (this._beforeunloadEventListener) {
          removeEventListener("beforeunload", this._beforeunloadEventListener, false);
        }
        if (this._offlineEventListener) {
          const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
          if (i !== -1) {
            OFFLINE_EVENT_LISTENERS.splice(i, 1);
          }
        }
      }
      this.readyState = "closed";
      this.id = null;
      this.emitReserved("close", reason, description);
      this.writeBuffer = [];
      this._prevBufferLen = 0;
    }
  }
}
SocketWithoutUpgrade.protocol = protocol$2;
class SocketWithUpgrade extends SocketWithoutUpgrade {
  constructor() {
    super(...arguments);
    this._upgrades = [];
  }
  onOpen() {
    super.onOpen();
    if ("open" === this.readyState && this.opts.upgrade) {
      for (let i = 0; i < this._upgrades.length; i++) {
        this._probe(this._upgrades[i]);
      }
    }
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  _probe(name) {
    let transport = this.createTransport(name);
    let failed = false;
    SocketWithoutUpgrade.priorWebsocketSuccess = false;
    const onTransportOpen = () => {
      if (failed)
        return;
      transport.send([{ type: "ping", data: "probe" }]);
      transport.once("packet", (msg) => {
        if (failed)
          return;
        if ("pong" === msg.type && "probe" === msg.data) {
          this.upgrading = true;
          this.emitReserved("upgrading", transport);
          if (!transport)
            return;
          SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
          this.transport.pause(() => {
            if (failed)
              return;
            if ("closed" === this.readyState)
              return;
            cleanup();
            this.setTransport(transport);
            transport.send([{ type: "upgrade" }]);
            this.emitReserved("upgrade", transport);
            transport = null;
            this.upgrading = false;
            this.flush();
          });
        } else {
          const err = new Error("probe error");
          err.transport = transport.name;
          this.emitReserved("upgradeError", err);
        }
      });
    };
    function freezeTransport() {
      if (failed)
        return;
      failed = true;
      cleanup();
      transport.close();
      transport = null;
    }
    const onerror = (err) => {
      const error = new Error("probe error: " + err);
      error.transport = transport.name;
      freezeTransport();
      this.emitReserved("upgradeError", error);
    };
    function onTransportClose() {
      onerror("transport closed");
    }
    function onclose() {
      onerror("socket closed");
    }
    function onupgrade(to) {
      if (transport && to.name !== transport.name) {
        freezeTransport();
      }
    }
    const cleanup = () => {
      transport.removeListener("open", onTransportOpen);
      transport.removeListener("error", onerror);
      transport.removeListener("close", onTransportClose);
      this.off("close", onclose);
      this.off("upgrading", onupgrade);
    };
    transport.once("open", onTransportOpen);
    transport.once("error", onerror);
    transport.once("close", onTransportClose);
    this.once("close", onclose);
    this.once("upgrading", onupgrade);
    if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
      this.setTimeoutFn(() => {
        if (!failed) {
          transport.open();
        }
      }, 200);
    } else {
      transport.open();
    }
  }
  onHandshake(data) {
    this._upgrades = this._filterUpgrades(data.upgrades);
    super.onHandshake(data);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  _filterUpgrades(upgrades) {
    const filteredUpgrades = [];
    for (let i = 0; i < upgrades.length; i++) {
      if (~this.transports.indexOf(upgrades[i]))
        filteredUpgrades.push(upgrades[i]);
    }
    return filteredUpgrades;
  }
}
let Socket$1 = class Socket extends SocketWithUpgrade {
  constructor(uri, opts = {}) {
    const o = typeof uri === "object" ? uri : opts;
    if (!o.transports || o.transports && typeof o.transports[0] === "string") {
      o.transports = (o.transports || ["polling", "websocket", "webtransport"]).map((transportName) => transports[transportName]).filter((t) => !!t);
    }
    super(uri, o);
  }
};
class Fetch extends Polling {
  doPoll() {
    this._fetch().then((res) => {
      if (!res.ok) {
        return this.onError("fetch read error", res.status, res);
      }
      res.text().then((data) => this.onData(data));
    }).catch((err) => {
      this.onError("fetch read error", err);
    });
  }
  doWrite(data, callback2) {
    this._fetch(data).then((res) => {
      if (!res.ok) {
        return this.onError("fetch write error", res.status, res);
      }
      callback2();
    }).catch((err) => {
      this.onError("fetch write error", err);
    });
  }
  _fetch(data) {
    var _a;
    const isPost = data !== void 0;
    const headers = new Headers(this.opts.extraHeaders);
    if (isPost) {
      headers.set("content-type", "text/plain;charset=UTF-8");
    }
    (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);
    return fetch(this.uri(), {
      method: isPost ? "POST" : "GET",
      body: isPost ? data : null,
      headers,
      credentials: this.opts.withCredentials ? "include" : "omit"
    }).then((res) => {
      var _a2;
      (_a2 = this.socket._cookieJar) === null || _a2 === void 0 ? void 0 : _a2.parseCookies(res.headers.getSetCookie());
      return res;
    });
  }
}
const protocol$1 = Socket$1.protocol;
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri)
    uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    obj = parse$1(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
const withNativeArrayBuffer = typeof ArrayBuffer === "function";
const isView = (obj) => {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};
const toString = Object.prototype.toString;
const withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
const withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return { packet: pack, buffers };
}
function _deconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (isBinary(data)) {
    const placeholder = { _placeholder: true, num: buffers.length };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data)
    return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
const RESERVED_EVENTS$1 = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
  // used by the Node.js EventEmitter
];
const protocol = 5;
var PacketType;
(function(PacketType2) {
  PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
  PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
  PacketType2[PacketType2["ACK"] = 3] = "ACK";
  PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType || (PacketType = {}));
class Encoder {
  /**
   * Encoder constructor
   *
   * @param {function} replacer - custom replacer to pass down to JSON.parse
   */
  constructor(replacer) {
    this.replacer = replacer;
  }
  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   */
  encode(obj) {
    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
      if (hasBinary(obj)) {
        return this.encodeAsBinary({
          type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
          nsp: obj.nsp,
          data: obj.data,
          id: obj.id
        });
      }
    }
    return [this.encodeAsString(obj)];
  }
  /**
   * Encode packet as string.
   */
  encodeAsString(obj) {
    let str = "" + obj.type;
    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
      str += obj.attachments + "-";
    }
    if (obj.nsp && "/" !== obj.nsp) {
      str += obj.nsp + ",";
    }
    if (null != obj.id) {
      str += obj.id;
    }
    if (null != obj.data) {
      str += JSON.stringify(obj.data, this.replacer);
    }
    return str;
  }
  /**
   * Encode packet as 'buffer sequence' by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   */
  encodeAsBinary(obj) {
    const deconstruction = deconstructPacket(obj);
    const pack = this.encodeAsString(deconstruction.packet);
    const buffers = deconstruction.buffers;
    buffers.unshift(pack);
    return buffers;
  }
}
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
class Decoder extends Emitter {
  /**
   * Decoder constructor
   *
   * @param {function} reviver - custom reviver to pass down to JSON.stringify
   */
  constructor(reviver) {
    super();
    this.reviver = reviver;
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */
  add(obj) {
    let packet;
    if (typeof obj === "string") {
      if (this.reconstructor) {
        throw new Error("got plaintext data when reconstructing a packet");
      }
      packet = this.decodeString(obj);
      const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
      if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
        packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
        this.reconstructor = new BinaryReconstructor(packet);
        if (packet.attachments === 0) {
          super.emitReserved("decoded", packet);
        }
      } else {
        super.emitReserved("decoded", packet);
      }
    } else if (isBinary(obj) || obj.base64) {
      if (!this.reconstructor) {
        throw new Error("got binary data when not reconstructing a packet");
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) {
          this.reconstructor = null;
          super.emitReserved("decoded", packet);
        }
      }
    } else {
      throw new Error("Unknown type: " + obj);
    }
  }
  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   */
  decodeString(str) {
    let i = 0;
    const p = {
      type: Number(str.charAt(0))
    };
    if (PacketType[p.type] === void 0) {
      throw new Error("unknown packet type " + p.type);
    }
    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
      const start2 = i + 1;
      while (str.charAt(++i) !== "-" && i != str.length) {
      }
      const buf = str.substring(start2, i);
      if (buf != Number(buf) || str.charAt(i) !== "-") {
        throw new Error("Illegal attachments");
      }
      p.attachments = Number(buf);
    }
    if ("/" === str.charAt(i + 1)) {
      const start2 = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if ("," === c)
          break;
        if (i === str.length)
          break;
      }
      p.nsp = str.substring(start2, i);
    } else {
      p.nsp = "/";
    }
    const next = str.charAt(i + 1);
    if ("" !== next && Number(next) == next) {
      const start2 = i + 1;
      while (++i) {
        const c = str.charAt(i);
        if (null == c || Number(c) != c) {
          --i;
          break;
        }
        if (i === str.length)
          break;
      }
      p.id = Number(str.substring(start2, i + 1));
    }
    if (str.charAt(++i)) {
      const payload = this.tryParse(str.substr(i));
      if (Decoder.isPayloadValid(p.type, payload)) {
        p.data = payload;
      } else {
        throw new Error("invalid payload");
      }
    }
    return p;
  }
  tryParse(str) {
    try {
      return JSON.parse(str, this.reviver);
    } catch (e) {
      return false;
    }
  }
  static isPayloadValid(type, payload) {
    switch (type) {
      case PacketType.CONNECT:
        return isObject(payload);
      case PacketType.DISCONNECT:
        return payload === void 0;
      case PacketType.CONNECT_ERROR:
        return typeof payload === "string" || isObject(payload);
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        return Array.isArray(payload);
    }
  }
  /**
   * Deallocates a parser's resources
   */
  destroy() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
      this.reconstructor = null;
    }
  }
}
class BinaryReconstructor {
  constructor(packet) {
    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */
  takeBinaryData(binData) {
    this.buffers.push(binData);
    if (this.buffers.length === this.reconPack.attachments) {
      const packet = reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  }
  /**
   * Cleans up binary packet reconstruction variables.
   */
  finishedReconstruction() {
    this.reconPack = null;
    this.buffers = [];
  }
}
const parser$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Decoder,
  Encoder,
  get PacketType() {
    return PacketType;
  },
  protocol
}, Symbol.toStringTag, { value: "Module" }));
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return function subDestroy() {
    obj.off(ev, fn);
  };
}
const RESERVED_EVENTS = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class Socket2 extends Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(io, nsp, opts) {
    super();
    this.connected = false;
    this.recovered = false;
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this._queue = [];
    this._queueSeq = 0;
    this.ids = 0;
    this.acks = {};
    this.flags = {};
    this.io = io;
    this.nsp = nsp;
    if (opts && opts.auth) {
      this.auth = opts.auth;
    }
    this._opts = Object.assign({}, opts);
    if (this.io._autoConnect)
      this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const io = this.io;
    this.subs = [
      on(io, "open", this.onopen.bind(this)),
      on(io, "packet", this.onpacket.bind(this)),
      on(io, "error", this.onerror.bind(this)),
      on(io, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    if (this.connected)
      return this;
    this.subEvents();
    if (!this.io["_reconnecting"])
      this.io.open();
    if ("open" === this.io._readyState)
      this.onopen();
    return this;
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...args) {
    args.unshift("message");
    this.emit.apply(this, args);
    return this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(ev, ...args) {
    var _a, _b, _c;
    if (RESERVED_EVENTS.hasOwnProperty(ev)) {
      throw new Error('"' + ev.toString() + '" is a reserved event name');
    }
    args.unshift(ev);
    if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
      this._addToQueue(args);
      return this;
    }
    const packet = {
      type: PacketType.EVENT,
      data: args
    };
    packet.options = {};
    packet.options.compress = this.flags.compress !== false;
    if ("function" === typeof args[args.length - 1]) {
      const id = this.ids++;
      const ack = args.pop();
      this._registerAckCallback(id, ack);
      packet.id = id;
    }
    const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;
    const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());
    const discardPacket = this.flags.volatile && !isTransportWritable;
    if (discardPacket) {
    } else if (isConnected) {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }
    this.flags = {};
    return this;
  }
  /**
   * @private
   */
  _registerAckCallback(id, ack) {
    var _a;
    const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;
    if (timeout === void 0) {
      this.acks[id] = ack;
      return;
    }
    const timer = this.io.setTimeoutFn(() => {
      delete this.acks[id];
      for (let i = 0; i < this.sendBuffer.length; i++) {
        if (this.sendBuffer[i].id === id) {
          this.sendBuffer.splice(i, 1);
        }
      }
      ack.call(this, new Error("operation has timed out"));
    }, timeout);
    const fn = (...args) => {
      this.io.clearTimeoutFn(timer);
      ack.apply(this, args);
    };
    fn.withError = true;
    this.acks[id] = fn;
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(ev, ...args) {
    return new Promise((resolve, reject) => {
      const fn = (arg1, arg2) => {
        return arg1 ? reject(arg1) : resolve(arg2);
      };
      fn.withError = true;
      args.push(fn);
      this.emit(ev, ...args);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(args) {
    let ack;
    if (typeof args[args.length - 1] === "function") {
      ack = args.pop();
    }
    const packet = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: false,
      args,
      flags: Object.assign({ fromQueue: true }, this.flags)
    };
    args.push((err, ...responseArgs) => {
      if (packet !== this._queue[0]) {
        return;
      }
      const hasError = err !== null;
      if (hasError) {
        if (packet.tryCount > this._opts.retries) {
          this._queue.shift();
          if (ack) {
            ack(err);
          }
        }
      } else {
        this._queue.shift();
        if (ack) {
          ack(null, ...responseArgs);
        }
      }
      packet.pending = false;
      return this._drainQueue();
    });
    this._queue.push(packet);
    this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(force = false) {
    if (!this.connected || this._queue.length === 0) {
      return;
    }
    const packet = this._queue[0];
    if (packet.pending && !force) {
      return;
    }
    packet.pending = true;
    packet.tryCount++;
    this.flags = packet.flags;
    this.emit.apply(this, packet.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(packet) {
    packet.nsp = this.nsp;
    this.io._packet(packet);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    if (typeof this.auth == "function") {
      this.auth((data) => {
        this._sendConnectPacket(data);
      });
    } else {
      this._sendConnectPacket(this.auth);
    }
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(data) {
    this.packet({
      type: PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data) : data
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(err) {
    if (!this.connected) {
      this.emitReserved("connect_error", err);
    }
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(reason, description) {
    this.connected = false;
    delete this.id;
    this.emitReserved("disconnect", reason, description);
    this._clearAcks();
  }
  /**
   * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
   * the server.
   *
   * @private
   */
  _clearAcks() {
    Object.keys(this.acks).forEach((id) => {
      const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
      if (!isBuffered) {
        const ack = this.acks[id];
        delete this.acks[id];
        if (ack.withError) {
          ack.call(this, new Error("socket has been disconnected"));
        }
      }
    });
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(packet) {
    const sameNamespace = packet.nsp === this.nsp;
    if (!sameNamespace)
      return;
    switch (packet.type) {
      case PacketType.CONNECT:
        if (packet.data && packet.data.sid) {
          this.onconnect(packet.data.sid, packet.data.pid);
        } else {
          this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
        }
        break;
      case PacketType.EVENT:
      case PacketType.BINARY_EVENT:
        this.onevent(packet);
        break;
      case PacketType.ACK:
      case PacketType.BINARY_ACK:
        this.onack(packet);
        break;
      case PacketType.DISCONNECT:
        this.ondisconnect();
        break;
      case PacketType.CONNECT_ERROR:
        this.destroy();
        const err = new Error(packet.data.message);
        err.data = packet.data.data;
        this.emitReserved("connect_error", err);
        break;
    }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(packet) {
    const args = packet.data || [];
    if (null != packet.id) {
      args.push(this.ack(packet.id));
    }
    if (this.connected) {
      this.emitEvent(args);
    } else {
      this.receiveBuffer.push(Object.freeze(args));
    }
  }
  emitEvent(args) {
    if (this._anyListeners && this._anyListeners.length) {
      const listeners = this._anyListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
    super.emit.apply(this, args);
    if (this._pid && args.length && typeof args[args.length - 1] === "string") {
      this._lastOffset = args[args.length - 1];
    }
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(id) {
    const self2 = this;
    let sent = false;
    return function(...args) {
      if (sent)
        return;
      sent = true;
      self2.packet({
        type: PacketType.ACK,
        id,
        data: args
      });
    };
  }
  /**
   * Called upon a server acknowledgement.
   *
   * @param packet
   * @private
   */
  onack(packet) {
    const ack = this.acks[packet.id];
    if (typeof ack !== "function") {
      return;
    }
    delete this.acks[packet.id];
    if (ack.withError) {
      packet.data.unshift(null);
    }
    ack.apply(this, packet.data);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(id, pid) {
    this.id = id;
    this.recovered = pid && this._pid === pid;
    this._pid = pid;
    this.connected = true;
    this.emitBuffered();
    this.emitReserved("connect");
    this._drainQueue(true);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((args) => this.emitEvent(args));
    this.receiveBuffer = [];
    this.sendBuffer.forEach((packet) => {
      this.notifyOutgoingListeners(packet);
      this.packet(packet);
    });
    this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    this.destroy();
    this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    if (this.subs) {
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs = void 0;
    }
    this.io["_destroy"](this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    if (this.connected) {
      this.packet({ type: PacketType.DISCONNECT });
    }
    this.destroy();
    if (this.connected) {
      this.onclose("io client disconnect");
    }
    return this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(compress) {
    this.flags.compress = compress;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    this.flags.volatile = true;
    return this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(timeout) {
    this.flags.timeout = timeout;
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(listener) {
    this._anyListeners = this._anyListeners || [];
    this._anyListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(listener) {
    if (!this._anyListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.push(listener);
    return this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(listener) {
    this._anyOutgoingListeners = this._anyOutgoingListeners || [];
    this._anyOutgoingListeners.unshift(listener);
    return this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(listener) {
    if (!this._anyOutgoingListeners) {
      return this;
    }
    if (listener) {
      const listeners = this._anyOutgoingListeners;
      for (let i = 0; i < listeners.length; i++) {
        if (listener === listeners[i]) {
          listeners.splice(i, 1);
          return this;
        }
      }
    } else {
      this._anyOutgoingListeners = [];
    }
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(packet) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const listeners = this._anyOutgoingListeners.slice();
      for (const listener of listeners) {
        listener.apply(this, packet.data);
      }
    }
  }
}
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff.prototype.duration = function() {
  var ms2 = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms2);
    ms2 = (Math.floor(rand * 10) & 1) == 0 ? ms2 - deviation : ms2 + deviation;
  }
  return Math.min(ms2, this.max) | 0;
};
Backoff.prototype.reset = function() {
  this.attempts = 0;
};
Backoff.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff.prototype.setMax = function(max2) {
  this.max = max2;
};
Backoff.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
class Manager extends Emitter {
  constructor(uri, opts) {
    var _a;
    super();
    this.nsps = {};
    this.subs = [];
    if (uri && "object" === typeof uri) {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    opts.path = opts.path || "/socket.io";
    this.opts = opts;
    installTimerFunctions(this, opts);
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1e3);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
    this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
    this._readyState = "closed";
    this.uri = uri;
    const _parser = opts.parser || parser$1;
    this.encoder = new _parser.Encoder();
    this.decoder = new _parser.Decoder();
    this._autoConnect = opts.autoConnect !== false;
    if (this._autoConnect)
      this.open();
  }
  reconnection(v) {
    if (!arguments.length)
      return this._reconnection;
    this._reconnection = !!v;
    if (!v) {
      this.skipReconnect = true;
    }
    return this;
  }
  reconnectionAttempts(v) {
    if (v === void 0)
      return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  }
  reconnectionDelay(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelay;
    this._reconnectionDelay = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
    return this;
  }
  randomizationFactor(v) {
    var _a;
    if (v === void 0)
      return this._randomizationFactor;
    this._randomizationFactor = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
    return this;
  }
  reconnectionDelayMax(v) {
    var _a;
    if (v === void 0)
      return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
    return this;
  }
  timeout(v) {
    if (!arguments.length)
      return this._timeout;
    this._timeout = v;
    return this;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
      this.reconnect();
    }
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(fn) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Socket$1(this.uri, this.opts);
    const socket = this.engine;
    const self2 = this;
    this._readyState = "opening";
    this.skipReconnect = false;
    const openSubDestroy = on(socket, "open", function() {
      self2.onopen();
      fn && fn();
    });
    const onError = (err) => {
      this.cleanup();
      this._readyState = "closed";
      this.emitReserved("error", err);
      if (fn) {
        fn(err);
      } else {
        this.maybeReconnectOnOpen();
      }
    };
    const errorSub = on(socket, "error", onError);
    if (false !== this._timeout) {
      const timeout = this._timeout;
      const timer = this.setTimeoutFn(() => {
        openSubDestroy();
        onError(new Error("timeout"));
        socket.close();
      }, timeout);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
    this.subs.push(openSubDestroy);
    this.subs.push(errorSub);
    return this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(fn) {
    return this.open(fn);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    this.cleanup();
    this._readyState = "open";
    this.emitReserved("open");
    const socket = this.engine;
    this.subs.push(
      on(socket, "ping", this.onping.bind(this)),
      on(socket, "data", this.ondata.bind(this)),
      on(socket, "error", this.onerror.bind(this)),
      on(socket, "close", this.onclose.bind(this)),
      // @ts-ignore
      on(this.decoder, "decoded", this.ondecoded.bind(this))
    );
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(data) {
    try {
      this.decoder.add(data);
    } catch (e) {
      this.onclose("parse error", e);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(packet) {
    nextTick(() => {
      this.emitReserved("packet", packet);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(err) {
    this.emitReserved("error", err);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(nsp, opts) {
    let socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket2(this, nsp, opts);
      this.nsps[nsp] = socket;
    } else if (this._autoConnect && !socket.active) {
      socket.connect();
    }
    return socket;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(socket) {
    const nsps = Object.keys(this.nsps);
    for (const nsp of nsps) {
      const socket2 = this.nsps[nsp];
      if (socket2.active) {
        return;
      }
    }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(packet) {
    const encodedPackets = this.encoder.encode(packet);
    for (let i = 0; i < encodedPackets.length; i++) {
      this.engine.write(encodedPackets[i], packet.options);
    }
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    this.subs.forEach((subDestroy) => subDestroy());
    this.subs.length = 0;
    this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    this.skipReconnect = true;
    this._reconnecting = false;
    this.onclose("forced close");
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called when:
   *
   * - the low-level engine is closed
   * - the parser encountered a badly formatted packet
   * - all sockets are disconnected
   *
   * @private
   */
  onclose(reason, description) {
    var _a;
    this.cleanup();
    (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();
    this.backoff.reset();
    this._readyState = "closed";
    this.emitReserved("close", reason, description);
    if (this._reconnection && !this.skipReconnect) {
      this.reconnect();
    }
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const self2 = this;
    if (this.backoff.attempts >= this._reconnectionAttempts) {
      this.backoff.reset();
      this.emitReserved("reconnect_failed");
      this._reconnecting = false;
    } else {
      const delay = this.backoff.duration();
      this._reconnecting = true;
      const timer = this.setTimeoutFn(() => {
        if (self2.skipReconnect)
          return;
        this.emitReserved("reconnect_attempt", self2.backoff.attempts);
        if (self2.skipReconnect)
          return;
        self2.open((err) => {
          if (err) {
            self2._reconnecting = false;
            self2.reconnect();
            this.emitReserved("reconnect_error", err);
          } else {
            self2.onreconnect();
          }
        });
      }, delay);
      if (this.opts.autoUnref) {
        timer.unref();
      }
      this.subs.push(() => {
        this.clearTimeoutFn(timer);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const attempt = this.backoff.attempts;
    this._reconnecting = false;
    this.backoff.reset();
    this.emitReserved("reconnect", attempt);
  }
}
const cache = {};
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
Object.assign(lookup, {
  Manager,
  Socket: Socket2,
  io: lookup,
  connect: lookup
});
socketHandler.setRayeReceive = function(model) {
  const user = globalModel.users.find((x) => x.id == model.id);
  if (!user) return;
  const el = document.querySelector(`.itemMain${user.row} .itemImg`);
  if (!el) return;
  const divEl = document.createElement("div");
  divEl.className = `raygiriIcon imgStatus icon-hand`;
  el.appendChild(divEl);
};
socketHandler.rayegiriReceive = function(model) {
  rayegiri(model, "rayeDefae");
};
socketHandler.rayeKhorojReceive = function(model) {
  rayegiri(model, "rayeKhoroj");
  if (vm.$refs.childmain.door != "رای‌خروج")
    vm.$refs.childmain.door = "رای‌خروج";
};
function rayegiri(model, type) {
  if (model.type == "end") {
    main.reset();
    const elements = document.querySelectorAll(".raygiriIcon");
    elements.forEach((element) => {
      element.remove();
    });
    globalModel.activeUser = {};
    vm.$refs.childmain.raye = false;
    return;
  }
  globalModel.activeUser = {
    index: model.activeUser,
    row: model.activeUser + 1,
    type
  };
  if (model.type == "wait") {
    main.getDefensePosition();
  }
  if (model.type == "start") {
    globalModel.room.wait = model.wait;
    main.topTimeProgress(-100);
  }
  if (model.type == "start" && globalModel.user.userInGameStatus == 1 && model.activeUser != globalModel.user.index) {
    vm.$refs.childmain.raye = true;
  } else
    vm.$refs.childmain.raye = false;
}
socketHandler.defaeListReceive = function(model) {
};
socketHandler.defaeReceive = function(model) {
  defaeStream(model, "defaeReceive");
  if (vm.$refs.childmain.door != "دفاع")
    vm.$refs.childmain.door = "دفاع";
};
socketHandler.khorojReceive = function(model) {
  defaeStream(model, "khorojReceive");
  if (model.type == "start") {
    if (vm.$refs.childmain.door != "وصیت")
      vm.$refs.childmain.door = "وصیت";
    if (globalModel.user.index == model.activeUser)
      globalModel.khorojHadseNaghsh = true;
  }
  if (model.type == "end") {
    vm.$refs.childmain.door = "----";
    globalModel.khorojHadseNaghsh = false;
    setUserInGameStatus(model.activeUser, 2);
  }
};
function setUserInGameStatus(activeUser, userInGameStatus) {
  globalModel.users.map((x) => {
    if (x.index == activeUser)
      x.userInGameStatus = userInGameStatus;
  });
  vm.$refs.childmain.users = globalModel.users;
  if (globalModel.user.index == activeUser) {
    globalModel.user.userInGameStatus = userInGameStatus;
    vm.$refs.childmain.user = globalModel.user;
  }
}
function defaeStream(model, type) {
  if (model.type == "end") {
    main.reset();
    vm.$refs.childmain.soundDivI = false;
    vm.$refs.childitemclick.isAddTarget = false;
    socketHandler.closelObj();
    globalModel.activeUser = {};
    main.stream = null;
    return;
  }
  globalModel.activeUser = {
    index: model.activeUser,
    row: model.activeUser + 1,
    type
  };
  if (model.type == "wait") {
    main.getDefensePosition();
  }
  if (model.type == "start") {
    vm.$refs.childitemclick.isAddTarget = true;
    vm.$refs.childmain.soundDivI = true;
    globalModel.room.wait = model.wait;
    main.topTimeProgress(-100);
  }
}
socketHandler.setKalantarShotReceive = function(model) {
  const kalantar = globalModel.users.find((x) => x.id == model.user1);
  const user = globalModel.users.find((x) => x.id == model.user2);
  const naghsh2 = model.user2Type < 20 ? '<span style="color:var(--NaghshSefidColor)"> شهروند </span>' : '<span style="color:var(--NaghshSiahColor)"> مافیا </span>';
  const html = `<div style="margin: 10px 0;"> ${kalantar.info.UserName} با نقش <span style="color:var(--NaghshSefidColor)"> کلانتر </span> به ${user.info.UserName} در گروه ${naghsh2} شلیک و از بازی خارج کرد</div>`;
  setUserInGameStatus(user.index, 2);
  if (globalModel.user.index == kalantar.index) {
    globalModel.groupItem.shot = false;
  }
  elModal$1({ model: html });
};
socketHandler.setHadseNaghshReceive = function(model) {
  const user1 = globalModel.users.find((x) => x.id == model.user1);
  const user2 = globalModel.users.find((x) => x.id == model.user2);
  const html = model.type ? '<div style="margin: 10px 0;">گروه مافیا یک نفر را بوسیله حدس نقش از بازی خارج کرد</div>' : '<div style="margin: 10px 0;">تلاش مافیا برای حدس نقش ناموفق بود</div>';
  const backgroundColor = model.type ? "#5a0202" : "#025a16";
  const index2 = model.type ? user2.index : user1.index;
  if (globalModel.user.index == user1.index) {
    globalModel.groupItem.hadseNaghsh = false;
  }
  setUserInGameStatus(index2, 2);
  elModal$1({ model: html, backgroundColor });
};
function elModal$1({ model = "", backgroundColor = null, time = 7e3, className = "" } = {}) {
  const divEl = document.createElement("div");
  divEl.className = `modalBady ${className}`;
  if (backgroundColor) divEl.style.backgroundColor = backgroundColor;
  divEl.innerHTML = model;
  document.body.appendChild(divEl);
  setTimeout(() => {
    divEl.remove();
  }, time);
}
socketHandler.estelamReceive = function(model) {
  if (model.type == "start" && globalModel.user.userInGameStatus == 1) {
    const html = `<div style="margin: 10px 0;text-align: center;">ایا استعلام میخواهید؟</div><div style="margin: 10px 0;" class="d-flex"><button class="btn btn-green" onclick="socketHandler.estelamAdd()">بله</button><button class="btn btn-red" onclick="socketHandler.estelamRemove()">خیر</button></div>`;
    elModal$1({ model: html, className: "estelamAdd", time: model.wait * 1e3 });
    setTimeout(() => {
      const elements = document.querySelectorAll(".raygiriIcon");
      elements.forEach((element) => {
        element.remove();
      });
    }, model.wait * 1e3);
  }
  if (model.type == "result") {
    const elements = document.querySelectorAll(".raygiriIcon");
    elements.forEach((element) => {
      element.remove();
    });
    const html = `<div style="margin: 10px 0;text-align: center;">از بازی شما </div><div style="margin: 10px 0;text-align: center;">
        <span style="color:var(--NaghshSefidColor)">${model.shahr} </span> شهروند
        <span style="color:var(--NaghshSiahColor)">${model.mafia} </span> مافیا
        </div><div style="margin: 10px 0;text-align: center;">بیرون هستند</div>`;
    elModal$1({ model: html, className: "estelamResult", time: model.wait * 1e3 });
  }
  globalModel.room.wait = model.wait;
  main.topTimeProgress(-100);
};
socketHandler.setEstelamReceive = function(model) {
  socketHandler.setRayeReceive({ id: model.userId });
};
socketHandler.estelamRemove = function() {
  const elements = document.querySelectorAll(".estelamAdd");
  elements.forEach((element) => {
    element.remove();
  });
};
socketHandler.estelamAdd = function() {
  socketHandler.estelamRemove();
  globalModel.connection.emit("setEstelam", {
    roomId: socketHandler.roomId,
    userKey: socketHandler.userKey
  });
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getDefaultExportFromNamespaceIfPresent(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") ? n["default"] : n;
}
function getDefaultExportFromNamespaceIfNotNamed(n) {
  return n && Object.prototype.hasOwnProperty.call(n, "default") && Object.keys(n).length === 1 ? n["default"] : n;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var lib$4 = {};
var browser$1 = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index2];
            match = formatter.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var browser = browser$1.exports;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$1.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    var define_process_env_default = {};
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = define_process_env_default.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  "use strict";
  Object.defineProperty(types, "__esModule", { value: true });
  return types;
}
var Device = {};
var Logger$2 = {};
var hasRequiredLogger$2;
function requireLogger$2() {
  if (hasRequiredLogger$2) return Logger$2;
  hasRequiredLogger$2 = 1;
  "use strict";
  Object.defineProperty(Logger$2, "__esModule", { value: true });
  Logger$2.Logger = void 0;
  const debug_1 = requireBrowser();
  const APP_NAME = "mediasoup-client";
  class Logger2 {
    constructor(prefix) {
      __publicField(this, "_debug");
      __publicField(this, "_warn");
      __publicField(this, "_error");
      if (prefix) {
        this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
        this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
        this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
      } else {
        this._debug = (0, debug_1.default)(APP_NAME);
        this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
        this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
      }
      this._debug.log = console.info.bind(console);
      this._warn.log = console.warn.bind(console);
      this._error.log = console.error.bind(console);
    }
    get debug() {
      return this._debug;
    }
    get warn() {
      return this._warn;
    }
    get error() {
      return this._error;
    }
  }
  Logger$2.Logger = Logger2;
  return Logger$2;
}
var enhancedEvents = {};
var events$1 = { exports: {} };
var events = events$1.exports;
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events$1.exports;
  hasRequiredEvents = 1;
  "use strict";
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value2) {
    return value2 !== value2;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  events$1.exports = EventEmitter;
  events$1.exports.once = once;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = type === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type];
    }
    if (existing === void 0) {
      existing = events2[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type, listener) {
    var state = { fired: false, wrapFn: void 0, target, type, listener };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once2(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type];
        if (events2.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events2, i;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events2);
      var key;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners !== void 0) {
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type, listeners[i]);
      }
    }
    return this;
  };
  function _listeners(target, type, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }
  function spliceOne(list, index2) {
    for (; index2 + 1 < list.length; index2++)
      list[index2] = list[index2 + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      ;
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events$1.exports;
}
var hasRequiredEnhancedEvents;
function requireEnhancedEvents() {
  if (hasRequiredEnhancedEvents) return enhancedEvents;
  hasRequiredEnhancedEvents = 1;
  "use strict";
  Object.defineProperty(enhancedEvents, "__esModule", { value: true });
  enhancedEvents.EnhancedEventEmitter = void 0;
  const events_alias_1 = requireEvents();
  const Logger_1 = requireLogger$2();
  const enhancedEventEmitterLogger = new Logger_1.Logger("EnhancedEventEmitter");
  class EnhancedEventEmitter extends events_alias_1.EventEmitter {
    constructor() {
      super();
      this.setMaxListeners(Infinity);
    }
    /**
     * Empties all stored event listeners.
     */
    close() {
      super.removeAllListeners();
    }
    emit(eventName, ...args) {
      return super.emit(eventName, ...args);
    }
    /**
     * Special addition to the EventEmitter API.
     */
    safeEmit(eventName, ...args) {
      try {
        return super.emit(eventName, ...args);
      } catch (error) {
        enhancedEventEmitterLogger.error("safeEmit() | event listener threw an error [eventName:%s]:%o", eventName, error);
        try {
          super.emit("listenererror", eventName, error);
        } catch (error2) {
        }
        return Boolean(super.listenerCount(eventName));
      }
    }
    on(eventName, listener) {
      super.on(eventName, listener);
      return this;
    }
    off(eventName, listener) {
      super.off(eventName, listener);
      return this;
    }
    addListener(eventName, listener) {
      super.on(eventName, listener);
      return this;
    }
    prependListener(eventName, listener) {
      super.prependListener(eventName, listener);
      return this;
    }
    once(eventName, listener) {
      super.once(eventName, listener);
      return this;
    }
    prependOnceListener(eventName, listener) {
      super.prependOnceListener(eventName, listener);
      return this;
    }
    removeListener(eventName, listener) {
      super.off(eventName, listener);
      return this;
    }
    removeAllListeners(eventName) {
      super.removeAllListeners(eventName);
      return this;
    }
    listenerCount(eventName) {
      return super.listenerCount(eventName);
    }
    listeners(eventName) {
      return super.listeners(eventName);
    }
    rawListeners(eventName) {
      return super.rawListeners(eventName);
    }
  }
  enhancedEvents.EnhancedEventEmitter = EnhancedEventEmitter;
  return enhancedEvents;
}
var errors$1 = {};
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  "use strict";
  Object.defineProperty(errors$1, "__esModule", { value: true });
  errors$1.InvalidStateError = errors$1.UnsupportedError = void 0;
  class UnsupportedError extends Error {
    constructor(message) {
      super(message);
      this.name = "UnsupportedError";
      if (Error.hasOwnProperty("captureStackTrace")) {
        Error.captureStackTrace(this, UnsupportedError);
      } else {
        this.stack = new Error(message).stack;
      }
    }
  }
  errors$1.UnsupportedError = UnsupportedError;
  class InvalidStateError extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidStateError";
      if (Error.hasOwnProperty("captureStackTrace")) {
        Error.captureStackTrace(this, InvalidStateError);
      } else {
        this.stack = new Error(message).stack;
      }
    }
  }
  errors$1.InvalidStateError = InvalidStateError;
  return errors$1;
}
var utils$2 = {};
var hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  "use strict";
  Object.defineProperty(utils$2, "__esModule", { value: true });
  utils$2.clone = clone;
  utils$2.generateRandomNumber = generateRandomNumber;
  utils$2.deepFreeze = deepFreeze;
  function clone(value2) {
    if (value2 === void 0) {
      return void 0;
    } else if (Number.isNaN(value2)) {
      return NaN;
    } else if (typeof structuredClone === "function") {
      return structuredClone(value2);
    } else {
      return JSON.parse(JSON.stringify(value2));
    }
  }
  function generateRandomNumber() {
    return Math.round(Math.random() * 1e7);
  }
  function deepFreeze(data) {
    const propNames = Reflect.ownKeys(data);
    for (const name of propNames) {
      const value2 = data[name];
      if (value2 && typeof value2 === "object" || typeof value2 === "function") {
        deepFreeze(value2);
      }
    }
    return Object.freeze(data);
  }
  return utils$2;
}
var ortc = {};
var lib$3 = {};
var Logger$1 = {};
var hasRequiredLogger$1;
function requireLogger$1() {
  if (hasRequiredLogger$1) return Logger$1;
  hasRequiredLogger$1 = 1;
  "use strict";
  var __importDefault = Logger$1 && Logger$1.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(Logger$1, "__esModule", { value: true });
  Logger$1.Logger = void 0;
  const debug_1 = __importDefault(requireBrowser());
  const APP_NAME = "h264-profile-level-id";
  class Logger2 {
    constructor(prefix) {
      if (prefix) {
        this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
        this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
        this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
      } else {
        this._debug = (0, debug_1.default)(APP_NAME);
        this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
        this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
      }
      this._debug.log = console.info.bind(console);
      this._warn.log = console.warn.bind(console);
      this._error.log = console.error.bind(console);
    }
    get debug() {
      return this._debug;
    }
    get warn() {
      return this._warn;
    }
    get error() {
      return this._error;
    }
  }
  Logger$1.Logger = Logger2;
  return Logger$1;
}
var hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$3;
  hasRequiredLib$4 = 1;
  "use strict";
  Object.defineProperty(lib$3, "__esModule", { value: true });
  lib$3.ProfileLevelId = lib$3.Level = lib$3.Profile = void 0;
  lib$3.parseProfileLevelId = parseProfileLevelId;
  lib$3.profileLevelIdToString = profileLevelIdToString;
  lib$3.profileToString = profileToString;
  lib$3.levelToString = levelToString;
  lib$3.parseSdpProfileLevelId = parseSdpProfileLevelId;
  lib$3.isSameProfile = isSameProfile;
  lib$3.isSameProfileAndLevel = isSameProfileAndLevel;
  lib$3.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
  lib$3.supportedLevel = supportedLevel;
  const Logger_1 = requireLogger$1();
  const logger = new Logger_1.Logger();
  var Profile;
  (function(Profile2) {
    Profile2[Profile2["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
    Profile2[Profile2["Baseline"] = 2] = "Baseline";
    Profile2[Profile2["Main"] = 3] = "Main";
    Profile2[Profile2["ConstrainedHigh"] = 4] = "ConstrainedHigh";
    Profile2[Profile2["High"] = 5] = "High";
    Profile2[Profile2["PredictiveHigh444"] = 6] = "PredictiveHigh444";
  })(Profile || (lib$3.Profile = Profile = {}));
  var Level;
  (function(Level2) {
    Level2[Level2["L1_b"] = 0] = "L1_b";
    Level2[Level2["L1"] = 10] = "L1";
    Level2[Level2["L1_1"] = 11] = "L1_1";
    Level2[Level2["L1_2"] = 12] = "L1_2";
    Level2[Level2["L1_3"] = 13] = "L1_3";
    Level2[Level2["L2"] = 20] = "L2";
    Level2[Level2["L2_1"] = 21] = "L2_1";
    Level2[Level2["L2_2"] = 22] = "L2_2";
    Level2[Level2["L3"] = 30] = "L3";
    Level2[Level2["L3_1"] = 31] = "L3_1";
    Level2[Level2["L3_2"] = 32] = "L3_2";
    Level2[Level2["L4"] = 40] = "L4";
    Level2[Level2["L4_1"] = 41] = "L4_1";
    Level2[Level2["L4_2"] = 42] = "L4_2";
    Level2[Level2["L5"] = 50] = "L5";
    Level2[Level2["L5_1"] = 51] = "L5_1";
    Level2[Level2["L5_2"] = 52] = "L5_2";
  })(Level || (lib$3.Level = Level = {}));
  class ProfileLevelId {
    constructor(profile, level) {
      this.profile = profile;
      this.level = level;
    }
  }
  lib$3.ProfileLevelId = ProfileLevelId;
  const DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
  class BitPattern {
    constructor(str) {
      this.mask = ~byteMaskString("x", str);
      this.masked_value = byteMaskString("1", str);
    }
    isMatch(value2) {
      return this.masked_value === (value2 & this.mask);
    }
  }
  class ProfilePattern {
    constructor(profile_idc, profile_iop, profile) {
      this.profile_idc = profile_idc;
      this.profile_iop = profile_iop;
      this.profile = profile;
    }
  }
  const ProfilePatterns = [
    new ProfilePattern(66, new BitPattern("x1xx0000"), Profile.ConstrainedBaseline),
    new ProfilePattern(77, new BitPattern("1xxx0000"), Profile.ConstrainedBaseline),
    new ProfilePattern(88, new BitPattern("11xx0000"), Profile.ConstrainedBaseline),
    new ProfilePattern(66, new BitPattern("x0xx0000"), Profile.Baseline),
    new ProfilePattern(88, new BitPattern("10xx0000"), Profile.Baseline),
    new ProfilePattern(77, new BitPattern("0x0x0000"), Profile.Main),
    new ProfilePattern(100, new BitPattern("00000000"), Profile.High),
    new ProfilePattern(100, new BitPattern("00001100"), Profile.ConstrainedHigh),
    new ProfilePattern(244, new BitPattern("00000000"), Profile.PredictiveHigh444)
  ];
  const LevelConstraints = [
    {
      max_macroblocks_per_second: 1485,
      max_macroblock_frame_size: 99,
      level: Level.L1
    },
    {
      max_macroblocks_per_second: 1485,
      max_macroblock_frame_size: 99,
      level: Level.L1_b
    },
    {
      max_macroblocks_per_second: 3e3,
      max_macroblock_frame_size: 396,
      level: Level.L1_1
    },
    {
      max_macroblocks_per_second: 6e3,
      max_macroblock_frame_size: 396,
      level: Level.L1_2
    },
    {
      max_macroblocks_per_second: 11880,
      max_macroblock_frame_size: 396,
      level: Level.L1_3
    },
    {
      max_macroblocks_per_second: 11880,
      max_macroblock_frame_size: 396,
      level: Level.L2
    },
    {
      max_macroblocks_per_second: 19800,
      max_macroblock_frame_size: 792,
      level: Level.L2_1
    },
    {
      max_macroblocks_per_second: 20250,
      max_macroblock_frame_size: 1620,
      level: Level.L2_2
    },
    {
      max_macroblocks_per_second: 40500,
      max_macroblock_frame_size: 1620,
      level: Level.L3
    },
    {
      max_macroblocks_per_second: 108e3,
      max_macroblock_frame_size: 3600,
      level: Level.L3_1
    },
    {
      max_macroblocks_per_second: 216e3,
      max_macroblock_frame_size: 5120,
      level: Level.L3_2
    },
    {
      max_macroblocks_per_second: 245760,
      max_macroblock_frame_size: 8192,
      level: Level.L4
    },
    {
      max_macroblocks_per_second: 245760,
      max_macroblock_frame_size: 8192,
      level: Level.L4_1
    },
    {
      max_macroblocks_per_second: 522240,
      max_macroblock_frame_size: 8704,
      level: Level.L4_2
    },
    {
      max_macroblocks_per_second: 589824,
      max_macroblock_frame_size: 22080,
      level: Level.L5
    },
    {
      max_macroblocks_per_second: 983040,
      max_macroblock_frame_size: 36864,
      level: Level.L5_1
    },
    {
      max_macroblocks_per_second: 2073600,
      max_macroblock_frame_size: 36864,
      level: Level.L5_2
    }
  ];
  function parseProfileLevelId(str) {
    const ConstraintSet3Flag = 16;
    if (typeof str !== "string" || str.length !== 6) {
      return void 0;
    }
    const profile_level_id_numeric = parseInt(str, 16);
    if (profile_level_id_numeric === 0) {
      return void 0;
    }
    const level_idc = profile_level_id_numeric & 255;
    const profile_iop = profile_level_id_numeric >> 8 & 255;
    const profile_idc = profile_level_id_numeric >> 16 & 255;
    let level;
    switch (level_idc) {
      case Level.L1_1: {
        level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
        break;
      }
      case Level.L1:
      case Level.L1_2:
      case Level.L1_3:
      case Level.L2:
      case Level.L2_1:
      case Level.L2_2:
      case Level.L3:
      case Level.L3_1:
      case Level.L3_2:
      case Level.L4:
      case Level.L4_1:
      case Level.L4_2:
      case Level.L5:
      case Level.L5_1:
      case Level.L5_2: {
        level = level_idc;
        break;
      }
      // Unrecognized level_idc.
      default: {
        logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
        return void 0;
      }
    }
    for (const pattern of ProfilePatterns) {
      if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
        logger.debug(`parseProfileLevelId() | result [str:${str}, profile:${pattern.profile}, level:${level}]`);
        return new ProfileLevelId(pattern.profile, level);
      }
    }
    logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
    return void 0;
  }
  function profileLevelIdToString(profile_level_id) {
    if (profile_level_id.level == Level.L1_b) {
      switch (profile_level_id.profile) {
        case Profile.ConstrainedBaseline: {
          return "42f00b";
        }
        case Profile.Baseline: {
          return "42100b";
        }
        case Profile.Main: {
          return "4d100b";
        }
        // Level 1_b is not allowed for other profiles.
        default: {
          logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
          return void 0;
        }
      }
    }
    let profile_idc_iop_string;
    switch (profile_level_id.profile) {
      case Profile.ConstrainedBaseline: {
        profile_idc_iop_string = "42e0";
        break;
      }
      case Profile.Baseline: {
        profile_idc_iop_string = "4200";
        break;
      }
      case Profile.Main: {
        profile_idc_iop_string = "4d00";
        break;
      }
      case Profile.ConstrainedHigh: {
        profile_idc_iop_string = "640c";
        break;
      }
      case Profile.High: {
        profile_idc_iop_string = "6400";
        break;
      }
      case Profile.PredictiveHigh444: {
        profile_idc_iop_string = "f400";
        break;
      }
      default: {
        logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
        return void 0;
      }
    }
    let levelStr = profile_level_id.level.toString(16);
    if (levelStr.length === 1) {
      levelStr = `0${levelStr}`;
    }
    return `${profile_idc_iop_string}${levelStr}`;
  }
  function profileToString(profile) {
    switch (profile) {
      case Profile.ConstrainedBaseline: {
        return "ConstrainedBaseline";
      }
      case Profile.Baseline: {
        return "Baseline";
      }
      case Profile.Main: {
        return "Main";
      }
      case Profile.ConstrainedHigh: {
        return "ConstrainedHigh";
      }
      case Profile.High: {
        return "High";
      }
      case Profile.PredictiveHigh444: {
        return "PredictiveHigh444";
      }
      default: {
        logger.warn(`profileToString() | unrecognized profile ${profile}`);
        return void 0;
      }
    }
  }
  function levelToString(level) {
    switch (level) {
      case Level.L1_b: {
        return "1b";
      }
      case Level.L1: {
        return "1";
      }
      case Level.L1_1: {
        return "1.1";
      }
      case Level.L1_2: {
        return "1.2";
      }
      case Level.L1_3: {
        return "1.3";
      }
      case Level.L2: {
        return "2";
      }
      case Level.L2_1: {
        return "2.1";
      }
      case Level.L2_2: {
        return "2.2";
      }
      case Level.L3: {
        return "3";
      }
      case Level.L3_1: {
        return "3.1";
      }
      case Level.L3_2: {
        return "3.2";
      }
      case Level.L4: {
        return "4";
      }
      case Level.L4_1: {
        return "4.1";
      }
      case Level.L4_2: {
        return "4.2";
      }
      case Level.L5: {
        return "5";
      }
      case Level.L5_1: {
        return "5.1";
      }
      case Level.L5_2: {
        return "5.2";
      }
      default: {
        logger.warn(`levelToString() | unrecognized level ${level}`);
        return void 0;
      }
    }
  }
  function parseSdpProfileLevelId(params2 = {}) {
    const profile_level_id = params2["profile-level-id"];
    return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
  }
  function isSameProfile(params1 = {}, params2 = {}) {
    const profile_level_id_1 = parseSdpProfileLevelId(params1);
    const profile_level_id_2 = parseSdpProfileLevelId(params2);
    return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
  }
  function isSameProfileAndLevel(params1 = {}, params2 = {}) {
    const profile_level_id_1 = parseSdpProfileLevelId(params1);
    const profile_level_id_2 = parseSdpProfileLevelId(params2);
    return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile && profile_level_id_1.level == profile_level_id_2.level);
  }
  function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
    if (!local_supported_params["profile-level-id"] && !remote_offered_params["profile-level-id"]) {
      logger.warn("generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params");
      return void 0;
    }
    const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
    const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
    if (!local_profile_level_id) {
      throw new TypeError("invalid local_profile_level_id");
    }
    if (!remote_profile_level_id) {
      throw new TypeError("invalid remote_profile_level_id");
    }
    if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
      throw new TypeError("H264 Profile mismatch");
    }
    const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
    const local_level = local_profile_level_id.level;
    const remote_level = remote_profile_level_id.level;
    const min_level = minLevel(local_level, remote_level);
    const answer_level = level_asymmetry_allowed ? local_level : min_level;
    logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
    return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
  }
  function supportedLevel(max_frame_pixel_count, max_fps) {
    const PixelsPerMacroblock = 16 * 16;
    for (let i = LevelConstraints.length - 1; i >= 0; --i) {
      const level_constraint = LevelConstraints[i];
      if (level_constraint.max_macroblock_frame_size * PixelsPerMacroblock <= max_frame_pixel_count && level_constraint.max_macroblocks_per_second <= max_fps * level_constraint.max_macroblock_frame_size) {
        logger.debug(`supportedLevel() | result [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}, level:${level_constraint.level}]`);
        return level_constraint.level;
      }
    }
    logger.warn(`supportedLevel() | no level supported [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}]`);
    return void 0;
  }
  function byteMaskString(c, str) {
    return Number(str[0] === c) << 7 | Number(str[1] === c) << 6 | Number(str[2] === c) << 5 | Number(str[3] === c) << 4 | Number(str[4] === c) << 3 | Number(str[5] === c) << 2 | Number(str[6] === c) << 1 | Number(str[7] === c) << 0;
  }
  function isLessLevel(a, b) {
    if (a === Level.L1_b) {
      return b !== Level.L1 && b !== Level.L1_b;
    }
    if (b === Level.L1_b) {
      return a !== Level.L1;
    }
    return a < b;
  }
  function minLevel(a, b) {
    return isLessLevel(a, b) ? a : b;
  }
  function isLevelAsymmetryAllowed(params2 = {}) {
    const level_asymmetry_allowed = params2["level-asymmetry-allowed"];
    return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === "1";
  }
  return lib$3;
}
var hasRequiredOrtc;
function requireOrtc() {
  if (hasRequiredOrtc) return ortc;
  hasRequiredOrtc = 1;
  "use strict";
  Object.defineProperty(ortc, "__esModule", { value: true });
  ortc.validateAndNormalizeRtpCapabilities = validateAndNormalizeRtpCapabilities;
  ortc.validateAndNormalizeRtpParameters = validateAndNormalizeRtpParameters;
  ortc.validateAndNormalizeSctpStreamParameters = validateAndNormalizeSctpStreamParameters;
  ortc.validateSctpCapabilities = validateSctpCapabilities;
  ortc.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
  ortc.getRecvRtpCapabilities = getRecvRtpCapabilities;
  ortc.getSendingRtpParameters = getSendingRtpParameters;
  ortc.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
  ortc.reduceCodecs = reduceCodecs;
  ortc.generateProbatorRtpParameters = generateProbatorRtpParameters;
  ortc.canSend = canSend;
  ortc.canReceive = canReceive;
  const h264 = requireLib$4();
  const utils2 = requireUtils$2();
  const RTP_PROBATOR_MID = "probator";
  const RTP_PROBATOR_SSRC = 1234;
  const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
  function validateAndNormalizeRtpCapabilities(caps) {
    if (typeof caps !== "object") {
      throw new TypeError("caps is not an object");
    }
    if (caps.codecs && !Array.isArray(caps.codecs)) {
      throw new TypeError("caps.codecs is not an array");
    } else if (!caps.codecs) {
      caps.codecs = [];
    }
    for (const codec of caps.codecs) {
      validateAndNormalizeRtpCodecCapability(codec);
    }
    if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
      throw new TypeError("caps.headerExtensions is not an array");
    } else if (!caps.headerExtensions) {
      caps.headerExtensions = [];
    }
    for (const ext of caps.headerExtensions) {
      validateAndNormalizeRtpHeaderExtension(ext);
    }
  }
  function validateAndNormalizeRtpParameters(params2) {
    if (typeof params2 !== "object") {
      throw new TypeError("params is not an object");
    }
    if (params2.mid && typeof params2.mid !== "string") {
      throw new TypeError("params.mid is not a string");
    }
    if (!Array.isArray(params2.codecs)) {
      throw new TypeError("missing params.codecs");
    }
    for (const codec of params2.codecs) {
      validateAndNormalizeRtpCodecParameters(codec);
    }
    if (params2.headerExtensions && !Array.isArray(params2.headerExtensions)) {
      throw new TypeError("params.headerExtensions is not an array");
    } else if (!params2.headerExtensions) {
      params2.headerExtensions = [];
    }
    for (const ext of params2.headerExtensions) {
      validateRtpHeaderExtensionParameters(ext);
    }
    if (params2.encodings && !Array.isArray(params2.encodings)) {
      throw new TypeError("params.encodings is not an array");
    } else if (!params2.encodings) {
      params2.encodings = [];
    }
    for (const encoding of params2.encodings) {
      validateAndNormalizeRtpEncodingParameters(encoding);
    }
    if (params2.rtcp && typeof params2.rtcp !== "object") {
      throw new TypeError("params.rtcp is not an object");
    } else if (!params2.rtcp) {
      params2.rtcp = {};
    }
    validateAndNormalizeRtcpParameters(params2.rtcp);
  }
  function validateAndNormalizeSctpStreamParameters(params2) {
    if (typeof params2 !== "object") {
      throw new TypeError("params is not an object");
    }
    if (typeof params2.streamId !== "number") {
      throw new TypeError("missing params.streamId");
    }
    let orderedGiven = false;
    if (typeof params2.ordered === "boolean") {
      orderedGiven = true;
    } else {
      params2.ordered = true;
    }
    if (params2.maxPacketLifeTime && typeof params2.maxPacketLifeTime !== "number") {
      throw new TypeError("invalid params.maxPacketLifeTime");
    }
    if (params2.maxRetransmits && typeof params2.maxRetransmits !== "number") {
      throw new TypeError("invalid params.maxRetransmits");
    }
    if (params2.maxPacketLifeTime && params2.maxRetransmits) {
      throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
    }
    if (orderedGiven && params2.ordered && (params2.maxPacketLifeTime || params2.maxRetransmits)) {
      throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
    } else if (!orderedGiven && (params2.maxPacketLifeTime || params2.maxRetransmits)) {
      params2.ordered = false;
    }
    if (params2.label && typeof params2.label !== "string") {
      throw new TypeError("invalid params.label");
    }
    if (params2.protocol && typeof params2.protocol !== "string") {
      throw new TypeError("invalid params.protocol");
    }
  }
  function validateSctpCapabilities(caps) {
    if (typeof caps !== "object") {
      throw new TypeError("caps is not an object");
    }
    if (!caps.numStreams || typeof caps.numStreams !== "object") {
      throw new TypeError("missing caps.numStreams");
    }
    validateNumSctpStreams(caps.numStreams);
  }
  function getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {
    const extendedRtpCapabilities = {
      codecs: [],
      headerExtensions: []
    };
    if (preferLocalCodecsOrder) {
      for (const localCodec of localCaps.codecs ?? []) {
        if (isRtxCodec(localCodec)) {
          continue;
        }
        const matchingRemoteCodec = (remoteCaps.codecs ?? []).find((remoteCodec) => matchCodecs(remoteCodec, localCodec, { strict: true, modify: true }));
        if (!matchingRemoteCodec) {
          continue;
        }
        const extendedCodec = {
          kind: localCodec.kind,
          mimeType: localCodec.mimeType,
          clockRate: localCodec.clockRate,
          channels: localCodec.channels,
          localPayloadType: localCodec.preferredPayloadType,
          localRtxPayloadType: void 0,
          remotePayloadType: matchingRemoteCodec.preferredPayloadType,
          remoteRtxPayloadType: void 0,
          localParameters: localCodec.parameters ?? {},
          remoteParameters: matchingRemoteCodec.parameters ?? {},
          rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec)
        };
        extendedRtpCapabilities.codecs.push(extendedCodec);
      }
    } else {
      for (const remoteCodec of remoteCaps.codecs ?? []) {
        if (isRtxCodec(remoteCodec)) {
          continue;
        }
        const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
        if (!matchingLocalCodec) {
          continue;
        }
        const extendedCodec = {
          kind: matchingLocalCodec.kind,
          mimeType: matchingLocalCodec.mimeType,
          clockRate: matchingLocalCodec.clockRate,
          channels: matchingLocalCodec.channels,
          localPayloadType: matchingLocalCodec.preferredPayloadType,
          localRtxPayloadType: void 0,
          remotePayloadType: remoteCodec.preferredPayloadType,
          remoteRtxPayloadType: void 0,
          localParameters: matchingLocalCodec.parameters ?? {},
          remoteParameters: remoteCodec.parameters ?? {},
          rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
        };
        extendedRtpCapabilities.codecs.push(extendedCodec);
      }
    }
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
      const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => {
        var _a;
        return isRtxCodec(localCodec) && ((_a = localCodec.parameters) == null ? void 0 : _a["apt"]) === extendedCodec.localPayloadType;
      });
      const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => {
        var _a;
        return isRtxCodec(remoteCodec) && ((_a = remoteCodec.parameters) == null ? void 0 : _a["apt"]) === extendedCodec.remotePayloadType;
      });
      if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
        extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
        extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
      }
    }
    for (const remoteExt of remoteCaps.headerExtensions) {
      const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
      if (!matchingLocalExt) {
        continue;
      }
      const extendedExt = {
        kind: remoteExt.kind,
        uri: remoteExt.uri,
        sendId: matchingLocalExt.preferredId,
        recvId: remoteExt.preferredId,
        encrypt: matchingLocalExt.preferredEncrypt ?? false,
        direction: "sendrecv"
      };
      switch (remoteExt.direction) {
        case "sendrecv": {
          extendedExt.direction = "sendrecv";
          break;
        }
        case "recvonly": {
          extendedExt.direction = "sendonly";
          break;
        }
        case "sendonly": {
          extendedExt.direction = "recvonly";
          break;
        }
        case "inactive": {
          extendedExt.direction = "inactive";
          break;
        }
      }
      extendedRtpCapabilities.headerExtensions.push(extendedExt);
    }
    return extendedRtpCapabilities;
  }
  function getRecvRtpCapabilities(extendedRtpCapabilities) {
    const rtpCapabilities2 = {
      codecs: [],
      headerExtensions: []
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
      const codec = {
        kind: extendedCodec.kind,
        mimeType: extendedCodec.mimeType,
        preferredPayloadType: extendedCodec.remotePayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpCapabilities2.codecs.push(codec);
      if (!extendedCodec.remoteRtxPayloadType) {
        continue;
      }
      const rtxCodec = {
        kind: extendedCodec.kind,
        mimeType: `${extendedCodec.kind}/rtx`,
        preferredPayloadType: extendedCodec.remoteRtxPayloadType,
        clockRate: extendedCodec.clockRate,
        parameters: {
          apt: extendedCodec.remotePayloadType
        },
        rtcpFeedback: []
      };
      rtpCapabilities2.codecs.push(rtxCodec);
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
      if (extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "recvonly") {
        continue;
      }
      const ext = {
        kind: extendedExtension.kind,
        uri: extendedExtension.uri,
        preferredId: extendedExtension.recvId,
        preferredEncrypt: extendedExtension.encrypt ?? false,
        direction: extendedExtension.direction
      };
      rtpCapabilities2.headerExtensions.push(ext);
    }
    return rtpCapabilities2;
  }
  function getSendingRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
      mid: void 0,
      codecs: [],
      headerExtensions: [],
      encodings: [],
      rtcp: {}
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
      if (extendedCodec.kind !== kind) {
        continue;
      }
      const codec = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.localParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(codec);
      if (extendedCodec.localRtxPayloadType) {
        const rtxCodec = {
          mimeType: `${extendedCodec.kind}/rtx`,
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
        continue;
      }
      const ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
    return rtpParameters;
  }
  function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
    const rtpParameters = {
      mid: void 0,
      codecs: [],
      headerExtensions: [],
      encodings: [],
      rtcp: {}
    };
    for (const extendedCodec of extendedRtpCapabilities.codecs) {
      if (extendedCodec.kind !== kind) {
        continue;
      }
      const codec = {
        mimeType: extendedCodec.mimeType,
        payloadType: extendedCodec.localPayloadType,
        clockRate: extendedCodec.clockRate,
        channels: extendedCodec.channels,
        parameters: extendedCodec.remoteParameters,
        rtcpFeedback: extendedCodec.rtcpFeedback
      };
      rtpParameters.codecs.push(codec);
      if (extendedCodec.localRtxPayloadType) {
        const rtxCodec = {
          mimeType: `${extendedCodec.kind}/rtx`,
          payloadType: extendedCodec.localRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.localPayloadType
          },
          rtcpFeedback: []
        };
        rtpParameters.codecs.push(rtxCodec);
      }
    }
    for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
      if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
        continue;
      }
      const ext = {
        uri: extendedExtension.uri,
        id: extendedExtension.sendId,
        encrypt: extendedExtension.encrypt,
        parameters: {}
      };
      rtpParameters.headerExtensions.push(ext);
    }
    if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01")) {
      for (const codec of rtpParameters.codecs) {
        codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "goog-remb");
      }
    } else if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time")) {
      for (const codec of rtpParameters.codecs) {
        codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc");
      }
    } else {
      for (const codec of rtpParameters.codecs) {
        codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc" && fb.type !== "goog-remb");
      }
    }
    return rtpParameters;
  }
  function reduceCodecs(codecs, capCodec) {
    const filteredCodecs = [];
    if (!capCodec) {
      filteredCodecs.push(codecs[0]);
      if (isRtxCodec(codecs[1])) {
        filteredCodecs.push(codecs[1]);
      }
    } else {
      for (let idx = 0; idx < codecs.length; ++idx) {
        if (matchCodecs(codecs[idx], capCodec, { strict: true })) {
          filteredCodecs.push(codecs[idx]);
          if (isRtxCodec(codecs[idx + 1])) {
            filteredCodecs.push(codecs[idx + 1]);
          }
          break;
        }
      }
      if (filteredCodecs.length === 0) {
        throw new TypeError("no matching codec found");
      }
    }
    return filteredCodecs;
  }
  function generateProbatorRtpParameters(videoRtpParameters) {
    videoRtpParameters = utils2.clone(videoRtpParameters);
    validateAndNormalizeRtpParameters(videoRtpParameters);
    const rtpParameters = {
      mid: RTP_PROBATOR_MID,
      codecs: [],
      headerExtensions: [],
      encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
      rtcp: { cname: "probator" }
    };
    rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
    rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
    rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
    return rtpParameters;
  }
  function canSend(kind, rtpCapabilities2) {
    return (rtpCapabilities2.codecs ?? []).some((codec) => codec.kind === kind);
  }
  function canReceive(rtpParameters, rtpCapabilities2) {
    validateAndNormalizeRtpParameters(rtpParameters);
    if (rtpParameters.codecs.length === 0) {
      return false;
    }
    const firstMediaCodec = rtpParameters.codecs[0];
    return (rtpCapabilities2.codecs ?? []).some((codec) => codec.preferredPayloadType === firstMediaCodec.payloadType);
  }
  function validateAndNormalizeRtpCodecCapability(codec) {
    const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
    if (typeof codec !== "object") {
      throw new TypeError("codec is not an object");
    }
    if (!codec.mimeType || typeof codec.mimeType !== "string") {
      throw new TypeError("missing codec.mimeType");
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
      throw new TypeError("invalid codec.mimeType");
    }
    codec.kind = mimeTypeMatch[1].toLowerCase();
    if (typeof codec.preferredPayloadType !== "number") {
      throw new TypeError("missing codec.preferredPayloadType");
    }
    if (typeof codec.clockRate !== "number") {
      throw new TypeError("missing codec.clockRate");
    }
    if (codec.kind === "audio") {
      if (typeof codec.channels !== "number") {
        codec.channels = 1;
      }
    } else {
      delete codec.channels;
    }
    if (!codec.parameters || typeof codec.parameters !== "object") {
      codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
      let value2 = codec.parameters[key];
      if (value2 === void 0) {
        codec.parameters[key] = "";
        value2 = "";
      }
      if (typeof value2 !== "string" && typeof value2 !== "number") {
        throw new TypeError(`invalid codec parameter [key:${key}s, value:${value2}]`);
      }
      if (key === "apt") {
        if (typeof value2 !== "number") {
          throw new TypeError("invalid codec apt parameter");
        }
      }
    }
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
      codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
      validateAndNormalizeRtcpFeedback(fb);
    }
  }
  function validateAndNormalizeRtcpFeedback(fb) {
    if (typeof fb !== "object") {
      throw new TypeError("fb is not an object");
    }
    if (!fb.type || typeof fb.type !== "string") {
      throw new TypeError("missing fb.type");
    }
    if (!fb.parameter || typeof fb.parameter !== "string") {
      fb.parameter = "";
    }
  }
  function validateAndNormalizeRtpHeaderExtension(ext) {
    if (typeof ext !== "object") {
      throw new TypeError("ext is not an object");
    }
    if (ext.kind !== "audio" && ext.kind !== "video") {
      throw new TypeError("invalid ext.kind");
    }
    if (!ext.uri || typeof ext.uri !== "string") {
      throw new TypeError("missing ext.uri");
    }
    if (typeof ext.preferredId !== "number") {
      throw new TypeError("missing ext.preferredId");
    }
    if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== "boolean") {
      throw new TypeError("invalid ext.preferredEncrypt");
    } else if (!ext.preferredEncrypt) {
      ext.preferredEncrypt = false;
    }
    if (ext.direction && typeof ext.direction !== "string") {
      throw new TypeError("invalid ext.direction");
    } else if (!ext.direction) {
      ext.direction = "sendrecv";
    }
  }
  function validateAndNormalizeRtpCodecParameters(codec) {
    const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
    if (typeof codec !== "object") {
      throw new TypeError("codec is not an object");
    }
    if (!codec.mimeType || typeof codec.mimeType !== "string") {
      throw new TypeError("missing codec.mimeType");
    }
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
      throw new TypeError("invalid codec.mimeType");
    }
    if (typeof codec.payloadType !== "number") {
      throw new TypeError("missing codec.payloadType");
    }
    if (typeof codec.clockRate !== "number") {
      throw new TypeError("missing codec.clockRate");
    }
    const kind = mimeTypeMatch[1].toLowerCase();
    if (kind === "audio") {
      if (typeof codec.channels !== "number") {
        codec.channels = 1;
      }
    } else {
      delete codec.channels;
    }
    if (!codec.parameters || typeof codec.parameters !== "object") {
      codec.parameters = {};
    }
    for (const key of Object.keys(codec.parameters)) {
      let value2 = codec.parameters[key];
      if (value2 === void 0) {
        codec.parameters[key] = "";
        value2 = "";
      }
      if (typeof value2 !== "string" && typeof value2 !== "number") {
        throw new TypeError(`invalid codec parameter [key:${key}s, value:${value2}]`);
      }
      if (key === "apt") {
        if (typeof value2 !== "number") {
          throw new TypeError("invalid codec apt parameter");
        }
      }
    }
    if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
      codec.rtcpFeedback = [];
    }
    for (const fb of codec.rtcpFeedback) {
      validateAndNormalizeRtcpFeedback(fb);
    }
  }
  function validateRtpHeaderExtensionParameters(ext) {
    if (typeof ext !== "object") {
      throw new TypeError("ext is not an object");
    }
    if (!ext.uri || typeof ext.uri !== "string") {
      throw new TypeError("missing ext.uri");
    }
    if (typeof ext.id !== "number") {
      throw new TypeError("missing ext.id");
    }
    if (ext.encrypt && typeof ext.encrypt !== "boolean") {
      throw new TypeError("invalid ext.encrypt");
    } else if (!ext.encrypt) {
      ext.encrypt = false;
    }
    if (!ext.parameters || typeof ext.parameters !== "object") {
      ext.parameters = {};
    }
    for (const key of Object.keys(ext.parameters)) {
      let value2 = ext.parameters[key];
      if (value2 === void 0) {
        ext.parameters[key] = "";
        value2 = "";
      }
      if (typeof value2 !== "string" && typeof value2 !== "number") {
        throw new TypeError("invalid header extension parameter");
      }
    }
  }
  function validateAndNormalizeRtpEncodingParameters(encoding) {
    if (typeof encoding !== "object") {
      throw new TypeError("encoding is not an object");
    }
    if (encoding.ssrc && typeof encoding.ssrc !== "number") {
      throw new TypeError("invalid encoding.ssrc");
    }
    if (encoding.rid && typeof encoding.rid !== "string") {
      throw new TypeError("invalid encoding.rid");
    }
    if (encoding.rtx && typeof encoding.rtx !== "object") {
      throw new TypeError("invalid encoding.rtx");
    } else if (encoding.rtx) {
      if (typeof encoding.rtx.ssrc !== "number") {
        throw new TypeError("missing encoding.rtx.ssrc");
      }
    }
    if (!encoding.dtx || typeof encoding.dtx !== "boolean") {
      encoding.dtx = false;
    }
    if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== "string") {
      throw new TypeError("invalid encoding.scalabilityMode");
    }
  }
  function validateAndNormalizeRtcpParameters(rtcp) {
    if (typeof rtcp !== "object") {
      throw new TypeError("rtcp is not an object");
    }
    if (rtcp.cname && typeof rtcp.cname !== "string") {
      throw new TypeError("invalid rtcp.cname");
    }
    if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") {
      rtcp.reducedSize = true;
    }
  }
  function validateNumSctpStreams(numStreams) {
    if (typeof numStreams !== "object") {
      throw new TypeError("numStreams is not an object");
    }
    if (typeof numStreams.OS !== "number") {
      throw new TypeError("missing numStreams.OS");
    }
    if (typeof numStreams.MIS !== "number") {
      throw new TypeError("missing numStreams.MIS");
    }
  }
  function isRtxCodec(codec) {
    if (!codec) {
      return false;
    }
    return /.+\/rtx$/i.test(codec.mimeType);
  }
  function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
    const aMimeType = aCodec.mimeType.toLowerCase();
    const bMimeType = bCodec.mimeType.toLowerCase();
    if (aMimeType !== bMimeType) {
      return false;
    }
    if (aCodec.clockRate !== bCodec.clockRate) {
      return false;
    }
    if (aCodec.channels !== bCodec.channels) {
      return false;
    }
    switch (aMimeType) {
      case "video/h264": {
        if (strict) {
          const aPacketizationMode = aCodec.parameters["packetization-mode"] ?? 0;
          const bPacketizationMode = bCodec.parameters["packetization-mode"] ?? 0;
          if (aPacketizationMode !== bPacketizationMode) {
            return false;
          }
          if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
            return false;
          }
          let selectedProfileLevelId;
          try {
            selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
          } catch (error) {
            return false;
          }
          if (modify) {
            if (selectedProfileLevelId) {
              aCodec.parameters["profile-level-id"] = selectedProfileLevelId;
              bCodec.parameters["profile-level-id"] = selectedProfileLevelId;
            } else {
              delete aCodec.parameters["profile-level-id"];
              delete bCodec.parameters["profile-level-id"];
            }
          }
        }
        break;
      }
      case "video/vp9": {
        if (strict) {
          const aProfileId = aCodec.parameters["profile-id"] ?? 0;
          const bProfileId = bCodec.parameters["profile-id"] ?? 0;
          if (aProfileId !== bProfileId) {
            return false;
          }
        }
        break;
      }
    }
    return true;
  }
  function matchHeaderExtensions(aExt, bExt) {
    if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
      return false;
    }
    if (aExt.uri !== bExt.uri) {
      return false;
    }
    return true;
  }
  function reduceRtcpFeedback(codecA, codecB) {
    const reducedRtcpFeedback = [];
    for (const aFb of codecA.rtcpFeedback ?? []) {
      const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));
      if (matchingBFb) {
        reducedRtcpFeedback.push(matchingBFb);
      }
    }
    return reducedRtcpFeedback;
  }
  return ortc;
}
var Transport2 = {};
var lib$2 = {};
var AwaitQueue = {};
var Logger = {};
var hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger) return Logger;
  hasRequiredLogger = 1;
  "use strict";
  Object.defineProperty(Logger, "__esModule", { value: true });
  Logger.Logger = void 0;
  const debug = requireBrowser();
  const LIB_NAME = "awaitqueue";
  let Logger$12 = class Logger {
    constructor(prefix) {
      __publicField(this, "_debug");
      __publicField(this, "_warn");
      __publicField(this, "_error");
      if (prefix) {
        this._debug = debug(`${LIB_NAME}:${prefix}`);
        this._warn = debug(`${LIB_NAME}:WARN:${prefix}`);
        this._error = debug(`${LIB_NAME}:ERROR:${prefix}`);
      } else {
        this._debug = debug(LIB_NAME);
        this._warn = debug(`${LIB_NAME}:WARN`);
        this._error = debug(`${LIB_NAME}:ERROR`);
      }
      this._debug.log = console.info.bind(console);
      this._warn.log = console.warn.bind(console);
      this._error.log = console.error.bind(console);
    }
    get debug() {
      return this._debug;
    }
    get warn() {
      return this._warn;
    }
    get error() {
      return this._error;
    }
  };
  Logger.Logger = Logger$12;
  return Logger;
}
var errors = {};
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  "use strict";
  Object.defineProperty(errors, "__esModule", { value: true });
  errors.AwaitQueueRemovedTaskError = errors.AwaitQueueStoppedError = void 0;
  class AwaitQueueStoppedError extends Error {
    constructor(message) {
      super(message ?? "queue stopped");
      this.name = "AwaitQueueStoppedError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, AwaitQueueStoppedError);
      }
    }
  }
  errors.AwaitQueueStoppedError = AwaitQueueStoppedError;
  class AwaitQueueRemovedTaskError extends Error {
    constructor(message) {
      super(message ?? "queue task removed");
      this.name = "AwaitQueueRemovedTaskError";
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(this, AwaitQueueRemovedTaskError);
      }
    }
  }
  errors.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
  return errors;
}
var hasRequiredAwaitQueue;
function requireAwaitQueue() {
  if (hasRequiredAwaitQueue) return AwaitQueue;
  hasRequiredAwaitQueue = 1;
  "use strict";
  Object.defineProperty(AwaitQueue, "__esModule", { value: true });
  AwaitQueue.AwaitQueue = void 0;
  const Logger_1 = requireLogger();
  const errors_1 = requireErrors();
  const logger = new Logger_1.Logger("AwaitQueue");
  let AwaitQueue$1 = class AwaitQueue {
    constructor() {
      // Queue of pending tasks (map of PendingTasks indexed by id).
      __publicField(this, "pendingTasks", /* @__PURE__ */ new Map());
      // Incrementing PendingTask id.
      __publicField(this, "nextTaskId", 0);
      // Whether stop() method is stopping all pending tasks.
      __publicField(this, "stopping", false);
      logger.debug("constructor()");
    }
    get size() {
      return this.pendingTasks.size;
    }
    async push(task, name) {
      name = name ?? task.name;
      logger.debug(`push() [name:${name}]`);
      if (typeof task !== "function") {
        throw new TypeError("given task is not a function");
      }
      if (name) {
        try {
          Object.defineProperty(task, "name", { value: name });
        } catch (error) {
        }
      }
      return new Promise((resolve, reject) => {
        const pendingTask = {
          id: this.nextTaskId++,
          task,
          name,
          enqueuedAt: Date.now(),
          executedAt: void 0,
          completed: false,
          resolve: (result) => {
            if (pendingTask.completed) {
              return;
            }
            pendingTask.completed = true;
            this.pendingTasks.delete(pendingTask.id);
            logger.debug(`resolving task [name:${pendingTask.name}]`);
            resolve(result);
            const [nextPendingTask] = this.pendingTasks.values();
            if (nextPendingTask && !nextPendingTask.executedAt) {
              void this.execute(nextPendingTask);
            }
          },
          reject: (error) => {
            if (pendingTask.completed) {
              return;
            }
            pendingTask.completed = true;
            this.pendingTasks.delete(pendingTask.id);
            logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
            reject(error);
            if (!this.stopping) {
              const [nextPendingTask] = this.pendingTasks.values();
              if (nextPendingTask && !nextPendingTask.executedAt) {
                void this.execute(nextPendingTask);
              }
            }
          }
        };
        this.pendingTasks.set(pendingTask.id, pendingTask);
        if (this.pendingTasks.size === 1) {
          void this.execute(pendingTask);
        }
      });
    }
    stop() {
      logger.debug("stop()");
      this.stopping = true;
      for (const pendingTask of this.pendingTasks.values()) {
        logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
        pendingTask.reject(new errors_1.AwaitQueueStoppedError());
      }
      this.stopping = false;
    }
    remove(taskIdx) {
      logger.debug(`remove() [taskIdx:${taskIdx}]`);
      const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
      if (!pendingTask) {
        logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
        return;
      }
      pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError());
    }
    dump() {
      const now = Date.now();
      let idx = 0;
      return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
        idx: idx++,
        task: pendingTask.task,
        name: pendingTask.name,
        enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
        executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
      }));
    }
    async execute(pendingTask) {
      logger.debug(`execute() [name:${pendingTask.name}]`);
      if (pendingTask.executedAt) {
        throw new Error("task already being executed");
      }
      pendingTask.executedAt = Date.now();
      try {
        const result = await pendingTask.task();
        pendingTask.resolve(result);
      } catch (error) {
        pendingTask.reject(error);
      }
    }
  };
  AwaitQueue.AwaitQueue = AwaitQueue$1;
  return AwaitQueue;
}
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$2;
  hasRequiredLib$3 = 1;
  (function(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = exports.AwaitQueue = void 0;
    var AwaitQueue_1 = requireAwaitQueue();
    Object.defineProperty(exports, "AwaitQueue", { enumerable: true, get: function() {
      return AwaitQueue_1.AwaitQueue;
    } });
    var errors_1 = requireErrors();
    Object.defineProperty(exports, "AwaitQueueStoppedError", { enumerable: true, get: function() {
      return errors_1.AwaitQueueStoppedError;
    } });
    Object.defineProperty(exports, "AwaitQueueRemovedTaskError", { enumerable: true, get: function() {
      return errors_1.AwaitQueueRemovedTaskError;
    } });
  })(lib$2);
  return lib$2;
}
var Producer = {};
var hasRequiredProducer;
function requireProducer() {
  if (hasRequiredProducer) return Producer;
  hasRequiredProducer = 1;
  "use strict";
  Object.defineProperty(Producer, "__esModule", { value: true });
  Producer.Producer = void 0;
  const Logger_1 = requireLogger$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const errors_1 = requireErrors$1();
  const logger = new Logger_1.Logger("Producer");
  let Producer$1 = class Producer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
      super();
      // Id.
      __publicField(this, "_id");
      // Local id.
      __publicField(this, "_localId");
      // Closed flag.
      __publicField(this, "_closed", false);
      // Associated RTCRtpSender.
      __publicField(this, "_rtpSender");
      // Local track.
      __publicField(this, "_track");
      // Producer kind.
      __publicField(this, "_kind");
      // RTP parameters.
      __publicField(this, "_rtpParameters");
      // Paused flag.
      __publicField(this, "_paused");
      // Video max spatial layer.
      __publicField(this, "_maxSpatialLayer");
      // Whether the Producer should call stop() in given tracks.
      __publicField(this, "_stopTracks");
      // Whether the Producer should set track.enabled = false when paused.
      __publicField(this, "_disableTrackOnPause");
      // Whether we should replace the RTCRtpSender.track with null when paused.
      __publicField(this, "_zeroRtpOnPause");
      // App custom data.
      __publicField(this, "_appData");
      // Observer instance.
      __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
      logger.debug("constructor()");
      this._id = id;
      this._localId = localId;
      this._rtpSender = rtpSender;
      this._track = track;
      this._kind = track.kind;
      this._rtpParameters = rtpParameters;
      this._paused = disableTrackOnPause ? !track.enabled : false;
      this._maxSpatialLayer = void 0;
      this._stopTracks = stopTracks;
      this._disableTrackOnPause = disableTrackOnPause;
      this._zeroRtpOnPause = zeroRtpOnPause;
      this._appData = appData ?? {};
      this.onTrackEnded = this.onTrackEnded.bind(this);
      this.handleTrack();
    }
    /**
     * Producer id.
     */
    get id() {
      return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
      return this._localId;
    }
    /**
     * Whether the Producer is closed.
     */
    get closed() {
      return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
      return this._kind;
    }
    /**
     * Associated RTCRtpSender.
     */
    get rtpSender() {
      return this._rtpSender;
    }
    /**
     * The associated track.
     */
    get track() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
      return this._rtpParameters;
    }
    /**
     * Whether the Producer is paused.
     */
    get paused() {
      return this._paused;
    }
    /**
     * Max spatial layer.
     *
     * @type {Number | undefined}
     */
    get maxSpatialLayer() {
      return this._maxSpatialLayer;
    }
    /**
     * App custom data.
     */
    get appData() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
      this._appData = appData;
    }
    get observer() {
      return this._observer;
    }
    /**
     * Closes the Producer.
     */
    close() {
      if (this._closed) {
        return;
      }
      logger.debug("close()");
      this._closed = true;
      this.destroyTrack();
      this.emit("@close");
      this._observer.safeEmit("close");
      super.close();
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug("transportClosed()");
      this._closed = true;
      this.destroyTrack();
      this.safeEmit("transportclose");
      this._observer.safeEmit("close");
    }
    /**
     * Get associated RTCRtpSender stats.
     */
    async getStats() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      }
      return new Promise((resolve, reject) => {
        this.safeEmit("@getstats", resolve, reject);
      });
    }
    /**
     * Pauses sending media.
     */
    pause() {
      logger.debug("pause()");
      if (this._closed) {
        logger.error("pause() | Producer closed");
        return;
      }
      this._paused = true;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = false;
      }
      if (this._zeroRtpOnPause) {
        new Promise((resolve, reject) => {
          this.safeEmit("@pause", resolve, reject);
        }).catch(() => {
        });
      }
      this._observer.safeEmit("pause");
    }
    /**
     * Resumes sending media.
     */
    resume() {
      logger.debug("resume()");
      if (this._closed) {
        logger.error("resume() | Producer closed");
        return;
      }
      this._paused = false;
      if (this._track && this._disableTrackOnPause) {
        this._track.enabled = true;
      }
      if (this._zeroRtpOnPause) {
        new Promise((resolve, reject) => {
          this.safeEmit("@resume", resolve, reject);
        }).catch(() => {
        });
      }
      this._observer.safeEmit("resume");
    }
    /**
     * Replaces the current track with a new one or null.
     */
    async replaceTrack({ track }) {
      logger.debug("replaceTrack() [track:%o]", track);
      if (this._closed) {
        if (track && this._stopTracks) {
          try {
            track.stop();
          } catch (error) {
          }
        }
        throw new errors_1.InvalidStateError("closed");
      } else if (track && track.readyState === "ended") {
        throw new errors_1.InvalidStateError("track ended");
      }
      if (track === this._track) {
        logger.debug("replaceTrack() | same track, ignored");
        return;
      }
      await new Promise((resolve, reject) => {
        this.safeEmit("@replacetrack", track, resolve, reject);
      });
      this.destroyTrack();
      this._track = track;
      if (this._track && this._disableTrackOnPause) {
        if (!this._paused) {
          this._track.enabled = true;
        } else if (this._paused) {
          this._track.enabled = false;
        }
      }
      this.handleTrack();
    }
    /**
     * Sets the video max spatial layer to be sent.
     */
    async setMaxSpatialLayer(spatialLayer) {
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (this._kind !== "video") {
        throw new errors_1.UnsupportedError("not a video Producer");
      } else if (typeof spatialLayer !== "number") {
        throw new TypeError("invalid spatialLayer");
      }
      if (spatialLayer === this._maxSpatialLayer) {
        return;
      }
      await new Promise((resolve, reject) => {
        this.safeEmit("@setmaxspatiallayer", spatialLayer, resolve, reject);
      }).catch(() => {
      });
      this._maxSpatialLayer = spatialLayer;
    }
    async setRtpEncodingParameters(params2) {
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (typeof params2 !== "object") {
        throw new TypeError("invalid params");
      }
      await new Promise((resolve, reject) => {
        this.safeEmit("@setrtpencodingparameters", params2, resolve, reject);
      });
    }
    onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit("trackended");
      this._observer.safeEmit("trackended");
    }
    handleTrack() {
      if (!this._track) {
        return;
      }
      this._track.addEventListener("ended", this.onTrackEnded);
    }
    destroyTrack() {
      if (!this._track) {
        return;
      }
      try {
        this._track.removeEventListener("ended", this.onTrackEnded);
        if (this._stopTracks) {
          this._track.stop();
        }
      } catch (error) {
      }
    }
  };
  Producer.Producer = Producer$1;
  return Producer;
}
var Consumer = {};
var hasRequiredConsumer;
function requireConsumer() {
  if (hasRequiredConsumer) return Consumer;
  hasRequiredConsumer = 1;
  "use strict";
  Object.defineProperty(Consumer, "__esModule", { value: true });
  Consumer.Consumer = void 0;
  const Logger_1 = requireLogger$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const errors_1 = requireErrors$1();
  const logger = new Logger_1.Logger("Consumer");
  let Consumer$1 = class Consumer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
      super();
      // Id.
      __publicField(this, "_id");
      // Local id.
      __publicField(this, "_localId");
      // Associated Producer id.
      __publicField(this, "_producerId");
      // Closed flag.
      __publicField(this, "_closed", false);
      // Associated RTCRtpReceiver.
      __publicField(this, "_rtpReceiver");
      // Remote track.
      __publicField(this, "_track");
      // RTP parameters.
      __publicField(this, "_rtpParameters");
      // Paused flag.
      __publicField(this, "_paused");
      // App custom data.
      __publicField(this, "_appData");
      // Observer instance.
      __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
      logger.debug("constructor()");
      this._id = id;
      this._localId = localId;
      this._producerId = producerId;
      this._rtpReceiver = rtpReceiver;
      this._track = track;
      this._rtpParameters = rtpParameters;
      this._paused = !track.enabled;
      this._appData = appData ?? {};
      this.onTrackEnded = this.onTrackEnded.bind(this);
      this.handleTrack();
    }
    /**
     * Consumer id.
     */
    get id() {
      return this._id;
    }
    /**
     * Local id.
     */
    get localId() {
      return this._localId;
    }
    /**
     * Associated Producer id.
     */
    get producerId() {
      return this._producerId;
    }
    /**
     * Whether the Consumer is closed.
     */
    get closed() {
      return this._closed;
    }
    /**
     * Media kind.
     */
    get kind() {
      return this._track.kind;
    }
    /**
     * Associated RTCRtpReceiver.
     */
    get rtpReceiver() {
      return this._rtpReceiver;
    }
    /**
     * The associated track.
     */
    get track() {
      return this._track;
    }
    /**
     * RTP parameters.
     */
    get rtpParameters() {
      return this._rtpParameters;
    }
    /**
     * Whether the Consumer is paused.
     */
    get paused() {
      return this._paused;
    }
    /**
     * App custom data.
     */
    get appData() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
      this._appData = appData;
    }
    get observer() {
      return this._observer;
    }
    /**
     * Closes the Consumer.
     */
    close() {
      if (this._closed) {
        return;
      }
      logger.debug("close()");
      this._closed = true;
      this.destroyTrack();
      this.emit("@close");
      this._observer.safeEmit("close");
      super.close();
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug("transportClosed()");
      this._closed = true;
      this.destroyTrack();
      this.safeEmit("transportclose");
      this._observer.safeEmit("close");
    }
    /**
     * Get associated RTCRtpReceiver stats.
     */
    async getStats() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      }
      return new Promise((resolve, reject) => {
        this.safeEmit("@getstats", resolve, reject);
      });
    }
    /**
     * Pauses receiving media.
     */
    pause() {
      logger.debug("pause()");
      if (this._closed) {
        logger.error("pause() | Consumer closed");
        return;
      }
      if (this._paused) {
        logger.debug("pause() | Consumer is already paused");
        return;
      }
      this._paused = true;
      this._track.enabled = false;
      this.emit("@pause");
      this._observer.safeEmit("pause");
    }
    /**
     * Resumes receiving media.
     */
    resume() {
      logger.debug("resume()");
      if (this._closed) {
        logger.error("resume() | Consumer closed");
        return;
      }
      if (!this._paused) {
        logger.debug("resume() | Consumer is already resumed");
        return;
      }
      this._paused = false;
      this._track.enabled = true;
      this.emit("@resume");
      this._observer.safeEmit("resume");
    }
    onTrackEnded() {
      logger.debug('track "ended" event');
      this.safeEmit("trackended");
      this._observer.safeEmit("trackended");
    }
    handleTrack() {
      this._track.addEventListener("ended", this.onTrackEnded);
    }
    destroyTrack() {
      try {
        this._track.removeEventListener("ended", this.onTrackEnded);
        this._track.stop();
      } catch (error) {
      }
    }
  };
  Consumer.Consumer = Consumer$1;
  return Consumer;
}
var DataProducer = {};
var hasRequiredDataProducer;
function requireDataProducer() {
  if (hasRequiredDataProducer) return DataProducer;
  hasRequiredDataProducer = 1;
  "use strict";
  Object.defineProperty(DataProducer, "__esModule", { value: true });
  DataProducer.DataProducer = void 0;
  const Logger_1 = requireLogger$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const errors_1 = requireErrors$1();
  const logger = new Logger_1.Logger("DataProducer");
  let DataProducer$1 = class DataProducer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, dataChannel, sctpStreamParameters, appData }) {
      super();
      // Id.
      __publicField(this, "_id");
      // The underlying RTCDataChannel instance.
      __publicField(this, "_dataChannel");
      // Closed flag.
      __publicField(this, "_closed", false);
      // SCTP stream parameters.
      __publicField(this, "_sctpStreamParameters");
      // App custom data.
      __publicField(this, "_appData");
      // Observer instance.
      __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
      logger.debug("constructor()");
      this._id = id;
      this._dataChannel = dataChannel;
      this._sctpStreamParameters = sctpStreamParameters;
      this._appData = appData ?? {};
      this.handleDataChannel();
    }
    /**
     * DataProducer id.
     */
    get id() {
      return this._id;
    }
    /**
     * Whether the DataProducer is closed.
     */
    get closed() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel bufferedAmount.
     */
    get bufferedAmount() {
      return this._dataChannel.bufferedAmount;
    }
    /**
     * DataChannel bufferedAmountLowThreshold.
     */
    get bufferedAmountLowThreshold() {
      return this._dataChannel.bufferedAmountLowThreshold;
    }
    /**
     * Set DataChannel bufferedAmountLowThreshold.
     */
    set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
      this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
    }
    /**
     * App custom data.
     */
    get appData() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
      this._appData = appData;
    }
    get observer() {
      return this._observer;
    }
    /**
     * Closes the DataProducer.
     */
    close() {
      if (this._closed) {
        return;
      }
      logger.debug("close()");
      this._closed = true;
      this._dataChannel.close();
      this.emit("@close");
      this._observer.safeEmit("close");
      super.close();
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug("transportClosed()");
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit("transportclose");
      this._observer.safeEmit("close");
    }
    /**
     * Send a message.
     *
     * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    send(data) {
      logger.debug("send()");
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      }
      this._dataChannel.send(data);
    }
    handleDataChannel() {
      this._dataChannel.addEventListener("open", () => {
        if (this._closed) {
          return;
        }
        logger.debug('DataChannel "open" event');
        this.safeEmit("open");
      });
      this._dataChannel.addEventListener("error", (event) => {
        var _a, _b;
        if (this._closed) {
          return;
        }
        const error = event.error ?? new Error("unknown DataChannel error");
        if (((_a = event.error) == null ? void 0 : _a.errorDetail) === "sctp-failure") {
          logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", (_b = event.error) == null ? void 0 : _b.sctpCauseCode, event.error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        this.safeEmit("error", error);
      });
      this._dataChannel.addEventListener("close", () => {
        if (this._closed) {
          return;
        }
        logger.warn('DataChannel "close" event');
        this._closed = true;
        this.emit("@close");
        this.safeEmit("close");
        this._observer.safeEmit("close");
      });
      this._dataChannel.addEventListener("message", () => {
        if (this._closed) {
          return;
        }
        logger.warn('DataChannel "message" event in a DataProducer, message discarded');
      });
      this._dataChannel.addEventListener("bufferedamountlow", () => {
        if (this._closed) {
          return;
        }
        this.safeEmit("bufferedamountlow");
      });
    }
  };
  DataProducer.DataProducer = DataProducer$1;
  return DataProducer;
}
var DataConsumer = {};
var hasRequiredDataConsumer;
function requireDataConsumer() {
  if (hasRequiredDataConsumer) return DataConsumer;
  hasRequiredDataConsumer = 1;
  "use strict";
  Object.defineProperty(DataConsumer, "__esModule", { value: true });
  DataConsumer.DataConsumer = void 0;
  const Logger_1 = requireLogger$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const logger = new Logger_1.Logger("DataConsumer");
  let DataConsumer$1 = class DataConsumer extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
      super();
      // Id.
      __publicField(this, "_id");
      // Associated DataProducer Id.
      __publicField(this, "_dataProducerId");
      // The underlying RTCDataChannel instance.
      __publicField(this, "_dataChannel");
      // Closed flag.
      __publicField(this, "_closed", false);
      // SCTP stream parameters.
      __publicField(this, "_sctpStreamParameters");
      // App custom data.
      __publicField(this, "_appData");
      // Observer instance.
      __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
      logger.debug("constructor()");
      this._id = id;
      this._dataProducerId = dataProducerId;
      this._dataChannel = dataChannel;
      this._sctpStreamParameters = sctpStreamParameters;
      this._appData = appData ?? {};
      this.handleDataChannel();
    }
    /**
     * DataConsumer id.
     */
    get id() {
      return this._id;
    }
    /**
     * Associated DataProducer id.
     */
    get dataProducerId() {
      return this._dataProducerId;
    }
    /**
     * Whether the DataConsumer is closed.
     */
    get closed() {
      return this._closed;
    }
    /**
     * SCTP stream parameters.
     */
    get sctpStreamParameters() {
      return this._sctpStreamParameters;
    }
    /**
     * DataChannel readyState.
     */
    get readyState() {
      return this._dataChannel.readyState;
    }
    /**
     * DataChannel label.
     */
    get label() {
      return this._dataChannel.label;
    }
    /**
     * DataChannel protocol.
     */
    get protocol() {
      return this._dataChannel.protocol;
    }
    /**
     * DataChannel binaryType.
     */
    get binaryType() {
      return this._dataChannel.binaryType;
    }
    /**
     * Set DataChannel binaryType.
     */
    set binaryType(binaryType) {
      this._dataChannel.binaryType = binaryType;
    }
    /**
     * App custom data.
     */
    get appData() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
      this._appData = appData;
    }
    get observer() {
      return this._observer;
    }
    /**
     * Closes the DataConsumer.
     */
    close() {
      if (this._closed) {
        return;
      }
      logger.debug("close()");
      this._closed = true;
      this._dataChannel.close();
      this.emit("@close");
      this._observer.safeEmit("close");
      super.close();
      this._observer.close();
    }
    /**
     * Transport was closed.
     */
    transportClosed() {
      if (this._closed) {
        return;
      }
      logger.debug("transportClosed()");
      this._closed = true;
      this._dataChannel.close();
      this.safeEmit("transportclose");
      this._observer.safeEmit("close");
    }
    handleDataChannel() {
      this._dataChannel.addEventListener("open", () => {
        if (this._closed) {
          return;
        }
        logger.debug('DataChannel "open" event');
        this.safeEmit("open");
      });
      this._dataChannel.addEventListener("error", (event) => {
        var _a, _b;
        if (this._closed) {
          return;
        }
        const error = event.error ?? new Error("unknown DataChannel error");
        if (((_a = event.error) == null ? void 0 : _a.errorDetail) === "sctp-failure") {
          logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", (_b = event.error) == null ? void 0 : _b.sctpCauseCode, event.error.message);
        } else {
          logger.error('DataChannel "error" event: %o', error);
        }
        this.safeEmit("error", error);
      });
      this._dataChannel.addEventListener("close", () => {
        if (this._closed) {
          return;
        }
        logger.warn('DataChannel "close" event');
        this._closed = true;
        this.emit("@close");
        this.safeEmit("close");
        this._observer.safeEmit("close");
      });
      this._dataChannel.addEventListener("message", (event) => {
        if (this._closed) {
          return;
        }
        this.safeEmit("message", event.data);
      });
    }
  };
  DataConsumer.DataConsumer = DataConsumer$1;
  return DataConsumer;
}
var hasRequiredTransport;
function requireTransport() {
  if (hasRequiredTransport) return Transport2;
  hasRequiredTransport = 1;
  "use strict";
  Object.defineProperty(Transport2, "__esModule", { value: true });
  Transport2.Transport = void 0;
  const awaitqueue_1 = requireLib$3();
  const Logger_1 = requireLogger$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const errors_1 = requireErrors$1();
  const utils2 = requireUtils$2();
  const ortc2 = requireOrtc();
  const Producer_1 = requireProducer();
  const Consumer_1 = requireConsumer();
  const DataProducer_1 = requireDataProducer();
  const DataConsumer_1 = requireDataConsumer();
  const logger = new Logger_1.Logger("Transport");
  class ConsumerCreationTask {
    constructor(consumerOptions) {
      __publicField(this, "consumerOptions");
      __publicField(this, "promise");
      __publicField(this, "resolve");
      __publicField(this, "reject");
      this.consumerOptions = consumerOptions;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
  }
  let Transport$12 = class Transport extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData, handlerFactory, getSendExtendedRtpCapabilities, recvRtpCapabilities, canProduceByKind }) {
      super();
      // Id.
      __publicField(this, "_id");
      // Closed flag.
      __publicField(this, "_closed", false);
      // Direction.
      __publicField(this, "_direction");
      // Callback for sending Transports to request sending extended RTP capabilities
      // on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // Recv RTP capabilities.
      __publicField(this, "_recvRtpCapabilities");
      // Whether we can produce audio/video based on computed extended RTP
      // capabilities.
      __publicField(this, "_canProduceByKind");
      // SCTP max message size if enabled, null otherwise.
      __publicField(this, "_maxSctpMessageSize");
      // RTC handler isntance.
      __publicField(this, "_handler");
      // Transport ICE gathering state.
      __publicField(this, "_iceGatheringState", "new");
      // Transport connection state.
      __publicField(this, "_connectionState", "new");
      // App custom data.
      __publicField(this, "_appData");
      // Map of Producers indexed by id.
      __publicField(this, "_producers", /* @__PURE__ */ new Map());
      // Map of Consumers indexed by id.
      __publicField(this, "_consumers", /* @__PURE__ */ new Map());
      // Map of DataProducers indexed by id.
      __publicField(this, "_dataProducers", /* @__PURE__ */ new Map());
      // Map of DataConsumers indexed by id.
      __publicField(this, "_dataConsumers", /* @__PURE__ */ new Map());
      // Whether the Consumer for RTP probation has been created.
      __publicField(this, "_probatorConsumerCreated", false);
      // AwaitQueue instance to make async tasks happen sequentially.
      __publicField(this, "_awaitQueue", new awaitqueue_1.AwaitQueue());
      // Consumer creation tasks awaiting to be processed.
      __publicField(this, "_pendingConsumerTasks", []);
      // Consumer creation in progress flag.
      __publicField(this, "_consumerCreationInProgress", false);
      // Consumers pending to be paused.
      __publicField(this, "_pendingPauseConsumers", /* @__PURE__ */ new Map());
      // Consumer pause in progress flag.
      __publicField(this, "_consumerPauseInProgress", false);
      // Consumers pending to be resumed.
      __publicField(this, "_pendingResumeConsumers", /* @__PURE__ */ new Map());
      // Consumer resume in progress flag.
      __publicField(this, "_consumerResumeInProgress", false);
      // Consumers pending to be closed.
      __publicField(this, "_pendingCloseConsumers", /* @__PURE__ */ new Map());
      // Consumer close in progress flag.
      __publicField(this, "_consumerCloseInProgress", false);
      // Observer instance.
      __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
      logger.debug("constructor() [id:%s, direction:%s]", id, direction);
      this._id = id;
      this._direction = direction;
      this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
      this._recvRtpCapabilities = recvRtpCapabilities;
      this._canProduceByKind = canProduceByKind;
      this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
      const clonedAdditionalSettings = utils2.clone(additionalSettings) ?? {};
      delete clonedAdditionalSettings.iceServers;
      delete clonedAdditionalSettings.iceTransportPolicy;
      delete clonedAdditionalSettings.bundlePolicy;
      delete clonedAdditionalSettings.rtcpMuxPolicy;
      this._handler = handlerFactory.factory({
        direction,
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters,
        iceServers,
        iceTransportPolicy,
        additionalSettings: clonedAdditionalSettings,
        getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities
      });
      this._appData = appData ?? {};
      this.handleHandler();
    }
    /**
     * Transport id.
     */
    get id() {
      return this._id;
    }
    /**
     * Whether the Transport is closed.
     */
    get closed() {
      return this._closed;
    }
    /**
     * Transport direction.
     */
    get direction() {
      return this._direction;
    }
    /**
     * RTC handler instance.
     */
    get handler() {
      return this._handler;
    }
    /**
     * ICE gathering state.
     */
    get iceGatheringState() {
      return this._iceGatheringState;
    }
    /**
     * Connection state.
     */
    get connectionState() {
      return this._connectionState;
    }
    /**
     * App custom data.
     */
    get appData() {
      return this._appData;
    }
    /**
     * App custom data setter.
     */
    set appData(appData) {
      this._appData = appData;
    }
    get observer() {
      return this._observer;
    }
    /**
     * Close the Transport.
     */
    close() {
      if (this._closed) {
        return;
      }
      logger.debug("close()");
      this._closed = true;
      this._awaitQueue.stop();
      this._handler.close();
      this._connectionState = "closed";
      for (const producer2 of this._producers.values()) {
        producer2.transportClosed();
      }
      this._producers.clear();
      for (const consumer2 of this._consumers.values()) {
        consumer2.transportClosed();
      }
      this._consumers.clear();
      for (const dataProducer of this._dataProducers.values()) {
        dataProducer.transportClosed();
      }
      this._dataProducers.clear();
      for (const dataConsumer of this._dataConsumers.values()) {
        dataConsumer.transportClosed();
      }
      this._dataConsumers.clear();
      this._observer.safeEmit("close");
      super.close();
      this._observer.close();
    }
    /**
     * Get associated Transport (RTCPeerConnection) stats.
     *
     * @returns {RTCStatsReport}
     */
    async getStats() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      }
      return this._handler.getTransportStats();
    }
    /**
     * Restart ICE connection.
     */
    async restartIce({ iceParameters }) {
      logger.debug("restartIce()");
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (!iceParameters) {
        throw new TypeError("missing iceParameters");
      }
      return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), "transport.restartIce()");
    }
    /**
     * Update ICE servers.
     */
    async updateIceServers({ iceServers } = {}) {
      logger.debug("updateIceServers()");
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (!Array.isArray(iceServers)) {
        throw new TypeError("missing iceServers");
      }
      return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), "transport.updateIceServers()");
    }
    /**
     * Create a Producer.
     */
    async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {} } = {}) {
      logger.debug("produce() [track:%o]", track);
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (!track) {
        throw new TypeError("missing track");
      } else if (this._direction !== "send") {
        throw new errors_1.UnsupportedError("not a sending Transport");
      } else if (!this._canProduceByKind[track.kind]) {
        throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
      } else if (track.readyState === "ended") {
        throw new errors_1.InvalidStateError("track ended");
      } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
        throw new TypeError('no "connect" listener set into this transport');
      } else if (this.listenerCount("produce") === 0) {
        throw new TypeError('no "produce" listener set into this transport');
      } else if (appData && typeof appData !== "object") {
        throw new TypeError("if given, appData must be an object");
      }
      return this._awaitQueue.push(async () => {
        let normalizedEncodings;
        if (encodings && !Array.isArray(encodings)) {
          throw TypeError("encodings must be an array");
        } else if (encodings && encodings.length === 0) {
          normalizedEncodings = void 0;
        } else if (encodings) {
          normalizedEncodings = encodings.map((encoding) => {
            const normalizedEncoding = {
              active: true
            };
            if (encoding.active === false) {
              normalizedEncoding.active = false;
            }
            if (typeof encoding.dtx === "boolean") {
              normalizedEncoding.dtx = encoding.dtx;
            }
            if (typeof encoding.scalabilityMode === "string") {
              normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
            }
            if (typeof encoding.scaleResolutionDownBy === "number") {
              normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
            }
            if (typeof encoding.maxBitrate === "number") {
              normalizedEncoding.maxBitrate = encoding.maxBitrate;
            }
            if (typeof encoding.maxFramerate === "number") {
              normalizedEncoding.maxFramerate = encoding.maxFramerate;
            }
            if (typeof encoding.adaptivePtime === "boolean") {
              normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
            }
            if (typeof encoding.priority === "string") {
              normalizedEncoding.priority = encoding.priority;
            }
            if (typeof encoding.networkPriority === "string") {
              normalizedEncoding.networkPriority = encoding.networkPriority;
            }
            return normalizedEncoding;
          });
        }
        const { localId, rtpParameters, rtpSender } = await this._handler.send({
          track,
          encodings: normalizedEncodings,
          codecOptions,
          codec,
          onRtpSender
        });
        try {
          ortc2.validateAndNormalizeRtpParameters(rtpParameters);
          const { id } = await new Promise((resolve, reject) => {
            this.safeEmit("produce", {
              kind: track.kind,
              rtpParameters,
              appData
            }, resolve, reject);
          });
          const producer2 = new Producer_1.Producer({
            id,
            localId,
            rtpSender,
            track,
            rtpParameters,
            stopTracks,
            disableTrackOnPause,
            zeroRtpOnPause,
            appData
          });
          this._producers.set(producer2.id, producer2);
          this.handleProducer(producer2);
          this._observer.safeEmit("newproducer", producer2);
          return producer2;
        } catch (error) {
          this._handler.stopSending(localId).catch(() => {
          });
          throw error;
        }
      }, "transport.produce()").catch((error) => {
        if (stopTracks) {
          try {
            track.stop();
          } catch (error2) {
          }
        }
        throw error;
      });
    }
    /**
     * Create a Consumer to consume a remote Producer.
     */
    async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {} }) {
      logger.debug("consume()");
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (this._direction !== "recv") {
        throw new errors_1.UnsupportedError("not a receiving Transport");
      } else if (typeof id !== "string") {
        throw new TypeError("missing id");
      } else if (typeof producerId !== "string") {
        throw new TypeError("missing producerId");
      } else if (kind !== "audio" && kind !== "video") {
        throw new TypeError(`invalid kind '${kind}'`);
      } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
        throw new TypeError('no "connect" listener set into this transport');
      } else if (appData && typeof appData !== "object") {
        throw new TypeError("if given, appData must be an object");
      }
      const clonedRtpParameters = utils2.clone(rtpParameters);
      const canConsume = ortc2.canReceive(clonedRtpParameters, this._recvRtpCapabilities);
      if (!canConsume) {
        throw new errors_1.UnsupportedError("cannot consume this Producer");
      }
      const consumerCreationTask = new ConsumerCreationTask({
        id,
        producerId,
        kind,
        rtpParameters: clonedRtpParameters,
        streamId,
        onRtpReceiver,
        appData
      });
      this._pendingConsumerTasks.push(consumerCreationTask);
      queueMicrotask(() => {
        if (this._closed) {
          return;
        }
        if (this._consumerCreationInProgress === false) {
          this.createPendingConsumers();
        }
      });
      return consumerCreationTask.promise;
    }
    /**
     * Create a DataProducer
     */
    async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = "", protocol: protocol2 = "", appData = {} } = {}) {
      logger.debug("produceData()");
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (this._direction !== "send") {
        throw new errors_1.UnsupportedError("not a sending Transport");
      } else if (!this._maxSctpMessageSize) {
        throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
      } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
        throw new TypeError('no "connect" listener set into this transport');
      } else if (this.listenerCount("producedata") === 0) {
        throw new TypeError('no "producedata" listener set into this transport');
      } else if (appData && typeof appData !== "object") {
        throw new TypeError("if given, appData must be an object");
      }
      if (maxPacketLifeTime || maxRetransmits) {
        ordered = false;
      }
      return this._awaitQueue.push(async () => {
        const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          label,
          protocol: protocol2
        });
        ortc2.validateAndNormalizeSctpStreamParameters(sctpStreamParameters);
        const { id } = await new Promise((resolve, reject) => {
          this.safeEmit("producedata", {
            sctpStreamParameters,
            label,
            protocol: protocol2,
            appData
          }, resolve, reject);
        });
        const dataProducer = new DataProducer_1.DataProducer({
          id,
          dataChannel,
          sctpStreamParameters,
          appData
        });
        this._dataProducers.set(dataProducer.id, dataProducer);
        this.handleDataProducer(dataProducer);
        this._observer.safeEmit("newdataproducer", dataProducer);
        return dataProducer;
      }, "transport.produceData()");
    }
    /**
     * Create a DataConsumer
     */
    async consumeData({ id, dataProducerId, sctpStreamParameters, label = "", protocol: protocol2 = "", appData = {} }) {
      logger.debug("consumeData()");
      if (this._closed) {
        throw new errors_1.InvalidStateError("closed");
      } else if (this._direction !== "recv") {
        throw new errors_1.UnsupportedError("not a receiving Transport");
      } else if (!this._maxSctpMessageSize) {
        throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
      } else if (typeof id !== "string") {
        throw new TypeError("missing id");
      } else if (typeof dataProducerId !== "string") {
        throw new TypeError("missing dataProducerId");
      } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
        throw new TypeError('no "connect" listener set into this transport');
      } else if (appData && typeof appData !== "object") {
        throw new TypeError("if given, appData must be an object");
      }
      const clonedSctpStreamParameters = utils2.clone(sctpStreamParameters);
      ortc2.validateAndNormalizeSctpStreamParameters(clonedSctpStreamParameters);
      return this._awaitQueue.push(async () => {
        const { dataChannel } = await this._handler.receiveDataChannel({
          sctpStreamParameters: clonedSctpStreamParameters,
          label,
          protocol: protocol2
        });
        const dataConsumer = new DataConsumer_1.DataConsumer({
          id,
          dataProducerId,
          dataChannel,
          sctpStreamParameters: clonedSctpStreamParameters,
          appData
        });
        this._dataConsumers.set(dataConsumer.id, dataConsumer);
        this.handleDataConsumer(dataConsumer);
        this._observer.safeEmit("newdataconsumer", dataConsumer);
        return dataConsumer;
      }, "transport.consumeData()");
    }
    // This method is guaranteed to never throw.
    createPendingConsumers() {
      this._consumerCreationInProgress = true;
      this._awaitQueue.push(async () => {
        if (this._pendingConsumerTasks.length === 0) {
          logger.debug("createPendingConsumers() | there is no Consumer to be created");
          return;
        }
        const pendingConsumerTasks = [...this._pendingConsumerTasks];
        this._pendingConsumerTasks = [];
        let videoConsumerForProbator = void 0;
        const optionsList = [];
        for (const task of pendingConsumerTasks) {
          const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;
          optionsList.push({
            trackId: id,
            kind,
            rtpParameters,
            streamId,
            onRtpReceiver
          });
        }
        try {
          const results = await this._handler.receive(optionsList);
          for (let idx = 0; idx < results.length; ++idx) {
            const task = pendingConsumerTasks[idx];
            const result = results[idx];
            const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
            const { localId, rtpReceiver, track } = result;
            const consumer2 = new Consumer_1.Consumer({
              id,
              localId,
              producerId,
              rtpReceiver,
              track,
              rtpParameters,
              appData
            });
            this._consumers.set(consumer2.id, consumer2);
            this.handleConsumer(consumer2);
            if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === "video") {
              videoConsumerForProbator = consumer2;
            }
            this._observer.safeEmit("newconsumer", consumer2);
            task.resolve(consumer2);
          }
        } catch (error) {
          for (const task of pendingConsumerTasks) {
            task.reject(error);
          }
        }
        if (videoConsumerForProbator) {
          try {
            const probatorRtpParameters = ortc2.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
            await this._handler.receive([
              {
                trackId: "probator",
                kind: "video",
                rtpParameters: probatorRtpParameters
              }
            ]);
            logger.debug("createPendingConsumers() | Consumer for RTP probation created");
            this._probatorConsumerCreated = true;
          } catch (error) {
            logger.error("createPendingConsumers() | failed to create Consumer for RTP probation:%o", error);
          }
        }
      }, "transport.createPendingConsumers()").then(() => {
        this._consumerCreationInProgress = false;
        if (this._pendingConsumerTasks.length > 0) {
          this.createPendingConsumers();
        }
      }).catch(() => {
      });
    }
    pausePendingConsumers() {
      this._consumerPauseInProgress = true;
      this._awaitQueue.push(async () => {
        if (this._pendingPauseConsumers.size === 0) {
          logger.debug("pausePendingConsumers() | there is no Consumer to be paused");
          return;
        }
        const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
        this._pendingPauseConsumers.clear();
        try {
          const localIds = pendingPauseConsumers.map((consumer2) => consumer2.localId);
          await this._handler.pauseReceiving(localIds);
        } catch (error) {
          logger.error("pausePendingConsumers() | failed to pause Consumers:", error);
        }
      }, "transport.pausePendingConsumers").then(() => {
        this._consumerPauseInProgress = false;
        if (this._pendingPauseConsumers.size > 0) {
          this.pausePendingConsumers();
        }
      }).catch(() => {
      });
    }
    resumePendingConsumers() {
      this._consumerResumeInProgress = true;
      this._awaitQueue.push(async () => {
        if (this._pendingResumeConsumers.size === 0) {
          logger.debug("resumePendingConsumers() | there is no Consumer to be resumed");
          return;
        }
        const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
        this._pendingResumeConsumers.clear();
        try {
          const localIds = pendingResumeConsumers.map((consumer2) => consumer2.localId);
          await this._handler.resumeReceiving(localIds);
        } catch (error) {
          logger.error("resumePendingConsumers() | failed to resume Consumers:", error);
        }
      }, "transport.resumePendingConsumers").then(() => {
        this._consumerResumeInProgress = false;
        if (this._pendingResumeConsumers.size > 0) {
          this.resumePendingConsumers();
        }
      }).catch(() => {
      });
    }
    closePendingConsumers() {
      this._consumerCloseInProgress = true;
      this._awaitQueue.push(async () => {
        if (this._pendingCloseConsumers.size === 0) {
          logger.debug("closePendingConsumers() | there is no Consumer to be closed");
          return;
        }
        const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
        this._pendingCloseConsumers.clear();
        try {
          await this._handler.stopReceiving(pendingCloseConsumers.map((consumer2) => consumer2.localId));
        } catch (error) {
          logger.error("closePendingConsumers() | failed to close Consumers:", error);
        }
      }, "transport.closePendingConsumers").then(() => {
        this._consumerCloseInProgress = false;
        if (this._pendingCloseConsumers.size > 0) {
          this.closePendingConsumers();
        }
      }).catch(() => {
      });
    }
    handleHandler() {
      const handler = this._handler;
      handler.on("@connect", ({ dtlsParameters }, callback2, errback) => {
        if (this._closed) {
          errback(new errors_1.InvalidStateError("closed"));
          return;
        }
        this.safeEmit("connect", { dtlsParameters }, callback2, errback);
      });
      handler.on("@icegatheringstatechange", (iceGatheringState) => {
        if (iceGatheringState === this._iceGatheringState) {
          return;
        }
        logger.debug("ICE gathering state changed to %s", iceGatheringState);
        this._iceGatheringState = iceGatheringState;
        if (!this._closed) {
          this.safeEmit("icegatheringstatechange", iceGatheringState);
        }
      });
      handler.on("@icecandidateerror", (event) => {
        logger.warn(`ICE candidate error [url:${event.url}, localAddress:${event.address}, localPort:${event.port}]: ${event.errorCode} "${event.errorText}"`);
        this.safeEmit("icecandidateerror", event);
      });
      handler.on("@connectionstatechange", (connectionState) => {
        if (connectionState === this._connectionState) {
          return;
        }
        logger.debug("connection state changed to %s", connectionState);
        this._connectionState = connectionState;
        if (!this._closed) {
          this.safeEmit("connectionstatechange", connectionState);
        }
      });
    }
    handleProducer(producer2) {
      producer2.on("@close", () => {
        this._producers.delete(producer2.id);
        if (this._closed) {
          return;
        }
        this._awaitQueue.push(async () => await this._handler.stopSending(producer2.localId), "producer @close event").catch((error) => logger.warn("producer.close() failed:%o", error));
      });
      producer2.on("@pause", (callback2, errback) => {
        this._awaitQueue.push(async () => await this._handler.pauseSending(producer2.localId), "producer @pause event").then(callback2).catch(errback);
      });
      producer2.on("@resume", (callback2, errback) => {
        this._awaitQueue.push(async () => await this._handler.resumeSending(producer2.localId), "producer @resume event").then(callback2).catch(errback);
      });
      producer2.on("@replacetrack", (track, callback2, errback) => {
        this._awaitQueue.push(async () => await this._handler.replaceTrack(producer2.localId, track), "producer @replacetrack event").then(callback2).catch(errback);
      });
      producer2.on("@setmaxspatiallayer", (spatialLayer, callback2, errback) => {
        this._awaitQueue.push(async () => await this._handler.setMaxSpatialLayer(producer2.localId, spatialLayer), "producer @setmaxspatiallayer event").then(callback2).catch(errback);
      });
      producer2.on("@setrtpencodingparameters", (params2, callback2, errback) => {
        this._awaitQueue.push(async () => await this._handler.setRtpEncodingParameters(producer2.localId, params2), "producer @setrtpencodingparameters event").then(callback2).catch(errback);
      });
      producer2.on("@getstats", (callback2, errback) => {
        if (this._closed) {
          return errback(new errors_1.InvalidStateError("closed"));
        }
        this._handler.getSenderStats(producer2.localId).then(callback2).catch(errback);
      });
    }
    handleConsumer(consumer2) {
      consumer2.on("@close", () => {
        this._consumers.delete(consumer2.id);
        this._pendingPauseConsumers.delete(consumer2.id);
        this._pendingResumeConsumers.delete(consumer2.id);
        if (this._closed) {
          return;
        }
        this._pendingCloseConsumers.set(consumer2.id, consumer2);
        if (this._consumerCloseInProgress === false) {
          this.closePendingConsumers();
        }
      });
      consumer2.on("@pause", () => {
        if (this._pendingResumeConsumers.has(consumer2.id)) {
          this._pendingResumeConsumers.delete(consumer2.id);
        }
        this._pendingPauseConsumers.set(consumer2.id, consumer2);
        queueMicrotask(() => {
          if (this._closed) {
            return;
          }
          if (this._consumerPauseInProgress === false) {
            this.pausePendingConsumers();
          }
        });
      });
      consumer2.on("@resume", () => {
        if (this._pendingPauseConsumers.has(consumer2.id)) {
          this._pendingPauseConsumers.delete(consumer2.id);
        }
        this._pendingResumeConsumers.set(consumer2.id, consumer2);
        queueMicrotask(() => {
          if (this._closed) {
            return;
          }
          if (this._consumerResumeInProgress === false) {
            this.resumePendingConsumers();
          }
        });
      });
      consumer2.on("@getstats", (callback2, errback) => {
        if (this._closed) {
          return errback(new errors_1.InvalidStateError("closed"));
        }
        this._handler.getReceiverStats(consumer2.localId).then(callback2).catch(errback);
      });
    }
    handleDataProducer(dataProducer) {
      dataProducer.on("@close", () => {
        this._dataProducers.delete(dataProducer.id);
      });
    }
    handleDataConsumer(dataConsumer) {
      dataConsumer.on("@close", () => {
        this._dataConsumers.delete(dataConsumer.id);
      });
    }
  };
  Transport2.Transport = Transport$12;
  return Transport2;
}
var Chrome111 = {};
var lib$1 = {};
var parser = {};
var grammar = { exports: {} };
var grammar_1 = grammar.exports;
var hasRequiredGrammar;
function requireGrammar() {
  if (hasRequiredGrammar) return grammar.exports;
  hasRequiredGrammar = 1;
  var grammar$1 = grammar.exports = {
    v: [{
      name: "version",
      reg: /^(\d*)$/
    }],
    o: [{
      // o=- 20518 0 IN IP4 203.0.113.1
      // NB: sessionId will be a String in most cases because it is huge
      name: "origin",
      reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
      names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
      format: "%s %s %d %s IP%d %s"
    }],
    // default parsing of these only (though some of these feel outdated)
    s: [{ name: "name" }],
    i: [{ name: "description" }],
    u: [{ name: "uri" }],
    e: [{ name: "email" }],
    p: [{ name: "phone" }],
    z: [{ name: "timezones" }],
    // TODO: this one can actually be parsed properly...
    r: [{ name: "repeats" }],
    // TODO: this one can also be parsed properly
    // k: [{}], // outdated thing ignored
    t: [{
      // t=0 0
      name: "timing",
      reg: /^(\d*) (\d*)/,
      names: ["start", "stop"],
      format: "%d %d"
    }],
    c: [{
      // c=IN IP4 10.47.197.26
      name: "connection",
      reg: /^IN IP(\d) (\S*)/,
      names: ["version", "ip"],
      format: "IN IP%d %s"
    }],
    b: [{
      // b=AS:4000
      push: "bandwidth",
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ["type", "limit"],
      format: "%s:%s"
    }],
    m: [{
      // m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
      names: ["type", "port", "protocol", "payloads"],
      format: "%s %d %s %s"
    }],
    a: [
      {
        // a=rtpmap:110 opus/48000/2
        push: "rtp",
        reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
        names: ["payload", "codec", "rate", "encoding"],
        format: function(o) {
          return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
        }
      },
      {
        // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
        // a=fmtp:111 minptime=10; useinbandfec=1
        push: "fmtp",
        reg: /^fmtp:(\d*) ([\S| ]*)/,
        names: ["payload", "config"],
        format: "fmtp:%d %s"
      },
      {
        // a=control:streamid=0
        name: "control",
        reg: /^control:(.*)/,
        format: "control:%s"
      },
      {
        // a=rtcp:65179 IN IP4 193.84.77.194
        name: "rtcp",
        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
        names: ["port", "netType", "ipVer", "address"],
        format: function(o) {
          return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
        }
      },
      {
        // a=rtcp-fb:98 trr-int 100
        push: "rtcpFbTrrInt",
        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
        names: ["payload", "value"],
        format: "rtcp-fb:%s trr-int %d"
      },
      {
        // a=rtcp-fb:98 nack rpsi
        push: "rtcpFb",
        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
        names: ["payload", "type", "subtype"],
        format: function(o) {
          return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
        }
      },
      {
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:1/recvonly URI-gps-string
        // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
        push: "ext",
        reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
        names: ["value", "direction", "encrypt-uri", "uri", "config"],
        format: function(o) {
          return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
        }
      },
      {
        // a=extmap-allow-mixed
        name: "extmapAllowMixed",
        reg: /^(extmap-allow-mixed)/
      },
      {
        // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
        push: "crypto",
        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
        names: ["id", "suite", "config", "sessionConfig"],
        format: function(o) {
          return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
        }
      },
      {
        // a=setup:actpass
        name: "setup",
        reg: /^setup:(\w*)/,
        format: "setup:%s"
      },
      {
        // a=connection:new
        name: "connectionType",
        reg: /^connection:(new|existing)/,
        format: "connection:%s"
      },
      {
        // a=mid:1
        name: "mid",
        reg: /^mid:([^\s]*)/,
        format: "mid:%s"
      },
      {
        // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
        name: "msid",
        reg: /^msid:(.*)/,
        format: "msid:%s"
      },
      {
        // a=ptime:20
        name: "ptime",
        reg: /^ptime:(\d*(?:\.\d*)*)/,
        format: "ptime:%d"
      },
      {
        // a=maxptime:60
        name: "maxptime",
        reg: /^maxptime:(\d*(?:\.\d*)*)/,
        format: "maxptime:%d"
      },
      {
        // a=sendrecv
        name: "direction",
        reg: /^(sendrecv|recvonly|sendonly|inactive)/
      },
      {
        // a=ice-lite
        name: "icelite",
        reg: /^(ice-lite)/
      },
      {
        // a=ice-ufrag:F7gI
        name: "iceUfrag",
        reg: /^ice-ufrag:(\S*)/,
        format: "ice-ufrag:%s"
      },
      {
        // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
        name: "icePwd",
        reg: /^ice-pwd:(\S*)/,
        format: "ice-pwd:%s"
      },
      {
        // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
        name: "fingerprint",
        reg: /^fingerprint:(\S*) (\S*)/,
        names: ["type", "hash"],
        format: "fingerprint:%s %s"
      },
      {
        // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
        // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
        // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
        push: "candidates",
        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
        names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
        format: function(o) {
          var str = "candidate:%s %d %s %d %s %d typ %s";
          str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
          str += o.tcptype != null ? " tcptype %s" : "%v";
          if (o.generation != null) {
            str += " generation %d";
          }
          str += o["network-id"] != null ? " network-id %d" : "%v";
          str += o["network-cost"] != null ? " network-cost %d" : "%v";
          return str;
        }
      },
      {
        // a=end-of-candidates (keep after the candidates line for readability)
        name: "endOfCandidates",
        reg: /^(end-of-candidates)/
      },
      {
        // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
        name: "remoteCandidates",
        reg: /^remote-candidates:(.*)/,
        format: "remote-candidates:%s"
      },
      {
        // a=ice-options:google-ice
        name: "iceOptions",
        reg: /^ice-options:(\S*)/,
        format: "ice-options:%s"
      },
      {
        // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
        push: "ssrcs",
        reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
        names: ["id", "attribute", "value"],
        format: function(o) {
          var str = "ssrc:%d";
          if (o.attribute != null) {
            str += " %s";
            if (o.value != null) {
              str += ":%s";
            }
          }
          return str;
        }
      },
      {
        // a=ssrc-group:FEC 1 2
        // a=ssrc-group:FEC-FR 3004364195 1080772241
        push: "ssrcGroups",
        // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
        names: ["semantics", "ssrcs"],
        format: "ssrc-group:%s %s"
      },
      {
        // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
        name: "msidSemantic",
        reg: /^msid-semantic:\s?(\w*) (\S*)/,
        names: ["semantic", "token"],
        format: "msid-semantic: %s %s"
        // space after ':' is not accidental
      },
      {
        // a=group:BUNDLE audio video
        push: "groups",
        reg: /^group:(\w*) (.*)/,
        names: ["type", "mids"],
        format: "group:%s %s"
      },
      {
        // a=rtcp-mux
        name: "rtcpMux",
        reg: /^(rtcp-mux)/
      },
      {
        // a=rtcp-rsize
        name: "rtcpRsize",
        reg: /^(rtcp-rsize)/
      },
      {
        // a=sctpmap:5000 webrtc-datachannel 1024
        name: "sctpmap",
        reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
        names: ["sctpmapNumber", "app", "maxMessageSize"],
        format: function(o) {
          return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
        }
      },
      {
        // a=x-google-flag:conference
        name: "xGoogleFlag",
        reg: /^x-google-flag:([^\s]*)/,
        format: "x-google-flag:%s"
      },
      {
        // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
        push: "rids",
        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
        names: ["id", "direction", "params"],
        format: function(o) {
          return o.params ? "rid:%s %s %s" : "rid:%s %s";
        }
      },
      {
        // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
        // a=imageattr:* send [x=800,y=640] recv *
        // a=imageattr:100 recv [x=320,y=240]
        push: "imageattrs",
        reg: new RegExp(
          // a=imageattr:97
          "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
        ),
        names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
        format: function(o) {
          return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
        }
      },
      {
        // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
        // a=simulcast:recv 1;4,5 send 6;7
        name: "simulcast",
        reg: new RegExp(
          // a=simulcast:
          "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
        ),
        names: ["dir1", "list1", "dir2", "list2"],
        format: function(o) {
          return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
        }
      },
      {
        // old simulcast draft 03 (implemented by Firefox)
        //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
        // a=simulcast: recv pt=97;98 send pt=97
        // a=simulcast: send rid=5;6;7 paused=6,7
        name: "simulcast_03",
        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
        names: ["value"],
        format: "simulcast: %s"
      },
      {
        // a=framerate:25
        // a=framerate:29.97
        name: "framerate",
        reg: /^framerate:(\d+(?:$|\.\d+))/,
        format: "framerate:%s"
      },
      {
        // RFC4570
        // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
        name: "sourceFilter",
        reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
        names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
        format: "source-filter: %s %s %s %s %s"
      },
      {
        // a=bundle-only
        name: "bundleOnly",
        reg: /^(bundle-only)/
      },
      {
        // a=label:1
        name: "label",
        reg: /^label:(.+)/,
        format: "label:%s"
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
        name: "sctpPort",
        reg: /^sctp-port:(\d+)$/,
        format: "sctp-port:%s"
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
        name: "maxMessageSize",
        reg: /^max-message-size:(\d+)$/,
        format: "max-message-size:%s"
      },
      {
        // RFC7273
        // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
        push: "tsRefClocks",
        reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
        names: ["clksrc", "clksrcExt"],
        format: function(o) {
          return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
        }
      },
      {
        // RFC7273
        // a=mediaclk:direct=963214424
        name: "mediaClk",
        reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
        names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
        format: function(o) {
          var str = "mediaclk:";
          str += o.id != null ? "id=%s %s" : "%v%s";
          str += o.mediaClockValue != null ? "=%s" : "";
          str += o.rateNumerator != null ? " rate=%s" : "";
          str += o.rateDenominator != null ? "/%s" : "";
          return str;
        }
      },
      {
        // a=keywds:keywords
        name: "keywords",
        reg: /^keywds:(.+)$/,
        format: "keywds:%s"
      },
      {
        // a=content:main
        name: "content",
        reg: /^content:(.+)/,
        format: "content:%s"
      },
      // BFCP https://tools.ietf.org/html/rfc4583
      {
        // a=floorctrl:c-s
        name: "bfcpFloorCtrl",
        reg: /^floorctrl:(c-only|s-only|c-s)/,
        format: "floorctrl:%s"
      },
      {
        // a=confid:1
        name: "bfcpConfId",
        reg: /^confid:(\d+)/,
        format: "confid:%s"
      },
      {
        // a=userid:1
        name: "bfcpUserId",
        reg: /^userid:(\d+)/,
        format: "userid:%s"
      },
      {
        // a=floorid:1
        name: "bfcpFloorId",
        reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
        names: ["id", "mStream"],
        format: "floorid:%s mstrm:%s"
      },
      {
        // any a= that we don't understand is kept verbatim on media.invalid
        push: "invalid",
        names: ["value"]
      }
    ]
  };
  Object.keys(grammar$1).forEach(function(key) {
    var objs = grammar$1[key];
    objs.forEach(function(obj) {
      if (!obj.reg) {
        obj.reg = /(.*)/;
      }
      if (!obj.format) {
        obj.format = "%s";
      }
    });
  });
  return grammar.exports;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  (function(exports) {
    var toIntIfInt = function(v) {
      return String(Number(v)) === v ? Number(v) : v;
    };
    var attachProperties = function(match, location2, names, rawName) {
      if (rawName && !names) {
        location2[rawName] = toIntIfInt(match[1]);
      } else {
        for (var i = 0; i < names.length; i += 1) {
          if (match[i + 1] != null) {
            location2[names[i]] = toIntIfInt(match[i + 1]);
          }
        }
      }
    };
    var parseReg = function(obj, location2, content) {
      var needsBlank = obj.name && obj.names;
      if (obj.push && !location2[obj.push]) {
        location2[obj.push] = [];
      } else if (needsBlank && !location2[obj.name]) {
        location2[obj.name] = {};
      }
      var keyLocation = obj.push ? {} : (
        // blank object that will be pushed
        needsBlank ? location2[obj.name] : location2
      );
      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
      if (obj.push) {
        location2[obj.push].push(keyLocation);
      }
    };
    var grammar2 = requireGrammar();
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    exports.parse = function(sdp) {
      var session = {}, media = [], location2 = session;
      sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
        var type = l[0];
        var content = l.slice(2);
        if (type === "m") {
          media.push({ rtp: [], fmtp: [] });
          location2 = media[media.length - 1];
        }
        for (var j = 0; j < (grammar2[type] || []).length; j += 1) {
          var obj = grammar2[type][j];
          if (obj.reg.test(content)) {
            return parseReg(obj, location2, content);
          }
        }
      });
      session.media = media;
      return session;
    };
    var paramReducer = function(acc, expr) {
      var s = expr.split(/=(.+)/, 2);
      if (s.length === 2) {
        acc[s[0]] = toIntIfInt(s[1]);
      } else if (s.length === 1 && expr.length > 1) {
        acc[s[0]] = void 0;
      }
      return acc;
    };
    exports.parseParams = function(str) {
      return str.split(/;\s?/).reduce(paramReducer, {});
    };
    exports.parseFmtpConfig = exports.parseParams;
    exports.parsePayloads = function(str) {
      return str.toString().split(" ").map(Number);
    };
    exports.parseRemoteCandidates = function(str) {
      var candidates = [];
      var parts2 = str.split(" ").map(toIntIfInt);
      for (var i = 0; i < parts2.length; i += 3) {
        candidates.push({
          component: parts2[i],
          ip: parts2[i + 1],
          port: parts2[i + 2]
        });
      }
      return candidates;
    };
    exports.parseImageAttributes = function(str) {
      return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
      });
    };
    exports.parseSimulcastStreamList = function(str) {
      return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
          var scid, paused = false;
          if (format[0] !== "~") {
            scid = toIntIfInt(format);
          } else {
            scid = toIntIfInt(format.substring(1, format.length));
            paused = true;
          }
          return {
            scid,
            paused
          };
        });
      });
    };
  })(parser);
  return parser;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  var grammar2 = requireGrammar();
  var formatRegExp = /%[sdv%]/g;
  var format = function(formatStr) {
    var i = 1;
    var args = arguments;
    var len = args.length;
    return formatStr.replace(formatRegExp, function(x) {
      if (i >= len) {
        return x;
      }
      var arg = args[i];
      i += 1;
      switch (x) {
        case "%%":
          return "%";
        case "%s":
          return String(arg);
        case "%d":
          return Number(arg);
        case "%v":
          return "";
      }
    });
  };
  var makeLine = function(type, obj, location2) {
    var str = obj.format instanceof Function ? obj.format(obj.push ? location2 : location2[obj.name]) : obj.format;
    var args = [type + "=" + str];
    if (obj.names) {
      for (var i = 0; i < obj.names.length; i += 1) {
        var n = obj.names[i];
        if (obj.name) {
          args.push(location2[obj.name][n]);
        } else {
          args.push(location2[obj.names[i]]);
        }
      }
    } else {
      args.push(location2[obj.name]);
    }
    return format.apply(null, args);
  };
  var defaultOuterOrder = [
    "v",
    "o",
    "s",
    "i",
    "u",
    "e",
    "p",
    "c",
    "b",
    "t",
    "r",
    "z",
    "a"
  ];
  var defaultInnerOrder = ["i", "c", "b", "a"];
  writer = function(session, opts) {
    opts = opts || {};
    if (session.version == null) {
      session.version = 0;
    }
    if (session.name == null) {
      session.name = " ";
    }
    session.media.forEach(function(mLine) {
      if (mLine.payloads == null) {
        mLine.payloads = "";
      }
    });
    var outerOrder = opts.outerOrder || defaultOuterOrder;
    var innerOrder = opts.innerOrder || defaultInnerOrder;
    var sdp = [];
    outerOrder.forEach(function(type) {
      grammar2[type].forEach(function(obj) {
        if (obj.name in session && session[obj.name] != null) {
          sdp.push(makeLine(type, obj, session));
        } else if (obj.push in session && session[obj.push] != null) {
          session[obj.push].forEach(function(el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
    session.media.forEach(function(mLine) {
      sdp.push(makeLine("m", grammar2.m[0], mLine));
      innerOrder.forEach(function(type) {
        grammar2[type].forEach(function(obj) {
          if (obj.name in mLine && mLine[obj.name] != null) {
            sdp.push(makeLine(type, obj, mLine));
          } else if (obj.push in mLine && mLine[obj.push] != null) {
            mLine[obj.push].forEach(function(el) {
              sdp.push(makeLine(type, obj, el));
            });
          }
        });
      });
    });
    return sdp.join("\r\n") + "\r\n";
  };
  return writer;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$1;
  hasRequiredLib$2 = 1;
  var parser2 = requireParser();
  var writer2 = requireWriter();
  var grammar2 = requireGrammar();
  lib$1.grammar = grammar2;
  lib$1.write = writer2;
  lib$1.parse = parser2.parse;
  lib$1.parseParams = parser2.parseParams;
  lib$1.parseFmtpConfig = parser2.parseFmtpConfig;
  lib$1.parsePayloads = parser2.parsePayloads;
  lib$1.parseRemoteCandidates = parser2.parseRemoteCandidates;
  lib$1.parseImageAttributes = parser2.parseImageAttributes;
  lib$1.parseSimulcastStreamList = parser2.parseSimulcastStreamList;
  return lib$1;
}
var scalabilityModes = {};
var hasRequiredScalabilityModes;
function requireScalabilityModes() {
  if (hasRequiredScalabilityModes) return scalabilityModes;
  hasRequiredScalabilityModes = 1;
  "use strict";
  Object.defineProperty(scalabilityModes, "__esModule", { value: true });
  scalabilityModes.parse = parse2;
  const ScalabilityModeRegex = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
  function parse2(scalabilityMode) {
    const match = ScalabilityModeRegex.exec(scalabilityMode ?? "");
    if (match) {
      return {
        spatialLayers: Number(match[1]),
        temporalLayers: Number(match[2])
      };
    } else {
      return {
        spatialLayers: 1,
        temporalLayers: 1
      };
    }
  }
  return scalabilityModes;
}
var commonUtils = {};
var hasRequiredCommonUtils;
function requireCommonUtils() {
  if (hasRequiredCommonUtils) return commonUtils;
  hasRequiredCommonUtils = 1;
  "use strict";
  Object.defineProperty(commonUtils, "__esModule", { value: true });
  commonUtils.extractRtpCapabilities = extractRtpCapabilities;
  commonUtils.extractDtlsParameters = extractDtlsParameters;
  commonUtils.getCname = getCname;
  commonUtils.applyCodecParameters = applyCodecParameters;
  const sdpTransform = requireLib$2();
  function extractRtpCapabilities({ sdpObject }) {
    const codecsMap = /* @__PURE__ */ new Map();
    const headerExtensionMap = /* @__PURE__ */ new Map();
    for (const m of sdpObject.media) {
      const kind = m.type;
      switch (kind) {
        case "audio":
        case "video": {
          break;
        }
        default: {
          continue;
        }
      }
      for (const rtp of m.rtp) {
        const codec = {
          kind,
          mimeType: `${kind}/${rtp.codec}`,
          preferredPayloadType: rtp.payload,
          clockRate: rtp.rate,
          channels: rtp.encoding,
          parameters: {},
          rtcpFeedback: []
        };
        codecsMap.set(codec.preferredPayloadType, codec);
      }
      for (const fmtp of m.fmtp ?? []) {
        const parameters = sdpTransform.parseParams(fmtp.config);
        const codec = codecsMap.get(fmtp.payload);
        if (!codec) {
          continue;
        }
        if (parameters == null ? void 0 : parameters.hasOwnProperty("profile-level-id")) {
          parameters["profile-level-id"] = String(parameters["profile-level-id"]);
        }
        codec.parameters = parameters;
      }
      for (const fb of m.rtcpFb ?? []) {
        const feedback = {
          type: fb.type,
          parameter: fb.subtype
        };
        if (!feedback.parameter) {
          delete feedback.parameter;
        }
        if (fb.payload !== "*") {
          const codec = codecsMap.get(Number(fb.payload));
          if (!codec) {
            continue;
          }
          codec.rtcpFeedback.push(feedback);
        } else {
          for (const codec of codecsMap.values()) {
            if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
              codec.rtcpFeedback.push(feedback);
            }
          }
        }
      }
      for (const ext of m.ext ?? []) {
        if (ext["encrypt-uri"]) {
          continue;
        }
        const headerExtension = {
          kind,
          uri: ext.uri,
          preferredId: ext.value
        };
        headerExtensionMap.set(headerExtension.preferredId, headerExtension);
      }
    }
    const rtpCapabilities2 = {
      codecs: Array.from(codecsMap.values()),
      headerExtensions: Array.from(headerExtensionMap.values())
    };
    return rtpCapabilities2;
  }
  function extractDtlsParameters({ sdpObject }) {
    let setup = sdpObject.setup;
    let fingerprint = sdpObject.fingerprint;
    if (!setup || !fingerprint) {
      const mediaObject = (sdpObject.media ?? []).find((m) => m.port !== 0);
      if (mediaObject) {
        setup ?? (setup = mediaObject.setup);
        fingerprint ?? (fingerprint = mediaObject.fingerprint);
      }
    }
    if (!setup) {
      throw new Error("no a=setup found at SDP session or media level");
    } else if (!fingerprint) {
      throw new Error("no a=fingerprint found at SDP session or media level");
    }
    let role;
    switch (setup) {
      case "active": {
        role = "client";
        break;
      }
      case "passive": {
        role = "server";
        break;
      }
      case "actpass": {
        role = "auto";
        break;
      }
    }
    const dtlsParameters = {
      role,
      fingerprints: [
        {
          algorithm: fingerprint.type,
          value: fingerprint.hash
        }
      ]
    };
    return dtlsParameters;
  }
  function getCname({ offerMediaObject }) {
    const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "cname");
    if (!ssrcCnameLine) {
      return "";
    }
    return ssrcCnameLine.value;
  }
  function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
    var _a;
    for (const codec of offerRtpParameters.codecs) {
      const mimeType = codec.mimeType.toLowerCase();
      if (mimeType !== "audio/opus") {
        continue;
      }
      const rtp = (answerMediaObject.rtp ?? []).find((r) => r.payload === codec.payloadType);
      if (!rtp) {
        continue;
      }
      answerMediaObject.fmtp = answerMediaObject.fmtp ?? [];
      let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
      if (!fmtp) {
        fmtp = { payload: codec.payloadType, config: "" };
        answerMediaObject.fmtp.push(fmtp);
      }
      const parameters = sdpTransform.parseParams(fmtp.config);
      switch (mimeType) {
        case "audio/opus": {
          const spropStereo = (_a = codec.parameters) == null ? void 0 : _a["sprop-stereo"];
          if (spropStereo !== void 0) {
            parameters["stereo"] = Number(spropStereo) ? 1 : 0;
          }
          break;
        }
      }
      fmtp.config = "";
      for (const key of Object.keys(parameters)) {
        if (fmtp.config) {
          fmtp.config += ";";
        }
        fmtp.config += `${key}=${parameters[key]}`;
      }
    }
  }
  return commonUtils;
}
var unifiedPlanUtils = {};
var hasRequiredUnifiedPlanUtils;
function requireUnifiedPlanUtils() {
  if (hasRequiredUnifiedPlanUtils) return unifiedPlanUtils;
  hasRequiredUnifiedPlanUtils = 1;
  "use strict";
  Object.defineProperty(unifiedPlanUtils, "__esModule", { value: true });
  unifiedPlanUtils.getRtpEncodings = getRtpEncodings;
  unifiedPlanUtils.addLegacySimulcast = addLegacySimulcast;
  function getRtpEncodings({ offerMediaObject }) {
    const ssrcs = /* @__PURE__ */ new Set();
    for (const line of offerMediaObject.ssrcs ?? []) {
      const ssrc = line.id;
      if (ssrc) {
        ssrcs.add(ssrc);
      }
    }
    if (ssrcs.size === 0) {
      throw new Error("no a=ssrc lines found");
    }
    const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
    for (const line of offerMediaObject.ssrcGroups ?? []) {
      if (line.semantics !== "FID") {
        continue;
      }
      const ssrcsStr = line.ssrcs.split(/\s+/);
      const ssrc = Number(ssrcsStr[0]);
      const rtxSsrc = Number(ssrcsStr[1]);
      if (ssrcs.has(ssrc)) {
        ssrcs.delete(ssrc);
        ssrcs.delete(rtxSsrc);
        ssrcToRtxSsrc.set(ssrc, rtxSsrc);
      }
    }
    for (const ssrc of ssrcs) {
      ssrcToRtxSsrc.set(ssrc, void 0);
    }
    const encodings = [];
    for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
      const encoding = { ssrc };
      if (rtxSsrc) {
        encoding.rtx = { ssrc: rtxSsrc };
      }
      encodings.push(encoding);
    }
    return encodings;
  }
  function addLegacySimulcast({ offerMediaObject, numStreams }) {
    if (numStreams <= 1) {
      throw new TypeError("numStreams must be greater than 1");
    }
    const ssrcMsidLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "msid");
    if (!ssrcMsidLine) {
      throw new Error("a=ssrc line with msid information not found");
    }
    const [streamId, trackId] = ssrcMsidLine.value.split(" ");
    const firstSsrc = Number(ssrcMsidLine.id);
    let firstRtxSsrc;
    (offerMediaObject.ssrcGroups ?? []).some((line) => {
      if (line.semantics !== "FID") {
        return false;
      }
      const ssrcs2 = line.ssrcs.split(/\s+/);
      if (Number(ssrcs2[0]) === firstSsrc) {
        firstRtxSsrc = Number(ssrcs2[1]);
        return true;
      } else {
        return false;
      }
    });
    const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "cname");
    if (!ssrcCnameLine) {
      throw new Error("a=ssrc line with cname information not found");
    }
    const cname = ssrcCnameLine.value;
    const ssrcs = [];
    const rtxSsrcs = [];
    for (let i = 0; i < numStreams; ++i) {
      ssrcs.push(firstSsrc + i);
      if (firstRtxSsrc) {
        rtxSsrcs.push(firstRtxSsrc + i);
      }
    }
    offerMediaObject.ssrcGroups = [];
    offerMediaObject.ssrcs = [];
    offerMediaObject.ssrcGroups.push({
      semantics: "SIM",
      ssrcs: ssrcs.join(" ")
    });
    for (const ssrc of ssrcs) {
      offerMediaObject.ssrcs.push({
        id: ssrc,
        attribute: "cname",
        value: cname
      });
      offerMediaObject.ssrcs.push({
        id: ssrc,
        attribute: "msid",
        value: `${streamId} ${trackId}`
      });
    }
    for (let i = 0; i < rtxSsrcs.length; ++i) {
      const ssrc = ssrcs[i];
      const rtxSsrc = rtxSsrcs[i];
      offerMediaObject.ssrcs.push({
        id: rtxSsrc,
        attribute: "cname",
        value: cname
      });
      offerMediaObject.ssrcs.push({
        id: rtxSsrc,
        attribute: "msid",
        value: `${streamId} ${trackId}`
      });
      offerMediaObject.ssrcGroups.push({
        semantics: "FID",
        ssrcs: `${ssrc} ${rtxSsrc}`
      });
    }
  }
  return unifiedPlanUtils;
}
var utils$1 = {};
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  "use strict";
  Object.defineProperty(utils$1, "__esModule", { value: true });
  utils$1.addNackSupportForOpus = addNackSupportForOpus;
  function addNackSupportForOpus(rtpCapabilities2) {
    var _a;
    for (const codec of rtpCapabilities2.codecs ?? []) {
      if ((codec.mimeType.toLowerCase() === "audio/opus" || codec.mimeType.toLowerCase() === "audio/multiopus") && !((_a = codec.rtcpFeedback) == null ? void 0 : _a.some((fb) => fb.type === "nack" && !fb.parameter))) {
        if (!codec.rtcpFeedback) {
          codec.rtcpFeedback = [];
        }
        codec.rtcpFeedback.push({ type: "nack" });
      }
    }
  }
  return utils$1;
}
var RemoteSdp = {};
var MediaSection = {};
var hasRequiredMediaSection;
function requireMediaSection() {
  if (hasRequiredMediaSection) return MediaSection;
  hasRequiredMediaSection = 1;
  "use strict";
  Object.defineProperty(MediaSection, "__esModule", { value: true });
  MediaSection.OfferMediaSection = MediaSection.AnswerMediaSection = MediaSection.MediaSection = void 0;
  const sdpTransform = requireLib$2();
  const utils2 = requireUtils$2();
  let MediaSection$1 = class MediaSection {
    constructor({ iceParameters, iceCandidates, dtlsParameters }) {
      // SDP media object.
      __publicField(this, "_mediaObject");
      this._mediaObject = {
        type: "",
        port: 0,
        protocol: "",
        payloads: "",
        rtp: [],
        fmtp: []
      };
      if (iceParameters) {
        this.setIceParameters(iceParameters);
      }
      if (iceCandidates) {
        this._mediaObject.candidates = [];
        for (const candidate of iceCandidates) {
          const candidateObject = {
            foundation: candidate.foundation,
            // mediasoup does mandates rtcp-mux so candidates component is always
            // RTP (1).
            component: 1,
            // Be ready for new candidate.address field in mediasoup server side
            // field and keep backward compatibility with deprecated candidate.ip.
            ip: candidate.address ?? candidate.ip,
            port: candidate.port,
            priority: candidate.priority,
            transport: candidate.protocol,
            type: candidate.type
          };
          if (candidate.tcpType) {
            candidateObject.tcptype = candidate.tcpType;
          }
          this._mediaObject.candidates.push(candidateObject);
        }
        this._mediaObject.endOfCandidates = "end-of-candidates";
        this._mediaObject.iceOptions = "renomination";
      }
      if (dtlsParameters) {
        this.setDtlsRole(dtlsParameters.role);
      }
    }
    get mid() {
      return String(this._mediaObject.mid);
    }
    get closed() {
      return this._mediaObject.port === 0;
    }
    getObject() {
      return this._mediaObject;
    }
    setIceParameters(iceParameters) {
      this._mediaObject.iceUfrag = iceParameters.usernameFragment;
      this._mediaObject.icePwd = iceParameters.password;
    }
    pause() {
      this._mediaObject.direction = "inactive";
    }
    disable() {
      this.pause();
      delete this._mediaObject.ext;
      delete this._mediaObject.ssrcs;
      delete this._mediaObject.ssrcGroups;
      delete this._mediaObject.simulcast;
      delete this._mediaObject.simulcast_03;
      delete this._mediaObject.rids;
      delete this._mediaObject.extmapAllowMixed;
    }
    close() {
      this.disable();
      this._mediaObject.port = 0;
    }
  };
  MediaSection.MediaSection = MediaSection$1;
  class AnswerMediaSection extends MediaSection$1 {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions }) {
      super({ iceParameters, iceCandidates, dtlsParameters });
      this._mediaObject.mid = String(offerMediaObject.mid);
      this._mediaObject.type = offerMediaObject.type;
      this._mediaObject.protocol = offerMediaObject.protocol;
      if (!plainRtpParameters) {
        this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
        this._mediaObject.port = 7;
      } else {
        this._mediaObject.connection = {
          ip: plainRtpParameters.ip,
          version: plainRtpParameters.ipVersion
        };
        this._mediaObject.port = plainRtpParameters.port;
      }
      switch (offerMediaObject.type) {
        case "audio":
        case "video": {
          this._mediaObject.direction = "recvonly";
          this._mediaObject.rtp = [];
          this._mediaObject.rtcpFb = [];
          this._mediaObject.fmtp = [];
          for (const codec of answerRtpParameters.codecs) {
            const rtp = {
              payload: codec.payloadType,
              codec: getCodecName(codec),
              rate: codec.clockRate
            };
            if (codec.channels > 1) {
              rtp.encoding = codec.channels;
            }
            this._mediaObject.rtp.push(rtp);
            const codecParameters = utils2.clone(codec.parameters) ?? {};
            let codecRtcpFeedback = utils2.clone(codec.rtcpFeedback) ?? [];
            if (codecOptions) {
              const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
              const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
              switch (codec.mimeType.toLowerCase()) {
                case "audio/opus":
                case "audio/multiopus": {
                  if (opusStereo !== void 0) {
                    offerCodec.parameters["sprop-stereo"] = opusStereo ? 1 : 0;
                    codecParameters["stereo"] = opusStereo ? 1 : 0;
                  }
                  if (opusFec !== void 0) {
                    offerCodec.parameters["useinbandfec"] = opusFec ? 1 : 0;
                    codecParameters["useinbandfec"] = opusFec ? 1 : 0;
                  }
                  if (opusDtx !== void 0) {
                    offerCodec.parameters["usedtx"] = opusDtx ? 1 : 0;
                    codecParameters["usedtx"] = opusDtx ? 1 : 0;
                  }
                  if (opusMaxPlaybackRate !== void 0) {
                    codecParameters["maxplaybackrate"] = opusMaxPlaybackRate;
                  }
                  if (opusMaxAverageBitrate !== void 0) {
                    codecParameters["maxaveragebitrate"] = opusMaxAverageBitrate;
                  }
                  if (opusPtime !== void 0) {
                    offerCodec.parameters["ptime"] = opusPtime;
                    codecParameters["ptime"] = opusPtime;
                  }
                  if (!opusNack) {
                    offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                    codecRtcpFeedback = codecRtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                  }
                  break;
                }
                case "video/vp8":
                case "video/vp9":
                case "video/h264":
                case "video/h265":
                case "video/av1": {
                  if (videoGoogleStartBitrate !== void 0) {
                    codecParameters["x-google-start-bitrate"] = videoGoogleStartBitrate;
                  }
                  if (videoGoogleMaxBitrate !== void 0) {
                    codecParameters["x-google-max-bitrate"] = videoGoogleMaxBitrate;
                  }
                  if (videoGoogleMinBitrate !== void 0) {
                    codecParameters["x-google-min-bitrate"] = videoGoogleMinBitrate;
                  }
                  break;
                }
              }
            }
            const fmtp = {
              payload: codec.payloadType,
              config: ""
            };
            for (const key of Object.keys(codecParameters)) {
              if (fmtp.config) {
                fmtp.config += ";";
              }
              fmtp.config += `${key}=${codecParameters[key]}`;
            }
            if (fmtp.config) {
              this._mediaObject.fmtp.push(fmtp);
            }
            for (const fb of codecRtcpFeedback) {
              this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
              });
            }
          }
          this._mediaObject.payloads = answerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
          this._mediaObject.ext = [];
          for (const ext of answerRtpParameters.headerExtensions) {
            const found = (offerMediaObject.ext ?? []).some((localExt) => localExt.uri === ext.uri);
            if (!found) {
              continue;
            }
            this._mediaObject.ext.push({
              uri: ext.uri,
              value: ext.id
            });
          }
          if (offerMediaObject.extmapAllowMixed === "extmap-allow-mixed") {
            this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
          }
          if (offerMediaObject.simulcast) {
            this._mediaObject.simulcast = {
              dir1: "recv",
              list1: offerMediaObject.simulcast.list1
            };
            this._mediaObject.rids = [];
            for (const rid of offerMediaObject.rids ?? []) {
              if (rid.direction !== "send") {
                continue;
              }
              this._mediaObject.rids.push({
                id: rid.id,
                direction: "recv"
              });
            }
          } else if (offerMediaObject.simulcast_03) {
            this._mediaObject.simulcast_03 = {
              value: offerMediaObject.simulcast_03.value.replace(/send/g, "recv")
            };
            this._mediaObject.rids = [];
            for (const rid of offerMediaObject.rids ?? []) {
              if (rid.direction !== "send") {
                continue;
              }
              this._mediaObject.rids.push({
                id: rid.id,
                direction: "recv"
              });
            }
          }
          this._mediaObject.rtcpMux = "rtcp-mux";
          this._mediaObject.rtcpRsize = "rtcp-rsize";
          break;
        }
        case "application": {
          if (typeof offerMediaObject.sctpPort === "number") {
            this._mediaObject.payloads = "webrtc-datachannel";
            this._mediaObject.sctpPort = sctpParameters.port;
            this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          } else if (offerMediaObject.sctpmap) {
            this._mediaObject.payloads = String(sctpParameters.port);
            this._mediaObject.sctpmap = {
              app: "webrtc-datachannel",
              sctpmapNumber: sctpParameters.port,
              maxMessageSize: sctpParameters.maxMessageSize
            };
          }
          break;
        }
      }
    }
    setDtlsRole(role) {
      switch (role) {
        case "client": {
          this._mediaObject.setup = "active";
          break;
        }
        case "server": {
          this._mediaObject.setup = "passive";
          break;
        }
        case "auto": {
          this._mediaObject.setup = "actpass";
          break;
        }
      }
    }
    resume() {
      this._mediaObject.direction = "recvonly";
    }
    muxSimulcastStreams(encodings) {
      var _a, _b;
      if (!((_a = this._mediaObject.simulcast) == null ? void 0 : _a.list1)) {
        return;
      }
      const layers = {};
      for (const encoding of encodings) {
        if (encoding.rid) {
          layers[encoding.rid] = encoding;
        }
      }
      const raw = this._mediaObject.simulcast.list1;
      const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
      for (const simulcastStream of simulcastStreams) {
        for (const simulcastFormat of simulcastStream) {
          simulcastFormat.paused = !((_b = layers[simulcastFormat.scid]) == null ? void 0 : _b.active);
        }
      }
      this._mediaObject.simulcast.list1 = simulcastStreams.map((simulcastFormats) => simulcastFormats.map((f) => `${f.paused ? "~" : ""}${f.scid}`).join(",")).join(";");
    }
  }
  MediaSection.AnswerMediaSection = AnswerMediaSection;
  class OfferMediaSection extends MediaSection$1 {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, mid, kind, offerRtpParameters, streamId, trackId }) {
      var _a;
      super({ iceParameters, iceCandidates, dtlsParameters });
      this._mediaObject.mid = String(mid);
      this._mediaObject.type = kind;
      if (!plainRtpParameters) {
        this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
        if (!sctpParameters) {
          this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
        } else {
          this._mediaObject.protocol = "UDP/DTLS/SCTP";
        }
        this._mediaObject.port = 7;
      } else {
        this._mediaObject.connection = {
          ip: plainRtpParameters.ip,
          version: plainRtpParameters.ipVersion
        };
        this._mediaObject.protocol = "RTP/AVP";
        this._mediaObject.port = plainRtpParameters.port;
      }
      this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
      switch (kind) {
        case "audio":
        case "video": {
          this._mediaObject.direction = "sendonly";
          this._mediaObject.rtp = [];
          this._mediaObject.rtcpFb = [];
          this._mediaObject.fmtp = [];
          this._mediaObject.msid = `${streamId ?? "-"} ${trackId}`;
          for (const codec of offerRtpParameters.codecs) {
            const rtp = {
              payload: codec.payloadType,
              codec: getCodecName(codec),
              rate: codec.clockRate
            };
            if (codec.channels > 1) {
              rtp.encoding = codec.channels;
            }
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
              payload: codec.payloadType,
              config: ""
            };
            for (const key of Object.keys(codec.parameters ?? {})) {
              if (fmtp.config) {
                fmtp.config += ";";
              }
              fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config) {
              this._mediaObject.fmtp.push(fmtp);
            }
            for (const fb of codec.rtcpFeedback) {
              this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
              });
            }
          }
          this._mediaObject.payloads = offerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
          this._mediaObject.ext = [];
          for (const ext of offerRtpParameters.headerExtensions) {
            this._mediaObject.ext.push({
              uri: ext.uri,
              value: ext.id
            });
          }
          this._mediaObject.rtcpMux = "rtcp-mux";
          this._mediaObject.rtcpRsize = "rtcp-rsize";
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = (_a = encoding.rtx) == null ? void 0 : _a.ssrc;
          this._mediaObject.ssrcs = [];
          this._mediaObject.ssrcGroups = [];
          if (ssrc && offerRtpParameters.rtcp.cname) {
            this._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: "cname",
              value: offerRtpParameters.rtcp.cname
            });
          }
          if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
              this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: "cname",
                value: offerRtpParameters.rtcp.cname
              });
            }
            if (ssrc) {
              this._mediaObject.ssrcGroups.push({
                semantics: "FID",
                ssrcs: `${ssrc} ${rtxSsrc}`
              });
            }
          }
          break;
        }
        case "application": {
          this._mediaObject.payloads = "webrtc-datachannel";
          this._mediaObject.sctpPort = sctpParameters.port;
          this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
          break;
        }
      }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setDtlsRole(role) {
      this._mediaObject.setup = "actpass";
    }
    resume() {
      this._mediaObject.direction = "sendonly";
    }
  }
  MediaSection.OfferMediaSection = OfferMediaSection;
  function getCodecName(codec) {
    const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
    const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
    if (!mimeTypeMatch) {
      throw new TypeError("invalid codec.mimeType");
    }
    return mimeTypeMatch[2];
  }
  return MediaSection;
}
var hasRequiredRemoteSdp;
function requireRemoteSdp() {
  if (hasRequiredRemoteSdp) return RemoteSdp;
  hasRequiredRemoteSdp = 1;
  "use strict";
  Object.defineProperty(RemoteSdp, "__esModule", { value: true });
  RemoteSdp.RemoteSdp = void 0;
  const sdpTransform = requireLib$2();
  const Logger_1 = requireLogger$2();
  const MediaSection_1 = requireMediaSection();
  const DD_CODECS = ["av1", "h264"];
  const logger = new Logger_1.Logger("RemoteSdp");
  let RemoteSdp$1 = class RemoteSdp {
    constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters }) {
      // Remote ICE parameters.
      __publicField(this, "_iceParameters");
      // Remote ICE candidates.
      __publicField(this, "_iceCandidates");
      // Remote DTLS parameters.
      __publicField(this, "_dtlsParameters");
      // Remote SCTP parameters.
      __publicField(this, "_sctpParameters");
      // Parameters for plain RTP (no SRTP nor DTLS no BUNDLE).
      __publicField(this, "_plainRtpParameters");
      // MediaSection instances with same order as in the SDP.
      __publicField(this, "_mediaSections", []);
      // MediaSection indices indexed by MID.
      __publicField(this, "_midToIndex", /* @__PURE__ */ new Map());
      // First MID.
      __publicField(this, "_firstMid");
      // SDP object.
      __publicField(this, "_sdpObject");
      this._iceParameters = iceParameters;
      this._iceCandidates = iceCandidates;
      this._dtlsParameters = dtlsParameters;
      this._sctpParameters = sctpParameters;
      this._plainRtpParameters = plainRtpParameters;
      this._sdpObject = {
        version: 0,
        origin: {
          address: "0.0.0.0",
          ipVer: 4,
          netType: "IN",
          sessionId: "10000",
          sessionVersion: 0,
          username: "mediasoup-client"
        },
        name: "-",
        timing: { start: 0, stop: 0 },
        media: []
      };
      if (iceParameters == null ? void 0 : iceParameters.iceLite) {
        this._sdpObject.icelite = "ice-lite";
      }
      if (dtlsParameters) {
        this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
        const numFingerprints = this._dtlsParameters.fingerprints.length;
        this._sdpObject.fingerprint = {
          type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
          hash: dtlsParameters.fingerprints[numFingerprints - 1].value
        };
        this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
      }
      if (plainRtpParameters) {
        this._sdpObject.origin.address = plainRtpParameters.ip;
        this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
      }
    }
    updateIceParameters(iceParameters) {
      logger.debug("updateIceParameters() [iceParameters:%o]", iceParameters);
      this._iceParameters = iceParameters;
      this._sdpObject.icelite = iceParameters.iceLite ? "ice-lite" : void 0;
      for (const mediaSection of this._mediaSections) {
        mediaSection.setIceParameters(iceParameters);
      }
    }
    updateDtlsRole(role) {
      logger.debug("updateDtlsRole() [role:%s]", role);
      this._dtlsParameters.role = role;
      for (const mediaSection of this._mediaSections) {
        mediaSection.setDtlsRole(role);
      }
    }
    /**
     * Set session level a=extmap-allow-mixed attibute.
     */
    setSessionExtmapAllowMixed() {
      logger.debug("setSessionExtmapAllowMixed()");
      this._sdpObject.extmapAllowMixed = "extmap-allow-mixed";
    }
    getNextMediaSectionIdx() {
      for (let idx = 0; idx < this._mediaSections.length; ++idx) {
        const mediaSection = this._mediaSections[idx];
        if (mediaSection.closed) {
          return { idx, reuseMid: mediaSection.mid };
        }
      }
      return { idx: this._mediaSections.length };
    }
    send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions }) {
      var _a;
      const mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        plainRtpParameters: this._plainRtpParameters,
        offerMediaObject,
        offerRtpParameters,
        answerRtpParameters,
        codecOptions
      });
      const mediaObject = mediaSection.getObject();
      const ddCodec = mediaObject.rtp.find((rtp) => DD_CODECS.includes(rtp.codec.toLowerCase()));
      if (!ddCodec) {
        mediaObject.ext = (_a = mediaObject.ext) == null ? void 0 : _a.filter((extmap) => extmap.uri !== "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension");
      }
      if (reuseMid) {
        this._replaceMediaSection(mediaSection, reuseMid);
      } else if (!this._midToIndex.has(mediaSection.mid)) {
        this._addMediaSection(mediaSection);
      } else {
        this._replaceMediaSection(mediaSection);
      }
    }
    receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
      this.setSessionExtmapAllowMixed();
      const mediaSection = new MediaSection_1.OfferMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        plainRtpParameters: this._plainRtpParameters,
        mid,
        kind,
        offerRtpParameters,
        streamId,
        trackId
      });
      const oldMediaSection = this._mediaSections.find((m) => m.closed);
      if (oldMediaSection) {
        this._replaceMediaSection(mediaSection, oldMediaSection.mid);
      } else {
        this._addMediaSection(mediaSection);
      }
    }
    pauseMediaSection(mid) {
      const mediaSection = this._findMediaSection(mid);
      mediaSection.pause();
    }
    resumeSendingMediaSection(mid) {
      const mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
    resumeReceivingMediaSection(mid) {
      const mediaSection = this._findMediaSection(mid);
      mediaSection.resume();
    }
    disableMediaSection(mid) {
      const mediaSection = this._findMediaSection(mid);
      mediaSection.disable();
    }
    /**
     * Closes media section. Returns true if the given MID corresponds to a m
     * section that has been indeed closed. False otherwise.
     *
     * NOTE: Closing the first m section is a pain since it invalidates the bundled
     * transport, so instead closing it we just disable it.
     */
    closeMediaSection(mid) {
      const mediaSection = this._findMediaSection(mid);
      if (mid === this._firstMid) {
        logger.debug("closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", mid);
        this.disableMediaSection(mid);
        return false;
      }
      mediaSection.close();
      this._regenerateBundleMids();
      return true;
    }
    muxMediaSectionSimulcast(mid, encodings) {
      const mediaSection = this._findMediaSection(mid);
      mediaSection.muxSimulcastStreams(encodings);
      this._replaceMediaSection(mediaSection);
    }
    sendSctpAssociation({ offerMediaObject }) {
      const mediaSection = new MediaSection_1.AnswerMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        offerMediaObject
      });
      this._addMediaSection(mediaSection);
    }
    receiveSctpAssociation() {
      const mediaSection = new MediaSection_1.OfferMediaSection({
        iceParameters: this._iceParameters,
        iceCandidates: this._iceCandidates,
        dtlsParameters: this._dtlsParameters,
        sctpParameters: this._sctpParameters,
        plainRtpParameters: this._plainRtpParameters,
        mid: "datachannel",
        kind: "application"
      });
      this._addMediaSection(mediaSection);
    }
    getSdp() {
      this._sdpObject.origin.sessionVersion++;
      return sdpTransform.write(this._sdpObject);
    }
    _addMediaSection(newMediaSection) {
      if (!this._firstMid) {
        this._firstMid = newMediaSection.mid;
      }
      this._mediaSections.push(newMediaSection);
      this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
      this._sdpObject.media.push(newMediaSection.getObject());
      this._regenerateBundleMids();
    }
    _replaceMediaSection(newMediaSection, reuseMid) {
      if (typeof reuseMid === "string") {
        const idx = this._midToIndex.get(reuseMid);
        if (idx === void 0) {
          throw new Error(`no media section found for reuseMid '${reuseMid}'`);
        }
        const oldMediaSection = this._mediaSections[idx];
        this._mediaSections[idx] = newMediaSection;
        this._midToIndex.delete(oldMediaSection.mid);
        this._midToIndex.set(newMediaSection.mid, idx);
        this._sdpObject.media[idx] = newMediaSection.getObject();
        this._regenerateBundleMids();
      } else {
        const idx = this._midToIndex.get(newMediaSection.mid);
        if (idx === void 0) {
          throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
        }
        this._mediaSections[idx] = newMediaSection;
        this._sdpObject.media[idx] = newMediaSection.getObject();
      }
    }
    _findMediaSection(mid) {
      const idx = this._midToIndex.get(mid);
      if (idx === void 0) {
        throw new Error(`no media section found with mid '${mid}'`);
      }
      return this._mediaSections[idx];
    }
    _regenerateBundleMids() {
      if (!this._dtlsParameters) {
        return;
      }
      this._sdpObject.groups[0].mids = this._mediaSections.filter((mediaSection) => !mediaSection.closed).map((mediaSection) => mediaSection.mid).join(" ");
    }
  };
  RemoteSdp.RemoteSdp = RemoteSdp$1;
  return RemoteSdp;
}
var hasRequiredChrome111;
function requireChrome111() {
  if (hasRequiredChrome111) return Chrome111;
  hasRequiredChrome111 = 1;
  "use strict";
  Object.defineProperty(Chrome111, "__esModule", { value: true });
  Chrome111.Chrome111 = void 0;
  const sdpTransform = requireLib$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const Logger_1 = requireLogger$2();
  const ortc2 = requireOrtc();
  const errors_1 = requireErrors$1();
  const scalabilityModes_1 = requireScalabilityModes();
  const sdpCommonUtils = requireCommonUtils();
  const sdpUnifiedPlanUtils = requireUnifiedPlanUtils();
  const ortcUtils = requireUtils$1();
  const RemoteSdp_1 = requireRemoteSdp();
  const logger = new Logger_1.Logger("Chrome111");
  const NAME = "Chrome111";
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  let Chrome111$1 = class Chrome1112 extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
      super();
      // Closed flag.
      __publicField(this, "_closed", false);
      // Handler direction.
      __publicField(this, "_direction");
      // Remote SDP handler.
      __publicField(this, "_remoteSdp");
      // Callback to request sending extended RTP capabilities on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      __publicField(this, "_forcedLocalDtlsRole");
      // RTCPeerConnection instance.
      __publicField(this, "_pc");
      // Map of RTCTransceivers indexed by MID.
      __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
      // Local stream for sending.
      __publicField(this, "_sendStream", new MediaStream());
      // Whether a DataChannel m=application section has been created.
      __publicField(this, "_hasDataChannelMediaSection", false);
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      __publicField(this, "_nextSendSctpStreamId", 0);
      // Got transport local and remote parameters.
      __publicField(this, "_transportReady", false);
      __publicField(this, "onIceGatheringStateChange", () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      });
      __publicField(this, "onIceCandidateError", (event) => {
        this.emit("@icecandidateerror", event);
      });
      __publicField(this, "onConnectionStateChange", () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      });
      __publicField(this, "onIceConnectionStateChange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      });
      logger.debug("constructor()");
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters
      });
      this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
      if (dtlsParameters.role && dtlsParameters.role !== "auto") {
        this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
      }
      this._pc = new RTCPeerConnection({
        iceServers: iceServers ?? [],
        iceTransportPolicy: iceTransportPolicy ?? "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        ...additionalSettings
      });
      this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
      if (this._pc.connectionState) {
        this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
      } else {
        logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
        this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      }
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
      return {
        name: NAME,
        factory: (options) => new Chrome1112(options),
        getNativeRtpCapabilities: async () => {
          logger.debug("getNativeRtpCapabilities()");
          let pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video", {
              sendEncodings: [{ scalabilityMode: "L3T3" }]
            });
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            pc = void 0;
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = Chrome1112.getLocalRtpCapabilities(sdpObject);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc == null ? void 0 : pc.close();
            } catch (error2) {
            }
            pc = void 0;
            throw error;
          }
        },
        getNativeSctpCapabilities: async () => {
          logger.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
      };
    }
    static getLocalRtpCapabilities(localSdpObject) {
      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      ortc2.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
    get name() {
      return NAME;
    }
    close() {
      logger.debug("close()");
      if (this._closed) {
        return;
      }
      this._closed = true;
      try {
        this._pc.close();
      } catch (error) {
      }
      this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
      this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
      this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      this.emit("@close");
      super.close();
    }
    async updateIceServers(iceServers) {
      this.assertNotClosed();
      logger.debug("updateIceServers()");
      const configuration = this._pc.getConfiguration();
      configuration.iceServers = iceServers;
      this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
      this.assertNotClosed();
      logger.debug("restartIce()");
      this._remoteSdp.updateIceParameters(iceParameters);
      if (!this._transportReady) {
        return;
      }
      if (this._direction === "send") {
        const offer = await this._pc.createOffer({ iceRestart: true });
        logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      } else {
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
    }
    async getTransportStats() {
      this.assertNotClosed();
      return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender }) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
      if (encodings && encodings.length > 1) {
        let maxTemporalLayers = 1;
        for (const encoding of encodings) {
          const temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
          if (temporalLayers > maxTemporalLayers) {
            maxTemporalLayers = temporalLayers;
          }
        }
        encodings.forEach((encoding, idx) => {
          encoding.rid = `r${idx}`;
          encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
        });
      }
      const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
      const transceiver = this._pc.addTransceiver(track, {
        direction: "sendonly",
        streams: [this._sendStream],
        sendEncodings: encodings
      });
      if (onRtpSender) {
        onRtpSender(transceiver.sender);
      }
      const offer = await this._pc.createOffer();
      let localSdpObject = sdpTransform.parse(offer.sdp);
      if (localSdpObject.extmapAllowMixed) {
        this._remoteSdp.setSessionExtmapAllowMixed();
      }
      const nativeRtpCapabilities = Chrome1112.getLocalRtpCapabilities(localSdpObject);
      const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
      const sendingRtpParameters = ortc2.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRtpParameters.codecs = ortc2.reduceCodecs(sendingRtpParameters.codecs, codec);
      const sendingRemoteRtpParameters = ortc2.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRemoteRtpParameters.codecs = ortc2.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const localId = transceiver.mid;
      sendingRtpParameters.mid = localId;
      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
      sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
        offerMediaObject
      });
      if (!encodings) {
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
      } else if (encodings.length === 1) {
        const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
        Object.assign(newEncodings[0], encodings[0]);
        sendingRtpParameters.encodings = newEncodings;
      } else {
        sendingRtpParameters.encodings = encodings;
      }
      this._remoteSdp.send({
        offerMediaObject,
        reuseMid: mediaSectionIdx.reuseMid,
        offerRtpParameters: sendingRtpParameters,
        answerRtpParameters: sendingRemoteRtpParameters,
        codecOptions
      });
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.set(localId, transceiver);
      return {
        localId,
        rtpParameters: sendingRtpParameters,
        rtpSender: transceiver.sender
      };
    }
    async stopSending(localId) {
      this.assertSendDirection();
      logger.debug("stopSending() [localId:%s]", localId);
      if (this._closed) {
        return;
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      void transceiver.sender.replaceTrack(null);
      this._pc.removeTrack(transceiver.sender);
      const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
      if (mediaSectionClosed) {
        try {
          transceiver.stop();
        } catch (error) {
        }
      }
      const offer = await this._pc.createOffer();
      logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("pauseSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "inactive";
      this._remoteSdp.pauseMediaSection(localId);
      const offer = await this._pc.createOffer();
      logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("resumeSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      this._remoteSdp.resumeSendingMediaSection(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "sendonly";
      const offer = await this._pc.createOffer();
      logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
      this.assertNotClosed();
      this.assertSendDirection();
      if (track) {
        logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
      } else {
        logger.debug("replaceTrack() [localId:%s, no track]", localId);
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        if (idx <= spatialLayer) {
          encoding.active = true;
        } else {
          encoding.active = false;
        }
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params2) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params2);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        parameters.encodings[idx] = { ...encoding, ...params2 };
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertSendDirection();
      const options = {
        negotiated: true,
        id: this._nextSendSctpStreamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("sendDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
      if (!this._hasDataChannelMediaSection) {
        const offer = await this._pc.createOffer();
        const localSdpObject = sdpTransform.parse(offer.sdp);
        const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        this._remoteSdp.sendSctpAssociation({ offerMediaObject });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      const sctpStreamParameters = {
        streamId: options.id,
        ordered: options.ordered,
        maxPacketLifeTime: options.maxPacketLifeTime,
        maxRetransmits: options.maxRetransmits
      };
      return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const results = [];
      const mapLocalId = /* @__PURE__ */ new Map();
      for (const options of optionsList) {
        const { trackId, kind, rtpParameters, streamId } = options;
        logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
        const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
        mapLocalId.set(trackId, localId);
        this._remoteSdp.receive({
          mid: localId,
          kind,
          offerRtpParameters: rtpParameters,
          streamId: streamId ?? rtpParameters.rtcp.cname,
          trackId
        });
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      for (const options of optionsList) {
        const { trackId, onRtpReceiver } = options;
        if (onRtpReceiver) {
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
          if (!transceiver) {
            throw new Error("transceiver not found");
          }
          onRtpReceiver(transceiver.receiver);
        }
      }
      let answer = await this._pc.createAnswer();
      const localSdpObject = sdpTransform.parse(answer.sdp);
      for (const options of optionsList) {
        const { trackId, rtpParameters } = options;
        const localId = mapLocalId.get(trackId);
        const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
        sdpCommonUtils.applyCodecParameters({
          offerRtpParameters: rtpParameters,
          answerMediaObject
        });
      }
      answer = {
        type: "answer",
        sdp: sdpTransform.write(localSdpObject)
      };
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const options of optionsList) {
        const { trackId } = options;
        const localId = mapLocalId.get(trackId);
        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
        if (!transceiver) {
          throw new Error("new RTCRtpTransceiver not found");
        } else {
          this._mapMidTransceiver.set(localId, transceiver);
          results.push({
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
          });
        }
      }
      return results;
    }
    async stopReceiving(localIds) {
      this.assertRecvDirection();
      if (this._closed) {
        return;
      }
      for (const localId of localIds) {
        logger.debug("stopReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        this._remoteSdp.closeMediaSection(transceiver.mid);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const localId of localIds) {
        this._mapMidTransceiver.delete(localId);
      }
    }
    async pauseReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("pauseReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("resumeReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "recvonly";
        this._remoteSdp.resumeReceivingMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
      const options = {
        negotiated: true,
        id: streamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("receiveDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      if (!this._hasDataChannelMediaSection) {
        this._remoteSdp.receiveSctpAssociation();
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        if (!this._transportReady) {
          const localSdpObject = sdpTransform.parse(answer.sdp);
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject }) {
      if (!localSdpObject) {
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      }
      const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
        sdpObject: localSdpObject
      });
      dtlsParameters.role = localDtlsRole;
      this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
      await new Promise((resolve, reject) => {
        this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
      });
      this._transportReady = true;
    }
    assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("method called in a closed handler");
      }
    }
    assertSendDirection() {
      if (this._direction !== "send") {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
    assertRecvDirection() {
      if (this._direction !== "recv") {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  };
  Chrome111.Chrome111 = Chrome111$1;
  return Chrome111;
}
var Chrome74 = {};
var hasRequiredChrome74;
function requireChrome74() {
  if (hasRequiredChrome74) return Chrome74;
  hasRequiredChrome74 = 1;
  "use strict";
  Object.defineProperty(Chrome74, "__esModule", { value: true });
  Chrome74.Chrome74 = void 0;
  const sdpTransform = requireLib$2();
  const Logger_1 = requireLogger$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const ortc2 = requireOrtc();
  const errors_1 = requireErrors$1();
  const scalabilityModes_1 = requireScalabilityModes();
  const sdpCommonUtils = requireCommonUtils();
  const sdpUnifiedPlanUtils = requireUnifiedPlanUtils();
  const ortcUtils = requireUtils$1();
  const RemoteSdp_1 = requireRemoteSdp();
  const logger = new Logger_1.Logger("Chrome74");
  const NAME = "Chrome74";
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  let Chrome74$1 = class Chrome742 extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
      super();
      // Closed flag.
      __publicField(this, "_closed", false);
      // Handler direction.
      __publicField(this, "_direction");
      // Remote SDP handler.
      __publicField(this, "_remoteSdp");
      // Callback to request sending extended RTP capabilities on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      __publicField(this, "_forcedLocalDtlsRole");
      // RTCPeerConnection instance.
      __publicField(this, "_pc");
      // Map of RTCTransceivers indexed by MID.
      __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
      // Local stream for sending.
      __publicField(this, "_sendStream", new MediaStream());
      // Whether a DataChannel m=application section has been created.
      __publicField(this, "_hasDataChannelMediaSection", false);
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      __publicField(this, "_nextSendSctpStreamId", 0);
      // Got transport local and remote parameters.
      __publicField(this, "_transportReady", false);
      __publicField(this, "onIceGatheringStateChange", () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      });
      __publicField(this, "onIceCandidateError", (event) => {
        this.emit("@icecandidateerror", event);
      });
      __publicField(this, "onConnectionStateChange", () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      });
      __publicField(this, "onIceConnectionStateChange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      });
      logger.debug("constructor()");
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters
      });
      this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
      if (dtlsParameters.role && dtlsParameters.role !== "auto") {
        this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
      }
      this._pc = new RTCPeerConnection({
        iceServers: iceServers ?? [],
        iceTransportPolicy: iceTransportPolicy ?? "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        ...additionalSettings
      });
      this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
      if (this._pc.connectionState) {
        this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
      } else {
        logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
        this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      }
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
      return {
        name: NAME,
        factory: (options) => new Chrome742(options),
        getNativeRtpCapabilities: async () => {
          logger.debug("getNativeRtpCapabilities()");
          let pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            pc = void 0;
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = Chrome742.getLocalRtpCapabilities(sdpObject);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc == null ? void 0 : pc.close();
            } catch (error2) {
            }
            pc = void 0;
            throw error;
          }
        },
        getNativeSctpCapabilities: async () => {
          logger.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
      };
    }
    static getLocalRtpCapabilities(localSdpObject) {
      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      ortc2.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
    get name() {
      return NAME;
    }
    close() {
      logger.debug("close()");
      if (this._closed) {
        return;
      }
      this._closed = true;
      try {
        this._pc.close();
      } catch (error) {
      }
      this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
      this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
      this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      this.emit("@close");
      super.close();
    }
    async updateIceServers(iceServers) {
      this.assertNotClosed();
      logger.debug("updateIceServers()");
      const configuration = this._pc.getConfiguration();
      configuration.iceServers = iceServers;
      this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
      this.assertNotClosed();
      logger.debug("restartIce()");
      this._remoteSdp.updateIceParameters(iceParameters);
      if (!this._transportReady) {
        return;
      }
      if (this._direction === "send") {
        const offer = await this._pc.createOffer({ iceRestart: true });
        logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      } else {
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
    }
    async getTransportStats() {
      this.assertNotClosed();
      return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec }) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
      if (encodings && encodings.length > 1) {
        encodings.forEach((encoding, idx) => {
          encoding.rid = `r${idx}`;
        });
      }
      const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
      const transceiver = this._pc.addTransceiver(track, {
        direction: "sendonly",
        streams: [this._sendStream],
        sendEncodings: encodings
      });
      let offer = await this._pc.createOffer();
      let localSdpObject = sdpTransform.parse(offer.sdp);
      if (localSdpObject.extmapAllowMixed) {
        this._remoteSdp.setSessionExtmapAllowMixed();
      }
      const nativeRtpCapabilities = Chrome742.getLocalRtpCapabilities(localSdpObject);
      const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
      const sendingRtpParameters = ortc2.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRtpParameters.codecs = ortc2.reduceCodecs(sendingRtpParameters.codecs, codec);
      const sendingRemoteRtpParameters = ortc2.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRemoteRtpParameters.codecs = ortc2.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      let hackVp9Svc = false;
      const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
      let offerMediaObject;
      if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
        logger.debug("send() | enabling legacy simulcast for VP9 SVC");
        hackVp9Svc = true;
        localSdpObject = sdpTransform.parse(offer.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        sdpUnifiedPlanUtils.addLegacySimulcast({
          offerMediaObject,
          numStreams: layers.spatialLayers
        });
        offer = {
          type: "offer",
          sdp: sdpTransform.write(localSdpObject)
        };
      }
      logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const localId = transceiver.mid;
      sendingRtpParameters.mid = localId;
      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
      sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
        offerMediaObject
      });
      if (!encodings) {
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
      } else if (encodings.length === 1) {
        let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
        Object.assign(newEncodings[0], encodings[0]);
        if (hackVp9Svc) {
          newEncodings = [newEncodings[0]];
        }
        sendingRtpParameters.encodings = newEncodings;
      } else {
        sendingRtpParameters.encodings = encodings;
      }
      if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
        for (const encoding of sendingRtpParameters.encodings) {
          if (encoding.scalabilityMode) {
            encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
          } else {
            encoding.scalabilityMode = "L1T3";
          }
        }
      }
      this._remoteSdp.send({
        offerMediaObject,
        reuseMid: mediaSectionIdx.reuseMid,
        offerRtpParameters: sendingRtpParameters,
        answerRtpParameters: sendingRemoteRtpParameters,
        codecOptions
      });
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.set(localId, transceiver);
      return {
        localId,
        rtpParameters: sendingRtpParameters,
        rtpSender: transceiver.sender
      };
    }
    async stopSending(localId) {
      this.assertSendDirection();
      logger.debug("stopSending() [localId:%s]", localId);
      if (this._closed) {
        return;
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      void transceiver.sender.replaceTrack(null);
      this._pc.removeTrack(transceiver.sender);
      const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
      if (mediaSectionClosed) {
        try {
          transceiver.stop();
        } catch (error) {
        }
      }
      const offer = await this._pc.createOffer();
      logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("pauseSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "inactive";
      this._remoteSdp.pauseMediaSection(localId);
      const offer = await this._pc.createOffer();
      logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("resumeSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      this._remoteSdp.resumeSendingMediaSection(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "sendonly";
      const offer = await this._pc.createOffer();
      logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
      this.assertNotClosed();
      this.assertSendDirection();
      if (track) {
        logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
      } else {
        logger.debug("replaceTrack() [localId:%s, no track]", localId);
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        if (idx <= spatialLayer) {
          encoding.active = true;
        } else {
          encoding.active = false;
        }
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params2) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params2);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        parameters.encodings[idx] = { ...encoding, ...params2 };
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertSendDirection();
      const options = {
        negotiated: true,
        id: this._nextSendSctpStreamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("sendDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
      if (!this._hasDataChannelMediaSection) {
        const offer = await this._pc.createOffer();
        const localSdpObject = sdpTransform.parse(offer.sdp);
        const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        this._remoteSdp.sendSctpAssociation({ offerMediaObject });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      const sctpStreamParameters = {
        streamId: options.id,
        ordered: options.ordered,
        maxPacketLifeTime: options.maxPacketLifeTime,
        maxRetransmits: options.maxRetransmits
      };
      return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const results = [];
      const mapLocalId = /* @__PURE__ */ new Map();
      for (const options of optionsList) {
        const { trackId, kind, rtpParameters, streamId } = options;
        logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
        const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
        mapLocalId.set(trackId, localId);
        this._remoteSdp.receive({
          mid: localId,
          kind,
          offerRtpParameters: rtpParameters,
          streamId: streamId ?? rtpParameters.rtcp.cname,
          trackId
        });
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      let answer = await this._pc.createAnswer();
      const localSdpObject = sdpTransform.parse(answer.sdp);
      for (const options of optionsList) {
        const { trackId, rtpParameters } = options;
        const localId = mapLocalId.get(trackId);
        const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
        sdpCommonUtils.applyCodecParameters({
          offerRtpParameters: rtpParameters,
          answerMediaObject
        });
      }
      answer = {
        type: "answer",
        sdp: sdpTransform.write(localSdpObject)
      };
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const options of optionsList) {
        const { trackId } = options;
        const localId = mapLocalId.get(trackId);
        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
        if (!transceiver) {
          throw new Error("new RTCRtpTransceiver not found");
        } else {
          this._mapMidTransceiver.set(localId, transceiver);
          results.push({
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
          });
        }
      }
      return results;
    }
    async stopReceiving(localIds) {
      this.assertRecvDirection();
      if (this._closed) {
        return;
      }
      for (const localId of localIds) {
        logger.debug("stopReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        this._remoteSdp.closeMediaSection(transceiver.mid);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const localId of localIds) {
        this._mapMidTransceiver.delete(localId);
      }
    }
    async pauseReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("pauseReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("resumeReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "recvonly";
        this._remoteSdp.resumeReceivingMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
      const options = {
        negotiated: true,
        id: streamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("receiveDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      if (!this._hasDataChannelMediaSection) {
        this._remoteSdp.receiveSctpAssociation();
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        if (!this._transportReady) {
          const localSdpObject = sdpTransform.parse(answer.sdp);
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject }) {
      if (!localSdpObject) {
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      }
      const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
        sdpObject: localSdpObject
      });
      dtlsParameters.role = localDtlsRole;
      this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
      await new Promise((resolve, reject) => {
        this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
      });
      this._transportReady = true;
    }
    assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("method called in a closed handler");
      }
    }
    assertSendDirection() {
      if (this._direction !== "send") {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
    assertRecvDirection() {
      if (this._direction !== "recv") {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  };
  Chrome74.Chrome74 = Chrome74$1;
  return Chrome74;
}
var Firefox120 = {};
var hasRequiredFirefox120;
function requireFirefox120() {
  if (hasRequiredFirefox120) return Firefox120;
  hasRequiredFirefox120 = 1;
  "use strict";
  Object.defineProperty(Firefox120, "__esModule", { value: true });
  Firefox120.Firefox120 = void 0;
  const sdpTransform = requireLib$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const Logger_1 = requireLogger$2();
  const errors_1 = requireErrors$1();
  const ortc2 = requireOrtc();
  const scalabilityModes_1 = requireScalabilityModes();
  const sdpCommonUtils = requireCommonUtils();
  const sdpUnifiedPlanUtils = requireUnifiedPlanUtils();
  const RemoteSdp_1 = requireRemoteSdp();
  const logger = new Logger_1.Logger("Firefox120");
  const NAME = "Firefox120";
  const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
  let Firefox120$1 = class Firefox1202 extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
      super();
      // Closed flag.
      __publicField(this, "_closed", false);
      // Handler direction.
      __publicField(this, "_direction");
      // Remote SDP handler.
      __publicField(this, "_remoteSdp");
      // Callback to request sending extended RTP capabilities on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // RTCPeerConnection instance.
      __publicField(this, "_pc");
      // Map of RTCTransceivers indexed by MID.
      __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
      // Local stream for sending.
      __publicField(this, "_sendStream", new MediaStream());
      // Whether a DataChannel m=application section has been created.
      __publicField(this, "_hasDataChannelMediaSection", false);
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      __publicField(this, "_nextSendSctpStreamId", 0);
      // Got transport local and remote parameters.
      __publicField(this, "_transportReady", false);
      __publicField(this, "onIceGatheringStateChange", () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      });
      __publicField(this, "onIceCandidateError", (event) => {
        this.emit("@icecandidateerror", event);
      });
      __publicField(this, "onConnectionStateChange", () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      });
      __publicField(this, "onIceConnectionStateChange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      });
      logger.debug("constructor()");
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters
      });
      this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
      this._pc = new RTCPeerConnection({
        iceServers: iceServers ?? [],
        iceTransportPolicy: iceTransportPolicy ?? "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        ...additionalSettings
      });
      this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
      if (this._pc.connectionState) {
        this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
      } else {
        logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
        this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      }
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
      return {
        name: NAME,
        factory: (options) => new Firefox1202(options),
        getNativeRtpCapabilities: async () => {
          logger.debug("getNativeRtpCapabilities()");
          let pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          const canvas = document.createElement("canvas");
          canvas.getContext("2d");
          const fakeStream = canvas.captureStream();
          const fakeVideoTrack = fakeStream.getVideoTracks()[0];
          try {
            pc.addTransceiver("audio", { direction: "sendrecv" });
            pc.addTransceiver(fakeVideoTrack, {
              direction: "sendrecv",
              sendEncodings: [
                { rid: "r0", maxBitrate: 1e5 },
                { rid: "r1", maxBitrate: 5e5 }
              ]
            });
            const offer = await pc.createOffer();
            try {
              canvas.remove();
            } catch (error) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error) {
            }
            try {
              pc.close();
            } catch (error) {
            }
            pc = void 0;
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = Firefox1202.getLocalRtpCapabilities(sdpObject);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              canvas.remove();
            } catch (error2) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error2) {
            }
            try {
              pc == null ? void 0 : pc.close();
            } catch (error2) {
            }
            pc = void 0;
            throw error;
          }
        },
        getNativeSctpCapabilities: async () => {
          logger.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
      };
    }
    static getLocalRtpCapabilities(localSdpObject) {
      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      ortc2.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
    get name() {
      return NAME;
    }
    close() {
      logger.debug("close()");
      if (this._closed) {
        return;
      }
      this._closed = true;
      try {
        this._pc.close();
      } catch (error) {
      }
      this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
      this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
      this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      this.emit("@close");
      super.close();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
      this.assertNotClosed();
      throw new errors_1.UnsupportedError("not supported");
    }
    async restartIce(iceParameters) {
      this.assertNotClosed();
      logger.debug("restartIce()");
      this._remoteSdp.updateIceParameters(iceParameters);
      if (!this._transportReady) {
        return;
      }
      if (this._direction === "send") {
        const offer = await this._pc.createOffer({ iceRestart: true });
        logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      } else {
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
    }
    async getTransportStats() {
      this.assertNotClosed();
      return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender }) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
      if (encodings && encodings.length > 1) {
        encodings.forEach((encoding, idx) => {
          encoding.rid = `r${idx}`;
        });
      }
      const transceiver = this._pc.addTransceiver(track, {
        direction: "sendonly",
        streams: [this._sendStream],
        sendEncodings: encodings
      });
      if (onRtpSender) {
        onRtpSender(transceiver.sender);
      }
      const offer = await this._pc.createOffer();
      let localSdpObject = sdpTransform.parse(offer.sdp);
      if (localSdpObject.extmapAllowMixed) {
        this._remoteSdp.setSessionExtmapAllowMixed();
      }
      const nativeRtpCapabilities = Firefox1202.getLocalRtpCapabilities(localSdpObject);
      const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
      const sendingRtpParameters = ortc2.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRtpParameters.codecs = ortc2.reduceCodecs(sendingRtpParameters.codecs, codec);
      const sendingRemoteRtpParameters = ortc2.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRemoteRtpParameters.codecs = ortc2.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
      if (!this._transportReady) {
        await this.setupTransport({ localDtlsRole: "client", localSdpObject });
      }
      const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
      logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const localId = transceiver.mid;
      sendingRtpParameters.mid = localId;
      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
      sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
        offerMediaObject
      });
      if (!encodings) {
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
      } else if (encodings.length === 1) {
        const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
        Object.assign(newEncodings[0], encodings[0]);
        sendingRtpParameters.encodings = newEncodings;
      } else {
        sendingRtpParameters.encodings = encodings;
      }
      if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
        for (const encoding of sendingRtpParameters.encodings) {
          if (encoding.scalabilityMode) {
            encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
          } else {
            encoding.scalabilityMode = "L1T3";
          }
        }
      }
      this._remoteSdp.send({
        offerMediaObject,
        offerRtpParameters: sendingRtpParameters,
        answerRtpParameters: sendingRemoteRtpParameters,
        codecOptions
      });
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.set(localId, transceiver);
      return {
        localId,
        rtpParameters: sendingRtpParameters,
        rtpSender: transceiver.sender
      };
    }
    async stopSending(localId) {
      this.assertSendDirection();
      logger.debug("stopSending() [localId:%s]", localId);
      if (this._closed) {
        return;
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated transceiver not found");
      }
      void transceiver.sender.replaceTrack(null);
      this._pc.removeTrack(transceiver.sender);
      this._remoteSdp.disableMediaSection(transceiver.mid);
      const offer = await this._pc.createOffer();
      logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("pauseSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "inactive";
      this._remoteSdp.pauseMediaSection(localId);
      const offer = await this._pc.createOffer();
      logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("resumeSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "sendonly";
      this._remoteSdp.resumeSendingMediaSection(localId);
      const offer = await this._pc.createOffer();
      logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
      this.assertNotClosed();
      this.assertSendDirection();
      if (track) {
        logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
      } else {
        logger.debug("replaceTrack() [localId:%s, no track]", localId);
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated transceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        if (idx <= spatialLayer) {
          encoding.active = true;
        } else {
          encoding.active = false;
        }
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params2) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params2);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        parameters.encodings[idx] = { ...encoding, ...params2 };
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertSendDirection();
      const options = {
        negotiated: true,
        id: this._nextSendSctpStreamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("sendDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
      if (!this._hasDataChannelMediaSection) {
        const offer = await this._pc.createOffer();
        const localSdpObject = sdpTransform.parse(offer.sdp);
        const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
        if (!this._transportReady) {
          await this.setupTransport({ localDtlsRole: "client", localSdpObject });
        }
        logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        this._remoteSdp.sendSctpAssociation({ offerMediaObject });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      const sctpStreamParameters = {
        streamId: options.id,
        ordered: options.ordered,
        maxPacketLifeTime: options.maxPacketLifeTime,
        maxRetransmits: options.maxRetransmits
      };
      return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const results = [];
      const mapLocalId = /* @__PURE__ */ new Map();
      for (const options of optionsList) {
        const { trackId, kind, rtpParameters, streamId } = options;
        logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
        const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
        mapLocalId.set(trackId, localId);
        this._remoteSdp.receive({
          mid: localId,
          kind,
          offerRtpParameters: rtpParameters,
          streamId: streamId ?? rtpParameters.rtcp.cname,
          trackId
        });
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      for (const options of optionsList) {
        const { trackId, onRtpReceiver } = options;
        if (onRtpReceiver) {
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
          if (!transceiver) {
            throw new Error("transceiver not found");
          }
          onRtpReceiver(transceiver.receiver);
        }
      }
      let answer = await this._pc.createAnswer();
      const localSdpObject = sdpTransform.parse(answer.sdp);
      for (const options of optionsList) {
        const { trackId, rtpParameters } = options;
        const localId = mapLocalId.get(trackId);
        const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
        sdpCommonUtils.applyCodecParameters({
          offerRtpParameters: rtpParameters,
          answerMediaObject
        });
        answer = {
          type: "answer",
          sdp: sdpTransform.write(localSdpObject)
        };
      }
      if (!this._transportReady) {
        await this.setupTransport({ localDtlsRole: "client", localSdpObject });
      }
      logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const options of optionsList) {
        const { trackId } = options;
        const localId = mapLocalId.get(trackId);
        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
        if (!transceiver) {
          throw new Error("new RTCRtpTransceiver not found");
        }
        this._mapMidTransceiver.set(localId, transceiver);
        results.push({
          localId,
          track: transceiver.receiver.track,
          rtpReceiver: transceiver.receiver
        });
      }
      return results;
    }
    async stopReceiving(localIds) {
      this.assertRecvDirection();
      if (this._closed) {
        return;
      }
      for (const localId of localIds) {
        logger.debug("stopReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        this._remoteSdp.closeMediaSection(transceiver.mid);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const localId of localIds) {
        this._mapMidTransceiver.delete(localId);
      }
    }
    async pauseReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("pauseReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("resumeReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "recvonly";
        this._remoteSdp.resumeReceivingMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
      this.assertRecvDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
      const options = {
        negotiated: true,
        id: streamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("receiveDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      if (!this._hasDataChannelMediaSection) {
        this._remoteSdp.receiveSctpAssociation();
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        if (!this._transportReady) {
          const localSdpObject = sdpTransform.parse(answer.sdp);
          await this.setupTransport({ localDtlsRole: "client", localSdpObject });
        }
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject }) {
      if (!localSdpObject) {
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      }
      const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
        sdpObject: localSdpObject
      });
      dtlsParameters.role = localDtlsRole;
      this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
      await new Promise((resolve, reject) => {
        this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
      });
      this._transportReady = true;
    }
    assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("method called in a closed handler");
      }
    }
    assertSendDirection() {
      if (this._direction !== "send") {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
    assertRecvDirection() {
      if (this._direction !== "recv") {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  };
  Firefox120.Firefox120 = Firefox120$1;
  return Firefox120;
}
var Safari12 = {};
var hasRequiredSafari12;
function requireSafari12() {
  if (hasRequiredSafari12) return Safari12;
  hasRequiredSafari12 = 1;
  "use strict";
  Object.defineProperty(Safari12, "__esModule", { value: true });
  Safari12.Safari12 = void 0;
  const sdpTransform = requireLib$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const Logger_1 = requireLogger$2();
  const ortc2 = requireOrtc();
  const errors_1 = requireErrors$1();
  const scalabilityModes_1 = requireScalabilityModes();
  const RemoteSdp_1 = requireRemoteSdp();
  const sdpCommonUtils = requireCommonUtils();
  const sdpUnifiedPlanUtils = requireUnifiedPlanUtils();
  const ortcUtils = requireUtils$1();
  const logger = new Logger_1.Logger("Safari12");
  const NAME = "Safari12";
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  let Safari12$1 = class Safari122 extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
      super();
      // Closed flag.
      __publicField(this, "_closed", false);
      // Handler direction.
      __publicField(this, "_direction");
      // Remote SDP handler.
      __publicField(this, "_remoteSdp");
      // Callback to request sending extended RTP capabilities on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      __publicField(this, "_forcedLocalDtlsRole");
      // RTCPeerConnection instance.
      __publicField(this, "_pc");
      // Map of RTCTransceivers indexed by MID.
      __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
      // Local stream for sending.
      __publicField(this, "_sendStream", new MediaStream());
      // Whether a DataChannel m=application section has been created.
      __publicField(this, "_hasDataChannelMediaSection", false);
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      __publicField(this, "_nextSendSctpStreamId", 0);
      // Got transport local and remote parameters.
      __publicField(this, "_transportReady", false);
      __publicField(this, "onIceGatheringStateChange", () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      });
      __publicField(this, "onIceCandidateError", (event) => {
        this.emit("@icecandidateerror", event);
      });
      __publicField(this, "onConnectionStateChange", () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      });
      __publicField(this, "onIceConnectionStateChange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      });
      logger.debug("constructor()");
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters
      });
      this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
      if (dtlsParameters.role && dtlsParameters.role !== "auto") {
        this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
      }
      this._pc = new RTCPeerConnection({
        iceServers: iceServers ?? [],
        iceTransportPolicy: iceTransportPolicy ?? "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        ...additionalSettings
      });
      this._pc.addEventListener("icegatheringstatechange", () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      });
      this._pc.addEventListener("icecandidateerror", (event) => {
        this.emit("@icecandidateerror", event);
      });
      this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
      if (this._pc.connectionState) {
        this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
      } else {
        logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
        this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      }
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
      return {
        name: NAME,
        factory: (options) => new Safari122(options),
        getNativeRtpCapabilities: async () => {
          logger.debug("getNativeRtpCapabilities()");
          let pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            pc = void 0;
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = Safari122.getLocalRtpCapabilities(sdpObject);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc == null ? void 0 : pc.close();
            } catch (error2) {
            }
            pc = void 0;
            throw error;
          }
        },
        getNativeSctpCapabilities: async () => {
          logger.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
      };
    }
    static getLocalRtpCapabilities(localSdpObject) {
      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      ortc2.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
    get name() {
      return NAME;
    }
    close() {
      logger.debug("close()");
      if (this._closed) {
        return;
      }
      this._closed = true;
      try {
        this._pc.close();
      } catch (error) {
      }
      this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
      this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
      this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      this.emit("@close");
      super.close();
    }
    async updateIceServers(iceServers) {
      this.assertNotClosed();
      logger.debug("updateIceServers()");
      const configuration = this._pc.getConfiguration();
      configuration.iceServers = iceServers;
      this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
      this.assertNotClosed();
      logger.debug("restartIce()");
      this._remoteSdp.updateIceParameters(iceParameters);
      if (!this._transportReady) {
        return;
      }
      if (this._direction === "send") {
        const offer = await this._pc.createOffer({ iceRestart: true });
        logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      } else {
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
    }
    async getTransportStats() {
      this.assertNotClosed();
      return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender }) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
      const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
      const transceiver = this._pc.addTransceiver(track, {
        direction: "sendonly",
        streams: [this._sendStream]
      });
      if (onRtpSender) {
        onRtpSender(transceiver.sender);
      }
      let offer = await this._pc.createOffer();
      let localSdpObject = sdpTransform.parse(offer.sdp);
      if (localSdpObject.extmapAllowMixed) {
        this._remoteSdp.setSessionExtmapAllowMixed();
      }
      const nativeRtpCapabilities = Safari122.getLocalRtpCapabilities(localSdpObject);
      const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
      const sendingRtpParameters = ortc2.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRtpParameters.codecs = ortc2.reduceCodecs(sendingRtpParameters.codecs, codec);
      const sendingRemoteRtpParameters = ortc2.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRemoteRtpParameters.codecs = ortc2.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
      let offerMediaObject;
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
      if (encodings && encodings.length > 1) {
        logger.debug("send() | enabling legacy simulcast");
        localSdpObject = sdpTransform.parse(offer.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        sdpUnifiedPlanUtils.addLegacySimulcast({
          offerMediaObject,
          numStreams: encodings.length
        });
        offer = {
          type: "offer",
          sdp: sdpTransform.write(localSdpObject)
        };
      }
      logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const localId = transceiver.mid;
      sendingRtpParameters.mid = localId;
      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
      sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
        offerMediaObject
      });
      sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
        offerMediaObject
      });
      if (encodings) {
        for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
          if (encodings[idx]) {
            Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
          }
        }
      }
      if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
        for (const encoding of sendingRtpParameters.encodings) {
          if (encoding.scalabilityMode) {
            encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
          } else {
            encoding.scalabilityMode = "L1T3";
          }
        }
      }
      this._remoteSdp.send({
        offerMediaObject,
        reuseMid: mediaSectionIdx.reuseMid,
        offerRtpParameters: sendingRtpParameters,
        answerRtpParameters: sendingRemoteRtpParameters,
        codecOptions
      });
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.set(localId, transceiver);
      return {
        localId,
        rtpParameters: sendingRtpParameters,
        rtpSender: transceiver.sender
      };
    }
    async stopSending(localId) {
      this.assertSendDirection();
      if (this._closed) {
        return;
      }
      logger.debug("stopSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      void transceiver.sender.replaceTrack(null);
      this._pc.removeTrack(transceiver.sender);
      const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
      if (mediaSectionClosed) {
        try {
          transceiver.stop();
        } catch (error) {
        }
      }
      const offer = await this._pc.createOffer();
      logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("pauseSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "inactive";
      this._remoteSdp.pauseMediaSection(localId);
      const offer = await this._pc.createOffer();
      logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("resumeSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "sendonly";
      this._remoteSdp.resumeSendingMediaSection(localId);
      const offer = await this._pc.createOffer();
      logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
      this.assertNotClosed();
      this.assertSendDirection();
      if (track) {
        logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
      } else {
        logger.debug("replaceTrack() [localId:%s, no track]", localId);
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        if (idx <= spatialLayer) {
          encoding.active = true;
        } else {
          encoding.active = false;
        }
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params2) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params2);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        parameters.encodings[idx] = { ...encoding, ...params2 };
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertSendDirection();
      const options = {
        negotiated: true,
        id: this._nextSendSctpStreamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("sendDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
      if (!this._hasDataChannelMediaSection) {
        const offer = await this._pc.createOffer();
        const localSdpObject = sdpTransform.parse(offer.sdp);
        const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        this._remoteSdp.sendSctpAssociation({ offerMediaObject });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      const sctpStreamParameters = {
        streamId: options.id,
        ordered: options.ordered,
        maxPacketLifeTime: options.maxPacketLifeTime,
        maxRetransmits: options.maxRetransmits
      };
      return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const results = [];
      const mapLocalId = /* @__PURE__ */ new Map();
      for (const options of optionsList) {
        const { trackId, kind, rtpParameters, streamId } = options;
        logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
        const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
        mapLocalId.set(trackId, localId);
        this._remoteSdp.receive({
          mid: localId,
          kind,
          offerRtpParameters: rtpParameters,
          streamId: streamId ?? rtpParameters.rtcp.cname,
          trackId
        });
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      for (const options of optionsList) {
        const { trackId, onRtpReceiver } = options;
        if (onRtpReceiver) {
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
          if (!transceiver) {
            throw new Error("transceiver not found");
          }
          onRtpReceiver(transceiver.receiver);
        }
      }
      let answer = await this._pc.createAnswer();
      const localSdpObject = sdpTransform.parse(answer.sdp);
      for (const options of optionsList) {
        const { trackId, rtpParameters } = options;
        const localId = mapLocalId.get(trackId);
        const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
        sdpCommonUtils.applyCodecParameters({
          offerRtpParameters: rtpParameters,
          answerMediaObject
        });
      }
      answer = {
        type: "answer",
        sdp: sdpTransform.write(localSdpObject)
      };
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const options of optionsList) {
        const { trackId } = options;
        const localId = mapLocalId.get(trackId);
        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
        if (!transceiver) {
          throw new Error("new RTCRtpTransceiver not found");
        }
        this._mapMidTransceiver.set(localId, transceiver);
        results.push({
          localId,
          track: transceiver.receiver.track,
          rtpReceiver: transceiver.receiver
        });
      }
      return results;
    }
    async stopReceiving(localIds) {
      this.assertRecvDirection();
      if (this._closed) {
        return;
      }
      for (const localId of localIds) {
        logger.debug("stopReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        this._remoteSdp.closeMediaSection(transceiver.mid);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const localId of localIds) {
        this._mapMidTransceiver.delete(localId);
      }
    }
    async pauseReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("pauseReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("resumeReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "recvonly";
        this._remoteSdp.resumeReceivingMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
      const options = {
        negotiated: true,
        id: streamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("receiveDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      if (!this._hasDataChannelMediaSection) {
        this._remoteSdp.receiveSctpAssociation();
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        if (!this._transportReady) {
          const localSdpObject = sdpTransform.parse(answer.sdp);
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject }) {
      if (!localSdpObject) {
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      }
      const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
        sdpObject: localSdpObject
      });
      dtlsParameters.role = localDtlsRole;
      this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
      await new Promise((resolve, reject) => {
        this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
      });
      this._transportReady = true;
    }
    assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("method called in a closed handler");
      }
    }
    assertSendDirection() {
      if (this._direction !== "send") {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
    assertRecvDirection() {
      if (this._direction !== "recv") {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  };
  Safari12.Safari12 = Safari12$1;
  return Safari12;
}
var ReactNative106 = {};
var hasRequiredReactNative106;
function requireReactNative106() {
  if (hasRequiredReactNative106) return ReactNative106;
  hasRequiredReactNative106 = 1;
  "use strict";
  Object.defineProperty(ReactNative106, "__esModule", { value: true });
  ReactNative106.ReactNative106 = void 0;
  const sdpTransform = requireLib$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const Logger_1 = requireLogger$2();
  const ortc2 = requireOrtc();
  const errors_1 = requireErrors$1();
  const scalabilityModes_1 = requireScalabilityModes();
  const RemoteSdp_1 = requireRemoteSdp();
  const sdpCommonUtils = requireCommonUtils();
  const sdpUnifiedPlanUtils = requireUnifiedPlanUtils();
  const ortcUtils = requireUtils$1();
  const logger = new Logger_1.Logger("ReactNative106");
  const NAME = "ReactNative106";
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  let ReactNative106$1 = class ReactNative1062 extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
      super();
      // Closed flag.
      __publicField(this, "_closed", false);
      // Handler direction.
      __publicField(this, "_direction");
      // Remote SDP handler.
      __publicField(this, "_remoteSdp");
      // Callback to request sending extended RTP capabilities on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      __publicField(this, "_forcedLocalDtlsRole");
      // RTCPeerConnection instance.
      __publicField(this, "_pc");
      // Map of RTCTransceivers indexed by MID.
      __publicField(this, "_mapMidTransceiver", /* @__PURE__ */ new Map());
      // Local stream for sending.
      __publicField(this, "_sendStream", new MediaStream());
      // Whether a DataChannel m=application section has been created.
      __publicField(this, "_hasDataChannelMediaSection", false);
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      __publicField(this, "_nextSendSctpStreamId", 0);
      // Got transport local and remote parameters.
      __publicField(this, "_transportReady", false);
      __publicField(this, "onIceGatheringStateChange", () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      });
      __publicField(this, "onIceCandidateError", (event) => {
        this.emit("@icecandidateerror", event);
      });
      __publicField(this, "onConnectionStateChange", () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      });
      __publicField(this, "onIceConnectionStateChange", () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      });
      logger.debug("constructor()");
      this._direction = direction;
      this._remoteSdp = new RemoteSdp_1.RemoteSdp({
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters
      });
      this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
      if (dtlsParameters.role && dtlsParameters.role !== "auto") {
        this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
      }
      this._pc = new RTCPeerConnection({
        iceServers: iceServers ?? [],
        iceTransportPolicy: iceTransportPolicy ?? "all",
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
        ...additionalSettings
      });
      this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
      if (this._pc.connectionState) {
        this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
      } else {
        logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
        this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      }
    }
    /**
     * Creates a factory function.
     */
    static createFactory() {
      return {
        name: NAME,
        factory: (options) => new ReactNative1062(options),
        getNativeRtpCapabilities: async () => {
          logger.debug("getNativeRtpCapabilities()");
          let pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            pc = void 0;
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = ReactNative1062.getLocalRtpCapabilities(sdpObject);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc == null ? void 0 : pc.close();
            } catch (error2) {
            }
            pc = void 0;
            throw error;
          }
        },
        getNativeSctpCapabilities: async () => {
          logger.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
      };
    }
    static getLocalRtpCapabilities(localSdpObject) {
      const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
        sdpObject: localSdpObject
      });
      ortc2.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
    get name() {
      return NAME;
    }
    close() {
      logger.debug("close()");
      if (this._closed) {
        return;
      }
      this._closed = true;
      this._sendStream.release(
        /* releaseTracks */
        false
      );
      try {
        this._pc.close();
      } catch (error) {
      }
      this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
      this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
      this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
      this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
      this.emit("@close");
      super.close();
    }
    async updateIceServers(iceServers) {
      this.assertNotClosed();
      logger.debug("updateIceServers()");
      const configuration = this._pc.getConfiguration();
      configuration.iceServers = iceServers;
      this._pc.setConfiguration(configuration);
    }
    async restartIce(iceParameters) {
      this.assertNotClosed();
      logger.debug("restartIce()");
      this._remoteSdp.updateIceParameters(iceParameters);
      if (!this._transportReady) {
        return;
      }
      if (this._direction === "send") {
        const offer = await this._pc.createOffer({ iceRestart: true });
        logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      } else {
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
    }
    async getTransportStats() {
      this.assertNotClosed();
      return this._pc.getStats();
    }
    async send({ track, encodings, codecOptions, codec, onRtpSender }) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
      if (encodings && encodings.length > 1) {
        encodings.forEach((encoding, idx) => {
          encoding.rid = `r${idx}`;
        });
      }
      const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
      const transceiver = this._pc.addTransceiver(track, {
        direction: "sendonly",
        streams: [this._sendStream],
        sendEncodings: encodings
      });
      if (onRtpSender) {
        onRtpSender(transceiver.sender);
      }
      let offer = await this._pc.createOffer();
      let localSdpObject = sdpTransform.parse(offer.sdp);
      if (localSdpObject.extmapAllowMixed) {
        this._remoteSdp.setSessionExtmapAllowMixed();
      }
      const nativeRtpCapabilities = ReactNative1062.getLocalRtpCapabilities(localSdpObject);
      const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
      const sendingRtpParameters = ortc2.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRtpParameters.codecs = ortc2.reduceCodecs(sendingRtpParameters.codecs, codec);
      const sendingRemoteRtpParameters = ortc2.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRemoteRtpParameters.codecs = ortc2.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      let hackVp9Svc = false;
      const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
      let offerMediaObject;
      if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
        logger.debug("send() | enabling legacy simulcast for VP9 SVC");
        hackVp9Svc = true;
        localSdpObject = sdpTransform.parse(offer.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        sdpUnifiedPlanUtils.addLegacySimulcast({
          offerMediaObject,
          numStreams: layers.spatialLayers
        });
        offer = {
          type: "offer",
          sdp: sdpTransform.write(localSdpObject)
        };
      }
      logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      let localId = transceiver.mid ?? void 0;
      if (!localId) {
        logger.warn("send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround");
      }
      sendingRtpParameters.mid = localId;
      localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
      sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
        offerMediaObject
      });
      if (!encodings) {
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
      } else if (encodings.length === 1) {
        let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject
        });
        Object.assign(newEncodings[0], encodings[0]);
        if (hackVp9Svc) {
          newEncodings = [newEncodings[0]];
        }
        sendingRtpParameters.encodings = newEncodings;
      } else {
        sendingRtpParameters.encodings = encodings;
      }
      if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
        for (const encoding of sendingRtpParameters.encodings) {
          if (encoding.scalabilityMode) {
            encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
          } else {
            encoding.scalabilityMode = "L1T3";
          }
        }
      }
      this._remoteSdp.send({
        offerMediaObject,
        reuseMid: mediaSectionIdx.reuseMid,
        offerRtpParameters: sendingRtpParameters,
        answerRtpParameters: sendingRemoteRtpParameters,
        codecOptions
      });
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      if (!localId) {
        localId = transceiver.mid;
        sendingRtpParameters.mid = localId;
      }
      this._mapMidTransceiver.set(localId, transceiver);
      return {
        localId,
        rtpParameters: sendingRtpParameters,
        rtpSender: transceiver.sender
      };
    }
    async stopSending(localId) {
      this.assertSendDirection();
      if (this._closed) {
        return;
      }
      logger.debug("stopSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      void transceiver.sender.replaceTrack(null);
      this._pc.removeTrack(transceiver.sender);
      const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
      if (mediaSectionClosed) {
        try {
          transceiver.stop();
        } catch (error) {
        }
      }
      const offer = await this._pc.createOffer();
      logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
      this._mapMidTransceiver.delete(localId);
    }
    async pauseSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("pauseSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "inactive";
      this._remoteSdp.pauseMediaSection(localId);
      const offer = await this._pc.createOffer();
      logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async resumeSending(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("resumeSending() [localId:%s]", localId);
      const transceiver = this._mapMidTransceiver.get(localId);
      this._remoteSdp.resumeSendingMediaSection(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      transceiver.direction = "sendonly";
      const offer = await this._pc.createOffer();
      logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async replaceTrack(localId, track) {
      this.assertNotClosed();
      this.assertSendDirection();
      if (track) {
        logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
      } else {
        logger.debug("replaceTrack() [localId:%s, no track]", localId);
      }
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      await transceiver.sender.replaceTrack(track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        if (idx <= spatialLayer) {
          encoding.active = true;
        } else {
          encoding.active = false;
        }
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async setRtpEncodingParameters(localId, params2) {
      this.assertNotClosed();
      this.assertSendDirection();
      logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params2);
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      const parameters = transceiver.sender.getParameters();
      parameters.encodings.forEach((encoding, idx) => {
        parameters.encodings[idx] = { ...encoding, ...params2 };
      });
      await transceiver.sender.setParameters(parameters);
      this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
      const offer = await this._pc.createOffer();
      logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
      await this._pc.setLocalDescription(offer);
      const answer = {
        type: "answer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
      await this._pc.setRemoteDescription(answer);
    }
    async getSenderStats(localId) {
      this.assertNotClosed();
      this.assertSendDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.sender.getStats();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertSendDirection();
      const options = {
        negotiated: true,
        id: this._nextSendSctpStreamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("sendDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
      if (!this._hasDataChannelMediaSection) {
        const offer = await this._pc.createOffer();
        const localSdpObject = sdpTransform.parse(offer.sdp);
        const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        this._remoteSdp.sendSctpAssociation({ offerMediaObject });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      const sctpStreamParameters = {
        streamId: options.id,
        ordered: options.ordered,
        maxPacketLifeTime: options.maxPacketLifeTime,
        maxRetransmits: options.maxRetransmits
      };
      return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const results = [];
      const mapLocalId = /* @__PURE__ */ new Map();
      for (const options of optionsList) {
        const { trackId, kind, rtpParameters, streamId } = options;
        logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
        const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
        mapLocalId.set(trackId, localId);
        this._remoteSdp.receive({
          mid: localId,
          kind,
          offerRtpParameters: rtpParameters,
          streamId: streamId ?? rtpParameters.rtcp.cname,
          trackId
        });
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      for (const options of optionsList) {
        const { trackId, onRtpReceiver } = options;
        if (onRtpReceiver) {
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
          if (!transceiver) {
            throw new Error("transceiver not found");
          }
          onRtpReceiver(transceiver.receiver);
        }
      }
      let answer = await this._pc.createAnswer();
      const localSdpObject = sdpTransform.parse(answer.sdp);
      for (const options of optionsList) {
        const { trackId, rtpParameters } = options;
        const localId = mapLocalId.get(trackId);
        const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
        sdpCommonUtils.applyCodecParameters({
          offerRtpParameters: rtpParameters,
          answerMediaObject
        });
      }
      answer = {
        type: "answer",
        sdp: sdpTransform.write(localSdpObject)
      };
      if (!this._transportReady) {
        await this.setupTransport({
          localDtlsRole: this._forcedLocalDtlsRole ?? "client",
          localSdpObject
        });
      }
      logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const options of optionsList) {
        const { trackId } = options;
        const localId = mapLocalId.get(trackId);
        const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
        if (!transceiver) {
          throw new Error("new RTCRtpTransceiver not found");
        } else {
          this._mapMidTransceiver.set(localId, transceiver);
          results.push({
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
          });
        }
      }
      return results;
    }
    async stopReceiving(localIds) {
      this.assertRecvDirection();
      if (this._closed) {
        return;
      }
      for (const localId of localIds) {
        logger.debug("stopReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        this._remoteSdp.closeMediaSection(transceiver.mid);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
      for (const localId of localIds) {
        this._mapMidTransceiver.delete(localId);
      }
    }
    async pauseReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("pauseReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async resumeReceiving(localIds) {
      this.assertNotClosed();
      this.assertRecvDirection();
      for (const localId of localIds) {
        logger.debug("resumeReceiving() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "recvonly";
        this._remoteSdp.resumeReceivingMediaSection(localId);
      }
      const offer = {
        type: "offer",
        sdp: this._remoteSdp.getSdp()
      };
      logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
      await this._pc.setRemoteDescription(offer);
      const answer = await this._pc.createAnswer();
      logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
      await this._pc.setLocalDescription(answer);
    }
    async getReceiverStats(localId) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const transceiver = this._mapMidTransceiver.get(localId);
      if (!transceiver) {
        throw new Error("associated RTCRtpTransceiver not found");
      }
      return transceiver.receiver.getStats();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol: protocol2 }) {
      this.assertNotClosed();
      this.assertRecvDirection();
      const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
      const options = {
        negotiated: true,
        id: streamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        protocol: protocol2
      };
      logger.debug("receiveDataChannel() [options:%o]", options);
      const dataChannel = this._pc.createDataChannel(label, options);
      if (!this._hasDataChannelMediaSection) {
        this._remoteSdp.receiveSctpAssociation();
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        if (!this._transportReady) {
          const localSdpObject = sdpTransform.parse(answer.sdp);
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        this._hasDataChannelMediaSection = true;
      }
      return { dataChannel };
    }
    async setupTransport({ localDtlsRole, localSdpObject }) {
      if (!localSdpObject) {
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
      }
      const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
        sdpObject: localSdpObject
      });
      dtlsParameters.role = localDtlsRole;
      this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
      await new Promise((resolve, reject) => {
        this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
      });
      this._transportReady = true;
    }
    assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("method called in a closed handler");
      }
    }
    assertSendDirection() {
      if (this._direction !== "send") {
        throw new Error('method can just be called for handlers with "send" direction');
      }
    }
    assertRecvDirection() {
      if (this._direction !== "recv") {
        throw new Error('method can just be called for handlers with "recv" direction');
      }
    }
  };
  ReactNative106.ReactNative106 = ReactNative106$1;
  return ReactNative106;
}
var hasRequiredDevice;
function requireDevice() {
  if (hasRequiredDevice) return Device;
  hasRequiredDevice = 1;
  "use strict";
  Object.defineProperty(Device, "__esModule", { value: true });
  Device.Device = void 0;
  Device.detectDevice = detectDevice;
  Device.detectDeviceAsync = detectDeviceAsync;
  const Logger_1 = requireLogger$2();
  const enhancedEvents_1 = requireEnhancedEvents();
  const errors_1 = requireErrors$1();
  const utils2 = requireUtils$2();
  const ortc2 = requireOrtc();
  const Transport_1 = requireTransport();
  const Chrome111_1 = requireChrome111();
  const Chrome74_1 = requireChrome74();
  const Firefox120_1 = requireFirefox120();
  const Safari12_1 = requireSafari12();
  const ReactNative106_1 = requireReactNative106();
  const logger = new Logger_1.Logger("Device");
  function detectDevice(userAgent, userAgentData) {
    logger.debug("detectDevice()");
    if (!userAgent && typeof navigator === "object") {
      userAgent = navigator.userAgent;
    }
    if (!userAgentData && typeof navigator === "object") {
      userAgentData = navigator.userAgentData;
    }
    return detectDeviceImpl(userAgent, userAgentData);
  }
  async function detectDeviceAsync(userAgent, userAgentData) {
    logger.debug("detectDeviceAsync()");
    if (!userAgent && typeof navigator === "object") {
      userAgent = navigator.userAgent;
    }
    if (!userAgentData && typeof navigator === "object") {
      userAgentData = navigator.userAgentData;
    }
    return detectDeviceImpl(userAgent, userAgentData);
  }
  let Device$1 = class Device2 {
    /**
     * Create a new Device to connect to mediasoup server.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    constructor({ handlerName, handlerFactory } = {}) {
      // RTC handler factory.
      __publicField(this, "_handlerFactory");
      // Handler name.
      __publicField(this, "_handlerName");
      // Loaded flag.
      __publicField(this, "_loaded", false);
      // Callback for sending Transports to request sending extended RTP capabilities
      // on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // Local RTP capabilities for receiving media.
      __publicField(this, "_recvRtpCapabilities");
      // Whether we can produce audio/video based on remote RTP capabilities.
      __publicField(this, "_canProduceByKind", {
        audio: false,
        video: false
      });
      // Local SCTP capabilities.
      __publicField(this, "_sctpCapabilities");
      // Observer instance.
      __publicField(this, "_observer", new enhancedEvents_1.EnhancedEventEmitter());
      logger.debug("constructor()");
      if (handlerName && handlerFactory) {
        throw new TypeError("just one of handlerName or handlerInterface can be given");
      }
      if (handlerFactory) {
        this._handlerFactory = handlerFactory;
      } else {
        if (handlerName) {
          logger.debug("constructor() | handler given: %s", handlerName);
        } else {
          handlerName = detectDevice();
          if (handlerName) {
            logger.debug("constructor() | detected handler: %s", handlerName);
          } else {
            throw new errors_1.UnsupportedError("device not supported");
          }
        }
        switch (handlerName) {
          case "Chrome111": {
            this._handlerFactory = Chrome111_1.Chrome111.createFactory();
            break;
          }
          case "Chrome74": {
            this._handlerFactory = Chrome74_1.Chrome74.createFactory();
            break;
          }
          case "Firefox120": {
            this._handlerFactory = Firefox120_1.Firefox120.createFactory();
            break;
          }
          case "Safari12": {
            this._handlerFactory = Safari12_1.Safari12.createFactory();
            break;
          }
          case "ReactNative106": {
            this._handlerFactory = ReactNative106_1.ReactNative106.createFactory();
            break;
          }
          default: {
            throw new TypeError(`unknown handlerName "${handlerName}"`);
          }
        }
      }
      this._handlerName = this._handlerFactory.name;
    }
    /**
     * Create a new Device to connect to mediasoup server. It uses a more advanced
     * device detection.
     *
     * @throws {UnsupportedError} if device is not supported.
     */
    static async factory({ handlerName, handlerFactory } = {}) {
      logger.debug("factory()");
      if (handlerName && handlerFactory) {
        throw new TypeError("just one of handlerName or handlerInterface can be given");
      }
      if (!handlerName && !handlerFactory) {
        handlerName = await detectDeviceAsync();
        if (!handlerName) {
          throw new errors_1.UnsupportedError("device not supported");
        }
      }
      return new Device2({ handlerName, handlerFactory });
    }
    /**
     * The RTC handler name.
     */
    get handlerName() {
      return this._handlerName;
    }
    /**
     * Whether the Device is loaded.
     */
    get loaded() {
      return this._loaded;
    }
    /**
     * RTP capabilities of the Device for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get rtpCapabilities() {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError("not loaded");
      }
      return this._recvRtpCapabilities;
    }
    /**
     * SCTP capabilities of the Device.
     *
     * @throws {InvalidStateError} if not loaded.
     */
    get sctpCapabilities() {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError("not loaded");
      }
      return this._sctpCapabilities;
    }
    get observer() {
      return this._observer;
    }
    /**
     * Initialize the Device.
     */
    async load({ routerRtpCapabilities, preferLocalCodecsOrder = false }) {
      logger.debug("load() [routerRtpCapabilities:%o]", routerRtpCapabilities);
      if (this._loaded) {
        throw new errors_1.InvalidStateError("already loaded");
      }
      const clonedRouterRtpCapabilities = utils2.clone(routerRtpCapabilities);
      ortc2.validateAndNormalizeRtpCapabilities(clonedRouterRtpCapabilities);
      const { getNativeRtpCapabilities, getNativeSctpCapabilities } = this._handlerFactory;
      const clonedNativeRtpCapabilities = utils2.clone(await getNativeRtpCapabilities());
      ortc2.validateAndNormalizeRtpCapabilities(clonedNativeRtpCapabilities);
      logger.debug("load() | got native RTP capabilities:%o", clonedNativeRtpCapabilities);
      this._getSendExtendedRtpCapabilities = (nativeRtpCapabilities) => {
        return utils2.clone(ortc2.getExtendedRtpCapabilities(nativeRtpCapabilities, clonedRouterRtpCapabilities, preferLocalCodecsOrder));
      };
      const recvExtendedRtpCapabilities = ortc2.getExtendedRtpCapabilities(
        clonedNativeRtpCapabilities,
        clonedRouterRtpCapabilities,
        /* preferLocalCodecsOrder */
        false
      );
      this._recvRtpCapabilities = ortc2.getRecvRtpCapabilities(recvExtendedRtpCapabilities);
      ortc2.validateAndNormalizeRtpCapabilities(this._recvRtpCapabilities);
      logger.debug("load() | got receiving RTP capabilities:%o", this._recvRtpCapabilities);
      this._canProduceByKind.audio = ortc2.canSend("audio", this._recvRtpCapabilities);
      this._canProduceByKind.video = ortc2.canSend("video", this._recvRtpCapabilities);
      this._sctpCapabilities = await getNativeSctpCapabilities();
      ortc2.validateSctpCapabilities(this._sctpCapabilities);
      logger.debug("load() | got native SCTP capabilities:%o", this._sctpCapabilities);
      logger.debug("load() succeeded");
      this._loaded = true;
    }
    /**
     * Whether we can produce audio/video.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    canProduce(kind) {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError("not loaded");
      } else if (kind !== "audio" && kind !== "video") {
        throw new TypeError(`invalid kind "${kind}"`);
      }
      return this._canProduceByKind[kind];
    }
    /**
     * Creates a Transport for sending media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
      logger.debug("createSendTransport()");
      return this.createTransport({
        direction: "send",
        id,
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters,
        iceServers,
        iceTransportPolicy,
        additionalSettings,
        appData
      });
    }
    /**
     * Creates a Transport for receiving media.
     *
     * @throws {InvalidStateError} if not loaded.
     * @throws {TypeError} if wrong arguments.
     */
    createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
      logger.debug("createRecvTransport()");
      return this.createTransport({
        direction: "recv",
        id,
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters,
        iceServers,
        iceTransportPolicy,
        additionalSettings,
        appData
      });
    }
    createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
      if (!this._loaded) {
        throw new errors_1.InvalidStateError("not loaded");
      } else if (typeof id !== "string") {
        throw new TypeError("missing id");
      } else if (typeof iceParameters !== "object") {
        throw new TypeError("missing iceParameters");
      } else if (!Array.isArray(iceCandidates)) {
        throw new TypeError("missing iceCandidates");
      } else if (typeof dtlsParameters !== "object") {
        throw new TypeError("missing dtlsParameters");
      } else if (sctpParameters && typeof sctpParameters !== "object") {
        throw new TypeError("wrong sctpParameters");
      } else if (appData && typeof appData !== "object") {
        throw new TypeError("if given, appData must be an object");
      }
      const transport = new Transport_1.Transport({
        direction,
        id,
        iceParameters,
        iceCandidates,
        dtlsParameters,
        sctpParameters,
        iceServers,
        iceTransportPolicy,
        additionalSettings,
        appData,
        handlerFactory: this._handlerFactory,
        getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities,
        recvRtpCapabilities: this._recvRtpCapabilities,
        canProduceByKind: this._canProduceByKind
      });
      this._observer.safeEmit("newtransport", transport);
      return transport;
    }
  };
  Device.Device = Device$1;
  function detectDeviceImpl(userAgent, userAgentData) {
    logger.debug('detectDeviceImpl() [userAgent:"%s", userAgentData:%o]', userAgent, userAgentData);
    const chromiumMajorVersion = getChromiumMajorVersion(userAgent, userAgentData);
    if (chromiumMajorVersion) {
      if (chromiumMajorVersion >= 111) {
        logger.debug("detectDeviceImpl() | using Chrome111 handler");
        return "Chrome111";
      } else if (chromiumMajorVersion >= 74) {
        logger.debug("detectDeviceImpl() | using Chrome74 handler");
        return "Chrome74";
      } else {
        logger.warn("detectDeviceImpl() | unsupported Chromium based browser/version");
        return void 0;
      }
    }
    const firefoxMajorVersion = getFirefoxMajorVersion(userAgent);
    if (firefoxMajorVersion) {
      if (firefoxMajorVersion >= 120) {
        logger.debug("detectDeviceImpl() | using Firefox120 handler");
        return "Firefox120";
      } else {
        logger.warn("detectDeviceImpl() | unsupported Firefox browser/version");
        return void 0;
      }
    }
    const macOSWebKitMajorVersion = getMacOSWebKitMajorVersion(userAgent);
    if (macOSWebKitMajorVersion) {
      if (macOSWebKitMajorVersion >= 605) {
        logger.debug("detectDeviceImpl() | using Safari12 handler");
        return "Safari12";
      } else {
        logger.warn("detectDeviceImpl() | unsupported desktop Safari browser/version");
        return void 0;
      }
    }
    const iOSWebKitMajorVersion = getIOSWebKitMajorVersion(userAgent);
    if (iOSWebKitMajorVersion) {
      if (iOSWebKitMajorVersion >= 605) {
        logger.debug("detectDeviceImpl() | using Safari12 handler");
        return "Safari12";
      } else {
        logger.warn("detectDeviceImpl() | unsupported iOS Safari based browser/version");
        return void 0;
      }
    }
    if (isReactNative2()) {
      if (typeof RTCPeerConnection !== "undefined" && typeof RTCRtpTransceiver !== "undefined") {
        logger.debug("detectDeviceImpl() | using ReactNative106 handler");
        return "ReactNative106";
      } else {
        logger.warn("detectDeviceImpl() | unsupported react-native-webrtc version without RTCPeerConnection or RTCRtpTransceiver, forgot to call registerGlobals() on it?");
        return void 0;
      }
    }
    logger.warn('detectDeviceImpl() | device not supported [userAgent:"%s", userAgentData:%o]', userAgent, userAgentData);
    return void 0;
  }
  function getChromiumMajorVersion(userAgent, userAgentData) {
    if (isIOS(userAgent, userAgentData)) {
      logger.debug("getChromiumMajorVersion() | this is iOS => undefined");
      return void 0;
    }
    if (isReactNative2()) {
      logger.debug("getChromiumMajorVersion() | this is React-Native => undefined");
      return void 0;
    }
    if (userAgentData) {
      const chromiumBrand = userAgentData.brands.find((b) => b.brand === "Chromium");
      if (chromiumBrand) {
        const majorVersion = Number(chromiumBrand.version);
        logger.debug(`getChromiumMajorVersion() | Chromium major version based on NavigatorUAData => ${majorVersion}`);
        return majorVersion;
      }
    }
    const match = userAgent == null ? void 0 : userAgent.match(/\b(?:Chrome|Chromium)\/(\w+)/i);
    if (match == null ? void 0 : match[1]) {
      const majorVersion = Number(match[1]);
      logger.debug(`getChromiumMajorVersion() | Chromium major version based on User-Agent => ${majorVersion}`);
      return majorVersion;
    }
    logger.debug("getChromiumMajorVersion() | this is not Chromium => undefined");
    return void 0;
  }
  function getFirefoxMajorVersion(userAgent) {
    if (isIOS(userAgent)) {
      logger.debug("getFirefoxMajorVersion() | this is iOS => undefined");
      return void 0;
    }
    if (isReactNative2()) {
      logger.debug("getFirefoxMajorVersion() | this is React-Native => undefined");
      return void 0;
    }
    const match = userAgent == null ? void 0 : userAgent.match(/\bFirefox\/(\w+)/i);
    if (match == null ? void 0 : match[1]) {
      const majorVersion = Number(match[1]);
      logger.debug(`getFirefoxMajorVersion() | Firefox major version based on User-Agent => ${majorVersion}`);
      return majorVersion;
    }
    logger.debug("getFirefoxMajorVersion() | this is not Firefox => undefined");
    return void 0;
  }
  function getMacOSWebKitMajorVersion(userAgent) {
    if (isIOS(userAgent)) {
      logger.debug("getMacOSWebKitMajorVersion() | this is iOS => undefined");
      return void 0;
    }
    if (isReactNative2()) {
      logger.debug("getMacOSWebKitMajorVersion() | this is React-Native => undefined");
      return void 0;
    }
    const isSafari = userAgent && /\bSafari\b/i.test(userAgent) && !/\bChrome\b/i.test(userAgent) && !/\bChromium\b/i.test(userAgent) && !/\bFirefox\b/i.test(userAgent);
    if (!isSafari) {
      logger.debug("getMacOSWebKitMajorVersion() | this is not Safari => undefined");
      return void 0;
    }
    const match = userAgent.match(/AppleWebKit\/(\w+)/i);
    if (match == null ? void 0 : match[1]) {
      const majorVersion = Number(match[1]);
      logger.debug(`getMacOSWebKitMajorVersion() | WebKit major version based on User-Agent => ${majorVersion}`);
      return majorVersion;
    }
    logger.debug("getMacOSWebKitMajorVersion() | this is not WebKit => undefined");
    return void 0;
  }
  function getIOSWebKitMajorVersion(userAgent) {
    if (!isIOS(userAgent)) {
      logger.debug("getIOSWebKitMajorVersion() | this is not iOS => undefined");
      return void 0;
    }
    if (isReactNative2()) {
      logger.debug("getIOSWebKitMajorVersion() | this is React-Native => undefined");
      return void 0;
    }
    const match = userAgent == null ? void 0 : userAgent.match(/AppleWebKit\/(\w+)/i);
    if (match == null ? void 0 : match[1]) {
      const majorVersion = Number(match[1]);
      logger.debug(`getIOSWebKitMajorVersion() | WebKit major version based on User-Agent => ${majorVersion}`);
      return majorVersion;
    }
    logger.debug("getIOSWebKitMajorVersion() | this is not WebKit => undefined");
    return void 0;
  }
  function isIOS(userAgent, userAgentData) {
    if ((userAgentData == null ? void 0 : userAgentData.platform) === "iOS") {
      logger.debug("isIOS() | this is iOS based on NavigatorUAData.platform => true");
      return true;
    }
    if (userAgentData == null ? void 0 : userAgentData.platform) {
      logger.debug("isIOS() | this is not iOS based on NavigatorUAData.platform => false");
      return false;
    }
    if (userAgent && /iPad|iPhone|iPod/.test(userAgent)) {
      logger.debug("isIOS() | this is iOS based on User-Agent => true");
      return true;
    }
    if (typeof navigator === "object" && navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) {
      logger.debug("isIOS() | this is iPadOS 13+ based on User-Agent => true");
      return true;
    }
    logger.debug("isIOS() | this is not iOS => false");
    return false;
  }
  function isReactNative2() {
    if (typeof navigator === "object" && navigator.product === "ReactNative") {
      logger.debug("isReactNative() | this is React-Native based on navigator.product");
      return true;
    }
    logger.debug("isReactNative() | this is not React-Native => false");
    return false;
  }
  return Device;
}
var FakeHandler = {};
var lib = {};
var cjsBrowser = {};
var max = {};
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  "use strict";
  Object.defineProperty(max, "__esModule", { value: true });
  max.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  return max;
}
var nil = {};
var hasRequiredNil;
function requireNil() {
  if (hasRequiredNil) return nil;
  hasRequiredNil = 1;
  "use strict";
  Object.defineProperty(nil, "__esModule", { value: true });
  nil.default = "00000000-0000-0000-0000-000000000000";
  return nil;
}
var parse = {};
var validate = {};
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  "use strict";
  Object.defineProperty(regex, "__esModule", { value: true });
  regex.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  return regex;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  "use strict";
  Object.defineProperty(validate, "__esModule", { value: true });
  const regex_js_1 = requireRegex();
  function validate$1(uuid) {
    return typeof uuid === "string" && regex_js_1.default.test(uuid);
  }
  validate.default = validate$1;
  return validate;
}
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  "use strict";
  Object.defineProperty(parse, "__esModule", { value: true });
  const validate_js_1 = requireValidate();
  function parse$12(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, v >>> 16 & 255, v >>> 8 & 255, v & 255, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 255, (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255, v / 4294967296 & 255, v >>> 24 & 255, v >>> 16 & 255, v >>> 8 & 255, v & 255);
  }
  parse.default = parse$12;
  return parse;
}
var stringify = {};
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  "use strict";
  Object.defineProperty(stringify, "__esModule", { value: true });
  stringify.unsafeStringify = void 0;
  const validate_js_1 = requireValidate();
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  stringify.unsafeStringify = unsafeStringify;
  function stringify$1(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, validate_js_1.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  stringify.default = stringify$1;
  return stringify;
}
var v1 = {};
var rng = {};
var hasRequiredRng;
function requireRng() {
  if (hasRequiredRng) return rng;
  hasRequiredRng = 1;
  "use strict";
  Object.defineProperty(rng, "__esModule", { value: true });
  let getRandomValues;
  const rnds8 = new Uint8Array(16);
  function rng$1() {
    if (!getRandomValues) {
      if (typeof crypto === "undefined" || !crypto.getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
      getRandomValues = crypto.getRandomValues.bind(crypto);
    }
    return getRandomValues(rnds8);
  }
  rng.default = rng$1;
  return rng;
}
var hasRequiredV1;
function requireV1() {
  if (hasRequiredV1) return v1;
  hasRequiredV1 = 1;
  "use strict";
  Object.defineProperty(v1, "__esModule", { value: true });
  v1.updateV1State = void 0;
  const rng_js_1 = requireRng();
  const stringify_js_1 = requireStringify();
  const _state = {};
  function v1$1(options, buf, offset) {
    var _a;
    let bytes;
    const isV6 = (options == null ? void 0 : options._v6) ?? false;
    if (options) {
      const optionsKeys = Object.keys(options);
      if (optionsKeys.length === 1 && optionsKeys[0] === "_v6") {
        options = void 0;
      }
    }
    if (options) {
      bytes = v1Bytes(options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? (0, rng_js_1.default)(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);
    } else {
      const now = Date.now();
      const rnds = (0, rng_js_1.default)();
      updateV1State(_state, now, rnds);
      bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? void 0 : _state.clockseq, isV6 ? void 0 : _state.node, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
  }
  function updateV1State(state, now, rnds) {
    state.msecs ?? (state.msecs = -Infinity);
    state.nsecs ?? (state.nsecs = 0);
    if (now === state.msecs) {
      state.nsecs++;
      if (state.nsecs >= 1e4) {
        state.node = void 0;
        state.nsecs = 0;
      }
    } else if (now > state.msecs) {
      state.nsecs = 0;
    } else if (now < state.msecs) {
      state.node = void 0;
    }
    if (!state.node) {
      state.node = rnds.slice(10, 16);
      state.node[0] |= 1;
      state.clockseq = (rnds[8] << 8 | rnds[9]) & 16383;
    }
    state.msecs = now;
    return state;
  }
  v1.updateV1State = updateV1State;
  function v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    if (!buf) {
      buf = new Uint8Array(16);
      offset = 0;
    } else {
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
    }
    msecs ?? (msecs = Date.now());
    nsecs ?? (nsecs = 0);
    clockseq ?? (clockseq = (rnds[8] << 8 | rnds[9]) & 16383);
    node ?? (node = rnds.slice(10, 16));
    msecs += 122192928e5;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    buf[offset++] = tl >>> 24 & 255;
    buf[offset++] = tl >>> 16 & 255;
    buf[offset++] = tl >>> 8 & 255;
    buf[offset++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    buf[offset++] = tmh >>> 8 & 255;
    buf[offset++] = tmh & 255;
    buf[offset++] = tmh >>> 24 & 15 | 16;
    buf[offset++] = tmh >>> 16 & 255;
    buf[offset++] = clockseq >>> 8 | 128;
    buf[offset++] = clockseq & 255;
    for (let n = 0; n < 6; ++n) {
      buf[offset++] = node[n];
    }
    return buf;
  }
  v1.default = v1$1;
  return v1;
}
var v1ToV6 = {};
var hasRequiredV1ToV6;
function requireV1ToV6() {
  if (hasRequiredV1ToV6) return v1ToV6;
  hasRequiredV1ToV6 = 1;
  "use strict";
  Object.defineProperty(v1ToV6, "__esModule", { value: true });
  const parse_js_1 = requireParse();
  const stringify_js_1 = requireStringify();
  function v1ToV6$1(uuid) {
    const v1Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v6Bytes) : v6Bytes;
  }
  v1ToV6.default = v1ToV6$1;
  function _v1ToV6(v1Bytes) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  }
  return v1ToV6;
}
var v3 = {};
var md5 = {};
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  "use strict";
  Object.defineProperty(md5, "__esModule", { value: true });
  function md5$1(bytes) {
    const words = uint8ToUint32(bytes);
    const md5Bytes = wordsToMd5(words, bytes.length * 8);
    return uint32ToUint8(md5Bytes);
  }
  function uint32ToUint8(input) {
    const bytes = new Uint8Array(input.length * 4);
    for (let i = 0; i < input.length * 4; i++) {
      bytes[i] = input[i >> 2] >>> i % 4 * 8 & 255;
    }
    return bytes;
  }
  function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
  }
  function wordsToMd5(x, len) {
    const xpad = new Uint32Array(getOutputLength(len)).fill(0);
    xpad.set(x);
    xpad[len >> 5] |= 128 << len % 32;
    xpad[xpad.length - 1] = len;
    x = xpad;
    let a = 1732584193;
    let b = -271733879;
    let c = -1732584194;
    let d = 271733878;
    for (let i = 0; i < x.length; i += 16) {
      const olda = a;
      const oldb = b;
      const oldc = c;
      const oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }
    return Uint32Array.of(a, b, c, d);
  }
  function uint8ToUint32(input) {
    if (input.length === 0) {
      return new Uint32Array();
    }
    const output = new Uint32Array(getOutputLength(input.length * 8)).fill(0);
    for (let i = 0; i < input.length; i++) {
      output[i >> 2] |= (input[i] & 255) << i % 4 * 8;
    }
    return output;
  }
  function safeAdd(x, y) {
    const lsw = (x & 65535) + (y & 65535);
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }
  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }
  md5.default = md5$1;
  return md5;
}
var v35 = {};
var hasRequiredV35;
function requireV35() {
  if (hasRequiredV35) return v35;
  hasRequiredV35 = 1;
  "use strict";
  Object.defineProperty(v35, "__esModule", { value: true });
  v35.URL = v35.DNS = v35.stringToBytes = void 0;
  const parse_js_1 = requireParse();
  const stringify_js_1 = requireStringify();
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; ++i) {
      bytes[i] = str.charCodeAt(i);
    }
    return bytes;
  }
  v35.stringToBytes = stringToBytes;
  v35.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  v35.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35$1(version2, hash, value2, namespace, buf, offset) {
    const valueBytes = typeof value2 === "string" ? stringToBytes(value2) : value2;
    const namespaceBytes = typeof namespace === "string" ? (0, parse_js_1.default)(namespace) : namespace;
    if (typeof namespace === "string") {
      namespace = (0, parse_js_1.default)(namespace);
    }
    if ((namespace == null ? void 0 : namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + valueBytes.length);
    bytes.set(namespaceBytes);
    bytes.set(valueBytes, namespaceBytes.length);
    bytes = hash(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
  }
  v35.default = v35$1;
  return v35;
}
var hasRequiredV3;
function requireV3() {
  if (hasRequiredV3) return v3;
  hasRequiredV3 = 1;
  (function(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    const md5_js_1 = requireMd5();
    const v35_js_1 = requireV35();
    var v35_js_2 = requireV35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v32(value2, namespace, buf, offset) {
      return (0, v35_js_1.default)(48, md5_js_1.default, value2, namespace, buf, offset);
    }
    v32.DNS = v35_js_1.DNS;
    v32.URL = v35_js_1.URL;
    exports.default = v32;
  })(v3);
  return v3;
}
var v4 = {};
var native = {};
var hasRequiredNative;
function requireNative() {
  if (hasRequiredNative) return native;
  hasRequiredNative = 1;
  "use strict";
  Object.defineProperty(native, "__esModule", { value: true });
  const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  native.default = { randomUUID };
  return native;
}
var hasRequiredV4;
function requireV4() {
  if (hasRequiredV4) return v4;
  hasRequiredV4 = 1;
  "use strict";
  Object.defineProperty(v4, "__esModule", { value: true });
  const native_js_1 = requireNative();
  const rng_js_1 = requireRng();
  const stringify_js_1 = requireStringify();
  function v4$1(options, buf, offset) {
    var _a;
    if (native_js_1.default.randomUUID && !buf && !options) {
      return native_js_1.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? (0, rng_js_1.default)();
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(rnds);
  }
  v4.default = v4$1;
  return v4;
}
var v5 = {};
var sha1 = {};
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  "use strict";
  Object.defineProperty(sha1, "__esModule", { value: true });
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;
      case 1:
        return x ^ y ^ z;
      case 2:
        return x & y ^ x & z ^ y & z;
      case 3:
        return x ^ y ^ z;
    }
  }
  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }
  function sha1$1(bytes) {
    const K = [1518500249, 1859775393, 2400959708, 3395469782];
    const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    const newBytes = new Uint8Array(bytes.length + 1);
    newBytes.set(bytes);
    newBytes[bytes.length] = 128;
    bytes = newBytes;
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for (let i = 0; i < N; ++i) {
      const arr = new Uint32Array(16);
      for (let j = 0; j < 16; ++j) {
        arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
      }
      M[i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
    for (let i = 0; i < N; ++i) {
      const W = new Uint32Array(80);
      for (let t = 0; t < 16; ++t) {
        W[t] = M[i][t];
      }
      for (let t = 16; t < 80; ++t) {
        W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
      }
      let a = H[0];
      let b = H[1];
      let c = H[2];
      let d = H[3];
      let e = H[4];
      for (let t = 0; t < 80; ++t) {
        const s = Math.floor(t / 20);
        const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }
      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }
    return Uint8Array.of(H[0] >> 24, H[0] >> 16, H[0] >> 8, H[0], H[1] >> 24, H[1] >> 16, H[1] >> 8, H[1], H[2] >> 24, H[2] >> 16, H[2] >> 8, H[2], H[3] >> 24, H[3] >> 16, H[3] >> 8, H[3], H[4] >> 24, H[4] >> 16, H[4] >> 8, H[4]);
  }
  sha1.default = sha1$1;
  return sha1;
}
var hasRequiredV5;
function requireV5() {
  if (hasRequiredV5) return v5;
  hasRequiredV5 = 1;
  (function(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URL = exports.DNS = void 0;
    const sha1_js_1 = requireSha1();
    const v35_js_1 = requireV35();
    var v35_js_2 = requireV35();
    Object.defineProperty(exports, "DNS", { enumerable: true, get: function() {
      return v35_js_2.DNS;
    } });
    Object.defineProperty(exports, "URL", { enumerable: true, get: function() {
      return v35_js_2.URL;
    } });
    function v52(value2, namespace, buf, offset) {
      return (0, v35_js_1.default)(80, sha1_js_1.default, value2, namespace, buf, offset);
    }
    v52.DNS = v35_js_1.DNS;
    v52.URL = v35_js_1.URL;
    exports.default = v52;
  })(v5);
  return v5;
}
var v6 = {};
var hasRequiredV6;
function requireV6() {
  if (hasRequiredV6) return v6;
  hasRequiredV6 = 1;
  "use strict";
  Object.defineProperty(v6, "__esModule", { value: true });
  const stringify_js_1 = requireStringify();
  const v1_js_1 = requireV1();
  const v1ToV6_js_1 = requireV1ToV6();
  function v6$1(options, buf, offset) {
    options ?? (options = {});
    offset ?? (offset = 0);
    let bytes = (0, v1_js_1.default)({ ...options, _v6: true }, new Uint8Array(16));
    bytes = (0, v1ToV6_js_1.default)(bytes);
    if (buf) {
      for (let i = 0; i < 16; i++) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, stringify_js_1.unsafeStringify)(bytes);
  }
  v6.default = v6$1;
  return v6;
}
var v6ToV1 = {};
var hasRequiredV6ToV1;
function requireV6ToV1() {
  if (hasRequiredV6ToV1) return v6ToV1;
  hasRequiredV6ToV1 = 1;
  "use strict";
  Object.defineProperty(v6ToV1, "__esModule", { value: true });
  const parse_js_1 = requireParse();
  const stringify_js_1 = requireStringify();
  function v6ToV1$1(uuid) {
    const v6Bytes = typeof uuid === "string" ? (0, parse_js_1.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === "string" ? (0, stringify_js_1.unsafeStringify)(v1Bytes) : v1Bytes;
  }
  v6ToV1.default = v6ToV1$1;
  function _v6ToV1(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  }
  return v6ToV1;
}
var v7 = {};
var hasRequiredV7;
function requireV7() {
  if (hasRequiredV7) return v7;
  hasRequiredV7 = 1;
  "use strict";
  Object.defineProperty(v7, "__esModule", { value: true });
  v7.updateV7State = void 0;
  const rng_js_1 = requireRng();
  const stringify_js_1 = requireStringify();
  const _state = {};
  function v7$1(options, buf, offset) {
    var _a;
    let bytes;
    if (options) {
      bytes = v7Bytes(options.random ?? ((_a = options.rng) == null ? void 0 : _a.call(options)) ?? (0, rng_js_1.default)(), options.msecs, options.seq, buf, offset);
    } else {
      const now = Date.now();
      const rnds = (0, rng_js_1.default)();
      updateV7State(_state, now, rnds);
      bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);
    }
    return buf ?? (0, stringify_js_1.unsafeStringify)(bytes);
  }
  function updateV7State(state, now, rnds) {
    state.msecs ?? (state.msecs = -Infinity);
    state.seq ?? (state.seq = 0);
    if (now > state.msecs) {
      state.seq = rnds[6] << 23 | rnds[7] << 16 | rnds[8] << 8 | rnds[9];
      state.msecs = now;
    } else {
      state.seq = state.seq + 1 | 0;
      if (state.seq === 0) {
        state.msecs++;
      }
    }
    return state;
  }
  v7.updateV7State = updateV7State;
  function v7Bytes(rnds, msecs, seq, buf, offset = 0) {
    if (rnds.length < 16) {
      throw new Error("Random bytes length must be >= 16");
    }
    if (!buf) {
      buf = new Uint8Array(16);
      offset = 0;
    } else {
      if (offset < 0 || offset + 16 > buf.length) {
        throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
      }
    }
    msecs ?? (msecs = Date.now());
    seq ?? (seq = rnds[6] * 127 << 24 | rnds[7] << 16 | rnds[8] << 8 | rnds[9]);
    buf[offset++] = msecs / 1099511627776 & 255;
    buf[offset++] = msecs / 4294967296 & 255;
    buf[offset++] = msecs / 16777216 & 255;
    buf[offset++] = msecs / 65536 & 255;
    buf[offset++] = msecs / 256 & 255;
    buf[offset++] = msecs & 255;
    buf[offset++] = 112 | seq >>> 28 & 15;
    buf[offset++] = seq >>> 20 & 255;
    buf[offset++] = 128 | seq >>> 14 & 63;
    buf[offset++] = seq >>> 6 & 255;
    buf[offset++] = seq << 2 & 255 | rnds[10] & 3;
    buf[offset++] = rnds[11];
    buf[offset++] = rnds[12];
    buf[offset++] = rnds[13];
    buf[offset++] = rnds[14];
    buf[offset++] = rnds[15];
    return buf;
  }
  v7.default = v7$1;
  return v7;
}
var version = {};
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  "use strict";
  Object.defineProperty(version, "__esModule", { value: true });
  const validate_js_1 = requireValidate();
  function version$1(uuid) {
    if (!(0, validate_js_1.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  version.default = version$1;
  return version;
}
var hasRequiredCjsBrowser;
function requireCjsBrowser() {
  if (hasRequiredCjsBrowser) return cjsBrowser;
  hasRequiredCjsBrowser = 1;
  (function(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = exports.validate = exports.v7 = exports.v6ToV1 = exports.v6 = exports.v5 = exports.v4 = exports.v3 = exports.v1ToV6 = exports.v1 = exports.stringify = exports.parse = exports.NIL = exports.MAX = void 0;
    var max_js_1 = requireMax();
    Object.defineProperty(exports, "MAX", { enumerable: true, get: function() {
      return max_js_1.default;
    } });
    var nil_js_1 = requireNil();
    Object.defineProperty(exports, "NIL", { enumerable: true, get: function() {
      return nil_js_1.default;
    } });
    var parse_js_1 = requireParse();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_js_1.default;
    } });
    var stringify_js_1 = requireStringify();
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return stringify_js_1.default;
    } });
    var v1_js_1 = requireV1();
    Object.defineProperty(exports, "v1", { enumerable: true, get: function() {
      return v1_js_1.default;
    } });
    var v1ToV6_js_1 = requireV1ToV6();
    Object.defineProperty(exports, "v1ToV6", { enumerable: true, get: function() {
      return v1ToV6_js_1.default;
    } });
    var v3_js_1 = requireV3();
    Object.defineProperty(exports, "v3", { enumerable: true, get: function() {
      return v3_js_1.default;
    } });
    var v4_js_1 = requireV4();
    Object.defineProperty(exports, "v4", { enumerable: true, get: function() {
      return v4_js_1.default;
    } });
    var v5_js_1 = requireV5();
    Object.defineProperty(exports, "v5", { enumerable: true, get: function() {
      return v5_js_1.default;
    } });
    var v6_js_1 = requireV6();
    Object.defineProperty(exports, "v6", { enumerable: true, get: function() {
      return v6_js_1.default;
    } });
    var v6ToV1_js_1 = requireV6ToV1();
    Object.defineProperty(exports, "v6ToV1", { enumerable: true, get: function() {
      return v6ToV1_js_1.default;
    } });
    var v7_js_1 = requireV7();
    Object.defineProperty(exports, "v7", { enumerable: true, get: function() {
      return v7_js_1.default;
    } });
    var validate_js_1 = requireValidate();
    Object.defineProperty(exports, "validate", { enumerable: true, get: function() {
      return validate_js_1.default;
    } });
    var version_js_1 = requireVersion();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return version_js_1.default;
    } });
  })(cjsBrowser);
  return cjsBrowser;
}
var FakeEventTarget$1 = {};
var hasRequiredFakeEventTarget$1;
function requireFakeEventTarget$1() {
  if (hasRequiredFakeEventTarget$1) return FakeEventTarget$1;
  hasRequiredFakeEventTarget$1 = 1;
  "use strict";
  Object.defineProperty(FakeEventTarget$1, "__esModule", { value: true });
  FakeEventTarget$1.FakeEventTarget = void 0;
  class FakeEventTarget2 {
    constructor() {
      __publicField(this, "listeners", {});
    }
    addEventListener(type, callback2, options) {
      var _a;
      if (!callback2) {
        return;
      }
      (_a = this.listeners)[type] ?? (_a[type] = []);
      this.listeners[type].push({
        callback: (
          // eslint-disable-next-line @typescript-eslint/unbound-method
          typeof callback2 === "function" ? callback2 : callback2.handleEvent
        ),
        once: typeof options === "object" && options.once === true
      });
    }
    removeEventListener(type, callback2, options) {
      if (!this.listeners[type]) {
        return;
      }
      if (!callback2) {
        return;
      }
      this.listeners[type] = this.listeners[type].filter((listener) => listener.callback !== // eslint-disable-next-line @typescript-eslint/unbound-method
      (typeof callback2 === "function" ? callback2 : callback2.handleEvent));
    }
    dispatchEvent(event) {
      if (!event || typeof event.type !== "string") {
        throw new Error("invalid event object");
      }
      const entries = this.listeners[event.type];
      if (!entries) {
        return true;
      }
      for (const listener of [...entries]) {
        try {
          listener.callback.call(this, event);
        } catch (error) {
          setTimeout(() => {
            throw error;
          }, 0);
        }
        if (listener.once) {
          this.removeEventListener(event.type, listener.callback);
        }
      }
      return !event.defaultPrevented;
    }
  }
  FakeEventTarget$1.FakeEventTarget = FakeEventTarget2;
  return FakeEventTarget$1;
}
var FakeEvent = {};
var hasRequiredFakeEvent;
function requireFakeEvent() {
  if (hasRequiredFakeEvent) return FakeEvent;
  hasRequiredFakeEvent = 1;
  "use strict";
  Object.defineProperty(FakeEvent, "__esModule", { value: true });
  FakeEvent.FakeEvent = void 0;
  let FakeEvent$1 = class FakeEvent {
    constructor(type, options = {}) {
      /**
       * Constants.
       */
      __publicField(this, "NONE", 0);
      __publicField(this, "CAPTURING_PHASE", 1);
      __publicField(this, "AT_TARGET", 2);
      __publicField(this, "BUBBLING_PHASE", 3);
      /**
       * Members.
       */
      __publicField(this, "type");
      __publicField(this, "bubbles");
      __publicField(this, "cancelable");
      __publicField(this, "defaultPrevented", false);
      __publicField(this, "composed", false);
      __publicField(this, "currentTarget", null);
      // Not implemented.
      __publicField(this, "eventPhase", this.NONE);
      __publicField(this, "isTrusted", true);
      __publicField(this, "target", null);
      __publicField(this, "timeStamp", 0);
      // Deprecated.
      __publicField(this, "cancelBubble", false);
      __publicField(this, "returnValue", true);
      __publicField(this, "srcElement", null);
      this.type = type;
      this.bubbles = options.bubbles ?? false;
      this.cancelable = options.cancelable ?? false;
    }
    preventDefault() {
      if (this.cancelable) {
        this.defaultPrevented = true;
      }
    }
    /**
     * Not implemented.
     */
    stopPropagation() {
    }
    /**
     * Not implemented.
     */
    stopImmediatePropagation() {
    }
    /**
     * Not implemented.
     */
    composedPath() {
      return [];
    }
    /**
     * Not implemented.
     * @deprecated
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    initEvent(type, bubbles, cancelable) {
    }
  };
  FakeEvent.FakeEvent = FakeEvent$1;
  return FakeEvent;
}
var utils = {};
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  "use strict";
  Object.defineProperty(utils, "__esModule", { value: true });
  utils.clone = clone;
  function clone(value2) {
    if (value2 === void 0) {
      return void 0;
    } else if (Number.isNaN(value2)) {
      return NaN;
    } else if (typeof structuredClone === "function") {
      return structuredClone(value2);
    } else {
      return JSON.parse(JSON.stringify(value2));
    }
  }
  return utils;
}
var hasRequiredLib$1;
function requireLib$1() {
  var _id, _kind, _label, _readyState, _enabled, _muted, _contentHint, _capabilities, _constraints, _settings, _data, _onmute, _onunmute, _onended, _onenabledchange, _onstopped;
  if (hasRequiredLib$1) return lib;
  hasRequiredLib$1 = 1;
  "use strict";
  Object.defineProperty(lib, "__esModule", { value: true });
  lib.FakeMediaStreamTrack = void 0;
  const uuid_1 = /* @__PURE__ */ requireCjsBrowser();
  const FakeEventTarget_1 = requireFakeEventTarget$1();
  const FakeEvent_1 = requireFakeEvent();
  const utils_1 = requireUtils();
  const _FakeMediaStreamTrack = class _FakeMediaStreamTrack extends FakeEventTarget_1.FakeEventTarget {
    constructor({ kind, id, label, contentHint, enabled, muted, readyState, capabilities, constraints, settings, data }) {
      super();
      __privateAdd(this, _id);
      __privateAdd(this, _kind);
      __privateAdd(this, _label);
      __privateAdd(this, _readyState);
      __privateAdd(this, _enabled);
      __privateAdd(this, _muted);
      __privateAdd(this, _contentHint);
      __privateAdd(this, _capabilities);
      __privateAdd(this, _constraints);
      __privateAdd(this, _settings);
      __privateAdd(this, _data);
      // Events.
      __privateAdd(this, _onmute, null);
      __privateAdd(this, _onunmute, null);
      __privateAdd(this, _onended, null);
      // Custom events.
      __privateAdd(this, _onenabledchange, null);
      __privateAdd(this, _onstopped, null);
      __privateSet(this, _id, id ?? (0, uuid_1.v4)());
      __privateSet(this, _kind, kind);
      __privateSet(this, _label, label ?? "");
      __privateSet(this, _contentHint, contentHint ?? "");
      __privateSet(this, _enabled, enabled ?? true);
      __privateSet(this, _muted, muted ?? false);
      __privateSet(this, _readyState, readyState ?? "live");
      __privateSet(this, _capabilities, capabilities ?? {});
      __privateSet(this, _constraints, constraints ?? {});
      __privateSet(this, _settings, settings ?? {});
      __privateSet(this, _data, data ?? {});
    }
    get id() {
      return __privateGet(this, _id);
    }
    get kind() {
      return __privateGet(this, _kind);
    }
    get label() {
      return __privateGet(this, _label);
    }
    get contentHint() {
      return __privateGet(this, _contentHint);
    }
    set contentHint(contentHint) {
      __privateSet(this, _contentHint, contentHint);
    }
    get enabled() {
      return __privateGet(this, _enabled);
    }
    /**
     * Changes `enabled` member value and fires a custom "enabledchange" event.
     */
    set enabled(enabled) {
      const changed = __privateGet(this, _enabled) !== enabled;
      __privateSet(this, _enabled, enabled);
      if (changed) {
        this.dispatchEvent(new FakeEvent_1.FakeEvent("enabledchange"));
      }
    }
    get muted() {
      return __privateGet(this, _muted);
    }
    get readyState() {
      return __privateGet(this, _readyState);
    }
    /**
     * Application custom data getter.
     */
    get data() {
      return __privateGet(this, _data);
    }
    /**
     * Application custom data setter.
     */
    set data(data) {
      __privateSet(this, _data, data);
    }
    get onmute() {
      return __privateGet(this, _onmute);
    }
    set onmute(handler) {
      if (__privateGet(this, _onmute)) {
        this.removeEventListener("mute", __privateGet(this, _onmute));
      }
      __privateSet(this, _onmute, handler);
      if (handler) {
        this.addEventListener("mute", handler);
      }
    }
    get onunmute() {
      return __privateGet(this, _onunmute);
    }
    set onunmute(handler) {
      if (__privateGet(this, _onunmute)) {
        this.removeEventListener("unmute", __privateGet(this, _onunmute));
      }
      __privateSet(this, _onunmute, handler);
      if (handler) {
        this.addEventListener("unmute", handler);
      }
    }
    get onended() {
      return __privateGet(this, _onended);
    }
    set onended(handler) {
      if (__privateGet(this, _onended)) {
        this.removeEventListener("ended", __privateGet(this, _onended));
      }
      __privateSet(this, _onended, handler);
      if (handler) {
        this.addEventListener("ended", handler);
      }
    }
    get onenabledchange() {
      return __privateGet(this, _onenabledchange);
    }
    set onenabledchange(handler) {
      if (__privateGet(this, _onenabledchange)) {
        this.removeEventListener("enabledchange", __privateGet(this, _onenabledchange));
      }
      __privateSet(this, _onenabledchange, handler);
      if (handler) {
        this.addEventListener("enabledchange", handler);
      }
    }
    get onstopped() {
      return __privateGet(this, _onstopped);
    }
    set onstopped(handler) {
      if (__privateGet(this, _onstopped)) {
        this.removeEventListener("stopped", __privateGet(this, _onstopped));
      }
      __privateSet(this, _onstopped, handler);
      if (handler) {
        this.addEventListener("stopped", handler);
      }
    }
    addEventListener(type, listener, options) {
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
    }
    /**
     * Changes `readyState` member to "ended" and fires a custom "stopped" event
     * (if not already stopped).
     */
    stop() {
      if (__privateGet(this, _readyState) === "ended") {
        return;
      }
      __privateSet(this, _readyState, "ended");
      this.dispatchEvent(new FakeEvent_1.FakeEvent("stopped"));
    }
    /**
     * Clones current track into another FakeMediaStreamTrack. `id` and `data`
     * can be optionally given.
     */
    clone({ id, data } = {}) {
      return new _FakeMediaStreamTrack({
        id: id ?? (0, uuid_1.v4)(),
        kind: __privateGet(this, _kind),
        label: __privateGet(this, _label),
        contentHint: __privateGet(this, _contentHint),
        enabled: __privateGet(this, _enabled),
        muted: __privateGet(this, _muted),
        readyState: __privateGet(this, _readyState),
        capabilities: (0, utils_1.clone)(__privateGet(this, _capabilities)),
        constraints: (0, utils_1.clone)(__privateGet(this, _constraints)),
        settings: (0, utils_1.clone)(__privateGet(this, _settings)),
        data: data ?? (0, utils_1.clone)(__privateGet(this, _data))
      });
    }
    getCapabilities() {
      return __privateGet(this, _capabilities);
    }
    getConstraints() {
      return __privateGet(this, _constraints);
    }
    async applyConstraints(constraints = {}) {
      __privateSet(this, _constraints, constraints);
      return Promise.resolve();
    }
    getSettings() {
      return __privateGet(this, _settings);
    }
    /**
     * Simulates a remotely triggered stop. It fires a custom "stopped" event and
     * the standard "ended" event (if the track was not already stopped).
     */
    remoteStop() {
      if (__privateGet(this, _readyState) === "ended") {
        return;
      }
      __privateSet(this, _readyState, "ended");
      this.dispatchEvent(new FakeEvent_1.FakeEvent("stopped"));
      this.dispatchEvent(new FakeEvent_1.FakeEvent("ended"));
    }
    /**
     * Simulates a remotely triggered mute. It fires a "mute" event (if the track
     * was not already muted).
     */
    remoteMute() {
      if (__privateGet(this, _muted)) {
        return;
      }
      __privateSet(this, _muted, true);
      this.dispatchEvent(new FakeEvent_1.FakeEvent("mute"));
    }
    /**
     * Simulates a remotely triggered unmute. It fires an "unmute" event (if the
     * track was muted).
     */
    remoteUnmute() {
      if (!__privateGet(this, _muted)) {
        return;
      }
      __privateSet(this, _muted, false);
      this.dispatchEvent(new FakeEvent_1.FakeEvent("unmute"));
    }
  };
  _id = new WeakMap();
  _kind = new WeakMap();
  _label = new WeakMap();
  _readyState = new WeakMap();
  _enabled = new WeakMap();
  _muted = new WeakMap();
  _contentHint = new WeakMap();
  _capabilities = new WeakMap();
  _constraints = new WeakMap();
  _settings = new WeakMap();
  _data = new WeakMap();
  _onmute = new WeakMap();
  _onunmute = new WeakMap();
  _onended = new WeakMap();
  _onenabledchange = new WeakMap();
  _onstopped = new WeakMap();
  let FakeMediaStreamTrack = _FakeMediaStreamTrack;
  lib.FakeMediaStreamTrack = FakeMediaStreamTrack;
  return lib;
}
var FakeEventTarget = {};
var hasRequiredFakeEventTarget;
function requireFakeEventTarget() {
  if (hasRequiredFakeEventTarget) return FakeEventTarget;
  hasRequiredFakeEventTarget = 1;
  "use strict";
  Object.defineProperty(FakeEventTarget, "__esModule", { value: true });
  FakeEventTarget.FakeEventTarget = void 0;
  let FakeEventTarget$12 = class FakeEventTarget {
    constructor() {
      __publicField(this, "listeners", {});
    }
    addEventListener(type, callback2, options) {
      var _a;
      if (!callback2) {
        return;
      }
      (_a = this.listeners)[type] ?? (_a[type] = []);
      this.listeners[type].push({
        callback: typeof callback2 === "function" ? callback2 : callback2.handleEvent,
        once: typeof options === "object" && options.once === true
      });
    }
    removeEventListener(type, callback2, options) {
      if (!this.listeners[type]) {
        return;
      }
      if (!callback2) {
        return;
      }
      this.listeners[type] = this.listeners[type].filter((listener) => listener.callback !== (typeof callback2 === "function" ? callback2 : callback2.handleEvent));
    }
    dispatchEvent(event) {
      if (!event || typeof event.type !== "string") {
        throw new Error("invalid event object");
      }
      const entries = this.listeners[event.type];
      if (!entries) {
        return true;
      }
      for (const listener of [...entries]) {
        try {
          listener.callback.call(this, event);
        } catch (error) {
          setTimeout(() => {
            throw error;
          }, 0);
        }
        if (listener.once) {
          this.removeEventListener(event.type, listener.callback);
        }
      }
      return !event.defaultPrevented;
    }
  };
  FakeEventTarget.FakeEventTarget = FakeEventTarget$12;
  return FakeEventTarget;
}
var hasRequiredFakeHandler;
function requireFakeHandler() {
  if (hasRequiredFakeHandler) return FakeHandler;
  hasRequiredFakeHandler = 1;
  "use strict";
  Object.defineProperty(FakeHandler, "__esModule", { value: true });
  FakeHandler.FakeHandler = void 0;
  const fake_mediastreamtrack_1 = requireLib$1();
  const enhancedEvents_1 = requireEnhancedEvents();
  const Logger_1 = requireLogger$2();
  const utils2 = requireUtils$2();
  const ortc2 = requireOrtc();
  const errors_1 = requireErrors$1();
  const FakeEventTarget_1 = requireFakeEventTarget();
  const logger = new Logger_1.Logger("FakeHandler");
  const NAME = "FakeHandler";
  let FakeHandler$1 = class FakeHandler2 extends enhancedEvents_1.EnhancedEventEmitter {
    constructor({
      // direction,
      // iceParameters,
      // iceCandidates,
      // dtlsParameters,
      // sctpParameters,
      // iceServers,
      // iceTransportPolicy,
      // additionalSettings,
      getSendExtendedRtpCapabilities
    }, fakeParameters2) {
      super();
      // Closed flag.
      __publicField(this, "_closed", false);
      // Fake parameters source of RTP and SCTP parameters and capabilities.
      __publicField(this, "_fakeParameters");
      // Callback to request sending extended RTP capabilities on demand.
      __publicField(this, "_getSendExtendedRtpCapabilities");
      // Local RTCP CNAME.
      __publicField(this, "_cname", `CNAME-${utils2.generateRandomNumber()}`);
      // Got transport local and remote parameters.
      __publicField(this, "_transportReady", false);
      // Next localId.
      __publicField(this, "_nextLocalId", 1);
      // Sending and receiving tracks indexed by localId.
      __publicField(this, "_tracks", /* @__PURE__ */ new Map());
      // DataChannel id value counter. It must be incremented for each new DataChannel.
      __publicField(this, "_nextSctpStreamId", 0);
      logger.debug("constructor()");
      this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
      this._fakeParameters = fakeParameters2;
    }
    /**
     * Creates a factory function.
     */
    static createFactory(fakeParameters2) {
      return {
        name: NAME,
        factory: (options) => new FakeHandler2(options, fakeParameters2),
        getNativeRtpCapabilities: async () => {
          logger.debug("getNativeRtpCapabilities()");
          return FakeHandler2.getLocalRtpCapabilities(fakeParameters2);
        },
        getNativeSctpCapabilities: async () => {
          logger.debug("getNativeSctpCapabilities()");
          return fakeParameters2.generateNativeSctpCapabilities();
        }
      };
    }
    static getLocalRtpCapabilities(fakeParameters2) {
      const nativeRtpCapabilities = fakeParameters2.generateNativeRtpCapabilities();
      ortc2.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
      return nativeRtpCapabilities;
    }
    get name() {
      return NAME;
    }
    close() {
      logger.debug("close()");
      if (this._closed) {
        return;
      }
      this._closed = true;
      super.close();
    }
    // NOTE: Custom method for simulation purposes.
    setIceGatheringState(iceGatheringState) {
      this.emit("@icegatheringstatechange", iceGatheringState);
    }
    // NOTE: Custom method for simulation purposes.
    setConnectionState(connectionState) {
      this.emit("@connectionstatechange", connectionState);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async updateIceServers(iceServers) {
      this.assertNotClosed();
      logger.debug("updateIceServers()");
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async restartIce(iceParameters) {
      this.assertNotClosed();
      logger.debug("restartIce()");
    }
    async getTransportStats() {
      this.assertNotClosed();
      return /* @__PURE__ */ new Map();
    }
    async send({ track, encodings, codecOptions, codec }) {
      this.assertNotClosed();
      logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
      if (!this._transportReady) {
        await this.setupTransport({ localDtlsRole: "server" });
      }
      const nativeRtpCapabilities = FakeHandler2.getLocalRtpCapabilities(this._fakeParameters);
      const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
      const sendingRtpParameters = ortc2.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
      sendingRtpParameters.codecs = ortc2.reduceCodecs(sendingRtpParameters.codecs, codec);
      const useRtx = sendingRtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
      sendingRtpParameters.mid = `mid-${utils2.generateRandomNumber()}`;
      if (!encodings) {
        encodings = [{}];
      }
      for (const encoding of encodings) {
        encoding.ssrc = utils2.generateRandomNumber();
        if (useRtx) {
          encoding.rtx = { ssrc: utils2.generateRandomNumber() };
        }
      }
      sendingRtpParameters.encodings = encodings;
      sendingRtpParameters.rtcp = {
        cname: this._cname,
        reducedSize: true,
        mux: true
      };
      const localId = this._nextLocalId++;
      this._tracks.set(localId, track);
      return { localId: String(localId), rtpParameters: sendingRtpParameters };
    }
    async stopSending(localId) {
      logger.debug("stopSending() [localId:%s]", localId);
      if (this._closed) {
        return;
      }
      if (!this._tracks.has(Number(localId))) {
        throw new Error("local track not found");
      }
      this._tracks.delete(Number(localId));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async pauseSending(localId) {
      this.assertNotClosed();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async resumeSending(localId) {
      this.assertNotClosed();
    }
    async replaceTrack(localId, track) {
      this.assertNotClosed();
      if (track) {
        logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
      } else {
        logger.debug("replaceTrack() [localId:%s, no track]", localId);
      }
      this._tracks.delete(Number(localId));
      this._tracks.set(Number(localId), track);
    }
    async setMaxSpatialLayer(localId, spatialLayer) {
      this.assertNotClosed();
      logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
    }
    async setRtpEncodingParameters(localId, params2) {
      this.assertNotClosed();
      logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params2);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getSenderStats(localId) {
      this.assertNotClosed();
      return /* @__PURE__ */ new Map();
    }
    async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol: protocol2 }) {
      this.assertNotClosed();
      if (!this._transportReady) {
        await this.setupTransport({ localDtlsRole: "server" });
      }
      logger.debug("sendDataChannel()");
      const dataChannel = new FakeRTCDataChannel({
        id: this._nextSctpStreamId++,
        ordered,
        maxPacketLifeTime,
        maxRetransmits,
        label,
        protocol: protocol2
      });
      const sctpStreamParameters = {
        streamId: this._nextSctpStreamId,
        ordered,
        maxPacketLifeTime,
        maxRetransmits
      };
      return { dataChannel, sctpStreamParameters };
    }
    async receive(optionsList) {
      this.assertNotClosed();
      const results = [];
      for (const options of optionsList) {
        const { trackId, kind } = options;
        if (!this._transportReady) {
          await this.setupTransport({ localDtlsRole: "client" });
        }
        logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
        const localId = this._nextLocalId++;
        const track = new fake_mediastreamtrack_1.FakeMediaStreamTrack({ kind });
        this._tracks.set(localId, track);
        results.push({ localId: String(localId), track });
      }
      return results;
    }
    async stopReceiving(localIds) {
      if (this._closed) {
        return;
      }
      for (const localId of localIds) {
        logger.debug("stopReceiving() [localId:%s]", localId);
        this._tracks.delete(Number(localId));
      }
    }
    async pauseReceiving(localIds) {
      this.assertNotClosed();
    }
    async resumeReceiving(localIds) {
      this.assertNotClosed();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async getReceiverStats(localId) {
      this.assertNotClosed();
      return /* @__PURE__ */ new Map();
    }
    async receiveDataChannel({ sctpStreamParameters, label, protocol: protocol2 }) {
      this.assertNotClosed();
      if (!this._transportReady) {
        await this.setupTransport({ localDtlsRole: "client" });
      }
      logger.debug("receiveDataChannel()");
      const dataChannel = new FakeRTCDataChannel({
        id: sctpStreamParameters.streamId,
        ordered: sctpStreamParameters.ordered,
        maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime,
        maxRetransmits: sctpStreamParameters.maxRetransmits,
        label,
        protocol: protocol2
      });
      return { dataChannel };
    }
    async setupTransport({
      localDtlsRole,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localSdpObject
    }) {
      const dtlsParameters = utils2.clone(this._fakeParameters.generateLocalDtlsParameters());
      if (localDtlsRole) {
        dtlsParameters.role = localDtlsRole;
      }
      this.emit("@connectionstatechange", "connecting");
      await new Promise((resolve, reject) => this.emit("@connect", { dtlsParameters }, resolve, reject));
      this._transportReady = true;
    }
    assertNotClosed() {
      if (this._closed) {
        throw new errors_1.InvalidStateError("method called in a closed handler");
      }
    }
  };
  FakeHandler.FakeHandler = FakeHandler$1;
  class FakeRTCDataChannel extends FakeEventTarget_1.FakeEventTarget {
    constructor({ id, ordered = true, maxPacketLifeTime = null, maxRetransmits = null, label = "", protocol: protocol2 = "" }) {
      super();
      // Members for RTCDataChannel standard public getters/setters.
      __publicField(this, "_id");
      __publicField(this, "_negotiated", true);
      // mediasoup just uses negotiated DataChannels.
      __publicField(this, "_ordered");
      __publicField(this, "_maxPacketLifeTime");
      __publicField(this, "_maxRetransmits");
      __publicField(this, "_label");
      __publicField(this, "_protocol");
      __publicField(this, "_readyState", "connecting");
      __publicField(this, "_bufferedAmount", 0);
      __publicField(this, "_bufferedAmountLowThreshold", 0);
      __publicField(this, "_binaryType", "arraybuffer");
      // Events.
      __publicField(this, "_onopen", null);
      __publicField(this, "_onclosing", null);
      __publicField(this, "_onclose", null);
      __publicField(this, "_onmessage", null);
      __publicField(this, "_onbufferedamountlow", null);
      __publicField(this, "_onerror", null);
      logger.debug(`constructor() [id:${id}, ordered:${ordered}, maxPacketLifeTime:${maxPacketLifeTime}, maxRetransmits:${maxRetransmits}, label:${label}, protocol:${protocol2}`);
      this._id = id;
      this._ordered = ordered;
      this._maxPacketLifeTime = maxPacketLifeTime;
      this._maxRetransmits = maxRetransmits;
      this._label = label;
      this._protocol = protocol2;
    }
    get id() {
      return this._id;
    }
    get negotiated() {
      return this._negotiated;
    }
    get ordered() {
      return this._ordered;
    }
    get maxPacketLifeTime() {
      return this._maxPacketLifeTime;
    }
    get maxRetransmits() {
      return this._maxRetransmits;
    }
    get label() {
      return this._label;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get bufferedAmount() {
      return this._bufferedAmount;
    }
    get bufferedAmountLowThreshold() {
      return this._bufferedAmountLowThreshold;
    }
    set bufferedAmountLowThreshold(value2) {
      this._bufferedAmountLowThreshold = value2;
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(binaryType) {
      this._binaryType = binaryType;
    }
    get onopen() {
      return this._onopen;
    }
    set onopen(handler) {
      if (this._onopen) {
        this.removeEventListener("open", this._onopen);
      }
      this._onopen = handler;
      if (handler) {
        this.addEventListener("open", handler);
      }
    }
    get onclosing() {
      return this._onclosing;
    }
    set onclosing(handler) {
      if (this._onclosing) {
        this.removeEventListener("closing", this._onclosing);
      }
      this._onclosing = handler;
      if (handler) {
        this.addEventListener("closing", handler);
      }
    }
    get onclose() {
      return this._onclose;
    }
    set onclose(handler) {
      if (this._onclose) {
        this.removeEventListener("close", this._onclose);
      }
      this._onclose = handler;
      if (handler) {
        this.addEventListener("close", handler);
      }
    }
    get onmessage() {
      return this._onmessage;
    }
    set onmessage(handler) {
      if (this._onmessage) {
        this.removeEventListener("message", this._onmessage);
      }
      this._onmessage = handler;
      if (handler) {
        this.addEventListener("message", handler);
      }
    }
    get onbufferedamountlow() {
      return this._onbufferedamountlow;
    }
    set onbufferedamountlow(handler) {
      if (this._onbufferedamountlow) {
        this.removeEventListener("bufferedamountlow", this._onbufferedamountlow);
      }
      this._onbufferedamountlow = handler;
      if (handler) {
        this.addEventListener("bufferedamountlow", handler);
      }
    }
    get onerror() {
      return this._onerror;
    }
    set onerror(handler) {
      if (this._onerror) {
        this.removeEventListener("error", this._onerror);
      }
      this._onerror = handler;
      if (handler) {
        this.addEventListener("error", handler);
      }
    }
    addEventListener(type, listener, options) {
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
    }
    close() {
      if (["closing", "closed"].includes(this._readyState)) {
        return;
      }
      this._readyState = "closed";
    }
    /**
     * We extend the definition of send() to allow Node Buffer. However
     * ArrayBufferView and Blob do not exist in Node.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    send(data) {
      if (this._readyState !== "open") {
        throw new errors_1.InvalidStateError("not open");
      }
    }
  }
  return FakeHandler;
}
var fakeParameters = {};
var hasRequiredFakeParameters;
function requireFakeParameters() {
  if (hasRequiredFakeParameters) return fakeParameters;
  hasRequiredFakeParameters = 1;
  "use strict";
  Object.defineProperty(fakeParameters, "__esModule", { value: true });
  fakeParameters.generateRouterRtpCapabilities = generateRouterRtpCapabilities;
  fakeParameters.generateNativeRtpCapabilities = generateNativeRtpCapabilities;
  fakeParameters.generateNativeSctpCapabilities = generateNativeSctpCapabilities;
  fakeParameters.generateLocalDtlsParameters = generateLocalDtlsParameters;
  fakeParameters.generateTransportRemoteParameters = generateTransportRemoteParameters;
  fakeParameters.generateProducerRemoteParameters = generateProducerRemoteParameters;
  fakeParameters.generateConsumerRemoteParameters = generateConsumerRemoteParameters;
  fakeParameters.generateDataProducerRemoteParameters = generateDataProducerRemoteParameters;
  fakeParameters.generateDataConsumerRemoteParameters = generateDataConsumerRemoteParameters;
  const utils2 = requireUtils$2();
  function generateFakeUuid() {
    return String(utils2.generateRandomNumber());
  }
  function generateRouterRtpCapabilities() {
    return utils2.deepFreeze({
      codecs: [
        {
          mimeType: "audio/opus",
          kind: "audio",
          preferredPayloadType: 100,
          clockRate: 48e3,
          channels: 2,
          rtcpFeedback: [{ type: "transport-cc" }],
          parameters: {
            useinbandfec: 1,
            foo: "bar"
          }
        },
        {
          mimeType: "video/VP8",
          kind: "video",
          preferredPayloadType: 101,
          clockRate: 9e4,
          rtcpFeedback: [
            { type: "nack" },
            { type: "nack", parameter: "pli" },
            { type: "ccm", parameter: "fir" },
            { type: "goog-remb" },
            { type: "transport-cc" }
          ],
          parameters: {
            "x-google-start-bitrate": 1500
          }
        },
        {
          mimeType: "video/rtx",
          kind: "video",
          preferredPayloadType: 102,
          clockRate: 9e4,
          rtcpFeedback: [],
          parameters: {
            apt: 101
          }
        },
        {
          mimeType: "video/H264",
          kind: "video",
          preferredPayloadType: 103,
          clockRate: 9e4,
          rtcpFeedback: [
            { type: "nack" },
            { type: "nack", parameter: "pli" },
            { type: "ccm", parameter: "fir" },
            { type: "goog-remb" },
            { type: "transport-cc" }
          ],
          parameters: {
            "level-asymmetry-allowed": 1,
            "packetization-mode": 1,
            "profile-level-id": "42e01f"
          }
        },
        {
          mimeType: "video/rtx",
          kind: "video",
          preferredPayloadType: 104,
          clockRate: 9e4,
          rtcpFeedback: [],
          parameters: {
            apt: 103
          }
        },
        {
          mimeType: "video/VP9",
          kind: "video",
          preferredPayloadType: 105,
          clockRate: 9e4,
          rtcpFeedback: [
            { type: "nack" },
            { type: "nack", parameter: "pli" },
            { type: "ccm", parameter: "fir" },
            { type: "goog-remb" },
            { type: "transport-cc" }
          ],
          parameters: {
            "profile-id": 0,
            "x-google-start-bitrate": 1500
          }
        },
        {
          mimeType: "video/rtx",
          kind: "video",
          preferredPayloadType: 106,
          clockRate: 9e4,
          rtcpFeedback: [],
          parameters: {
            apt: 105
          }
        }
      ],
      headerExtensions: [
        {
          kind: "audio",
          uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
          preferredId: 1,
          preferredEncrypt: false,
          direction: "sendrecv"
        },
        {
          kind: "video",
          uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
          preferredId: 1,
          preferredEncrypt: false,
          direction: "sendrecv"
        },
        {
          kind: "video",
          uri: "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id",
          preferredId: 2,
          preferredEncrypt: false,
          direction: "recvonly"
        },
        {
          kind: "video",
          uri: "urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id",
          preferredId: 3,
          preferredEncrypt: false,
          direction: "recvonly"
        },
        {
          kind: "audio",
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
          preferredId: 4,
          preferredEncrypt: false,
          direction: "sendrecv"
        },
        {
          kind: "video",
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
          preferredId: 4,
          preferredEncrypt: false,
          direction: "sendrecv"
        },
        {
          kind: "audio",
          uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
          preferredId: 5,
          preferredEncrypt: false,
          direction: "recvonly"
        },
        {
          kind: "video",
          uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
          preferredId: 5,
          preferredEncrypt: false,
          direction: "sendrecv"
        },
        {
          kind: "audio",
          uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
          preferredId: 10,
          preferredEncrypt: false,
          direction: "sendrecv"
        },
        {
          kind: "video",
          uri: "urn:3gpp:video-orientation",
          preferredId: 11,
          preferredEncrypt: false,
          direction: "sendrecv"
        },
        {
          kind: "video",
          uri: "urn:ietf:params:rtp-hdrext:toffset",
          preferredId: 12,
          preferredEncrypt: false,
          direction: "sendrecv"
        }
      ]
    });
  }
  function generateNativeRtpCapabilities() {
    return {
      codecs: [
        {
          mimeType: "audio/opus",
          kind: "audio",
          preferredPayloadType: 111,
          clockRate: 48e3,
          channels: 2,
          rtcpFeedback: [{ type: "transport-cc" }],
          parameters: {
            minptime: 10,
            useinbandfec: 1
          }
        },
        {
          mimeType: "audio/ISAC",
          kind: "audio",
          preferredPayloadType: 103,
          clockRate: 16e3,
          channels: 1,
          rtcpFeedback: [{ type: "transport-cc" }],
          parameters: {}
        },
        {
          mimeType: "audio/CN",
          kind: "audio",
          preferredPayloadType: 106,
          clockRate: 32e3,
          channels: 1,
          rtcpFeedback: [{ type: "transport-cc" }],
          parameters: {}
        },
        {
          mimeType: "audio/foo",
          kind: "audio",
          preferredPayloadType: 107,
          clockRate: 9e4,
          channels: 4,
          rtcpFeedback: [{ type: "foo-qwe-qwe" }],
          parameters: {
            foo: "lalala"
          }
        },
        {
          mimeType: "video/BAZCODEC",
          kind: "video",
          preferredPayloadType: 100,
          clockRate: 9e4,
          rtcpFeedback: [
            { type: "foo" },
            { type: "transport-cc" },
            { type: "ccm", parameter: "fir" },
            { type: "nack" },
            { type: "nack", parameter: "pli" }
          ],
          parameters: {
            baz: "1234abcd"
          }
        },
        {
          mimeType: "video/rtx",
          kind: "video",
          preferredPayloadType: 101,
          clockRate: 9e4,
          rtcpFeedback: [],
          parameters: {
            apt: 100
          }
        },
        {
          mimeType: "video/VP8",
          kind: "video",
          preferredPayloadType: 96,
          clockRate: 9e4,
          rtcpFeedback: [
            { type: "goog-remb" },
            { type: "transport-cc" },
            { type: "ccm", parameter: "fir" },
            { type: "nack" },
            { type: "nack", parameter: "pli" }
          ],
          parameters: {
            baz: "1234abcd"
          }
        },
        {
          mimeType: "video/rtx",
          kind: "video",
          preferredPayloadType: 97,
          clockRate: 9e4,
          rtcpFeedback: [],
          parameters: {
            apt: 96
          }
        },
        {
          mimeType: "video/VP9",
          kind: "video",
          preferredPayloadType: 98,
          clockRate: 9e4,
          rtcpFeedback: [
            { type: "goog-remb" },
            { type: "transport-cc" },
            { type: "ccm", parameter: "fir" },
            { type: "nack" },
            { type: "nack", parameter: "pli" }
          ],
          parameters: {
            "profile-id": 0
          }
        },
        {
          mimeType: "video/rtx",
          kind: "video",
          preferredPayloadType: 99,
          clockRate: 9e4,
          rtcpFeedback: [],
          parameters: {
            apt: 98
          }
        }
      ],
      headerExtensions: [
        {
          kind: "audio",
          uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
          preferredId: 1
        },
        {
          kind: "video",
          uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
          preferredId: 1
        },
        {
          kind: "video",
          uri: "urn:ietf:params:rtp-hdrext:toffset",
          preferredId: 2
        },
        {
          kind: "video",
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
          preferredId: 3
        },
        {
          kind: "video",
          uri: "urn:3gpp:video-orientation",
          preferredId: 4
        },
        {
          kind: "video",
          uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
          preferredId: 5
        },
        {
          kind: "video",
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay",
          preferredId: 6
        },
        {
          kind: "video",
          // @ts-expect-error --- ON purpose.
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/video-content-type",
          preferredId: 7
        },
        {
          kind: "video",
          // @ts-expect-error --- ON purpose.
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/video-timing",
          preferredId: 8
        },
        {
          kind: "audio",
          uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
          preferredId: 10
        }
      ]
    };
  }
  function generateNativeSctpCapabilities() {
    return utils2.deepFreeze({
      numStreams: { OS: 2048, MIS: 2048 }
    });
  }
  function generateLocalDtlsParameters() {
    return utils2.deepFreeze({
      fingerprints: [
        {
          algorithm: "sha-256",
          value: "82:5A:68:3D:36:C3:0A:DE:AF:E7:32:43:D2:88:83:57:AC:2D:65:E5:80:C4:B6:FB:AF:1A:A0:21:9F:6D:0C:AD"
        }
      ],
      role: "auto"
    });
  }
  function generateTransportRemoteParameters() {
    return {
      id: generateFakeUuid(),
      iceParameters: utils2.deepFreeze({
        iceLite: true,
        password: "yku5ej8nvfaor28lvtrabcx0wkrpkztz",
        usernameFragment: "h3hk1iz6qqlnqlne"
      }),
      iceCandidates: utils2.deepFreeze([
        {
          foundation: "udpcandidate",
          address: "9.9.9.9",
          ip: "9.9.9.9",
          port: 40533,
          priority: 1078862079,
          protocol: "udp",
          type: "host",
          tcpType: "passive"
        },
        {
          foundation: "udpcandidate",
          address: "9.9.9.9",
          ip: "9:9:9:9:9:9",
          port: 41333,
          priority: 1078862089,
          protocol: "udp",
          type: "host",
          tcpType: "passive"
        }
      ]),
      dtlsParameters: utils2.deepFreeze({
        fingerprints: [
          {
            algorithm: "sha-256",
            value: "A9:F4:E0:D2:74:D3:0F:D9:CA:A5:2F:9F:7F:47:FA:F0:C4:72:DD:73:49:D0:3B:14:90:20:51:30:1B:90:8E:71"
          },
          {
            algorithm: "sha-384",
            value: "03:D9:0B:87:13:98:F6:6D:BC:FC:92:2E:39:D4:E1:97:32:61:30:56:84:70:81:6E:D1:82:97:EA:D9:C1:21:0F:6B:C5:E7:7F:E1:97:0C:17:97:6E:CF:B3:EF:2E:74:B0"
          },
          {
            algorithm: "sha-512",
            value: "84:27:A4:28:A4:73:AF:43:02:2A:44:68:FF:2F:29:5C:3B:11:9A:60:F4:A8:F0:F5:AC:A0:E3:49:3E:B1:34:53:A9:85:CE:51:9B:ED:87:5E:B8:F4:8E:3D:FA:20:51:B8:96:EE:DA:56:DC:2F:5C:62:79:15:23:E0:21:82:2B:2C"
          }
        ],
        role: "auto"
      }),
      sctpParameters: utils2.deepFreeze({
        port: 5e3,
        OS: 2048,
        MIS: 2048,
        maxMessageSize: 2e6
      })
    };
  }
  function generateProducerRemoteParameters() {
    return utils2.deepFreeze({
      id: generateFakeUuid()
    });
  }
  function generateConsumerRemoteParameters({ id, codecMimeType } = {}) {
    switch (codecMimeType) {
      case "audio/opus": {
        return {
          id: id ?? generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: "audio",
          rtpParameters: utils2.deepFreeze({
            codecs: [
              {
                mimeType: "audio/opus",
                payloadType: 100,
                clockRate: 48e3,
                channels: 2,
                rtcpFeedback: [{ type: "transport-cc" }],
                parameters: {
                  useinbandfec: 1,
                  foo: "bar"
                }
              }
            ],
            encodings: [
              {
                ssrc: 46687003
              }
            ],
            headerExtensions: [
              {
                uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                id: 1
              },
              {
                uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                id: 5
              },
              {
                uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
                id: 10
              }
            ],
            rtcp: {
              cname: "wB4Ql4lrsxYLjzuN",
              reducedSize: true,
              mux: true
            }
          })
        };
      }
      case "audio/ISAC": {
        return {
          id: id ?? generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: "audio",
          rtpParameters: utils2.deepFreeze({
            codecs: [
              {
                mimeType: "audio/ISAC",
                payloadType: 111,
                clockRate: 16e3,
                channels: 1,
                rtcpFeedback: [{ type: "transport-cc" }],
                parameters: {}
              }
            ],
            encodings: [
              {
                ssrc: 46687004
              }
            ],
            headerExtensions: [
              {
                uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                id: 1
              },
              {
                uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                id: 5
              }
            ],
            rtcp: {
              cname: "wB4Ql4lrsxYLjzuN",
              reducedSize: true,
              mux: true
            }
          })
        };
      }
      case "video/VP8": {
        return {
          id: id ?? generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: "video",
          rtpParameters: utils2.deepFreeze({
            codecs: [
              {
                mimeType: "video/VP8",
                payloadType: 101,
                clockRate: 9e4,
                rtcpFeedback: [
                  { type: "nack" },
                  { type: "nack", parameter: "pli" },
                  { type: "ccm", parameter: "fir" },
                  { type: "goog-remb" },
                  { type: "transport-cc" }
                ],
                parameters: {
                  "x-google-start-bitrate": 1500
                }
              },
              {
                mimeType: "video/rtx",
                payloadType: 102,
                clockRate: 9e4,
                rtcpFeedback: [],
                parameters: {
                  apt: 101
                }
              }
            ],
            encodings: [
              {
                ssrc: 99991111,
                rtx: {
                  ssrc: 99991112
                }
              }
            ],
            headerExtensions: [
              {
                uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                id: 1
              },
              {
                uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                id: 4
              },
              {
                uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                id: 5
              },
              {
                uri: "urn:3gpp:video-orientation",
                id: 11
              },
              {
                uri: "urn:ietf:params:rtp-hdrext:toffset",
                id: 12
              }
            ],
            rtcp: {
              cname: "wB4Ql4lrsxYLjzuN",
              reducedSize: true,
              mux: true
            }
          })
        };
      }
      case "video/H264": {
        return {
          id: id ?? generateFakeUuid(),
          producerId: generateFakeUuid(),
          kind: "video",
          rtpParameters: utils2.deepFreeze({
            codecs: [
              {
                mimeType: "video/H264",
                payloadType: 103,
                clockRate: 9e4,
                rtcpFeedback: [
                  { type: "nack" },
                  { type: "nack", parameter: "pli" },
                  { type: "ccm", parameter: "fir" },
                  { type: "goog-remb" },
                  { type: "transport-cc" }
                ],
                parameters: {
                  "level-asymmetry-allowed": 1,
                  "packetization-mode": 1,
                  "profile-level-id": "42e01f"
                }
              },
              {
                mimeType: "video/rtx",
                payloadType: 104,
                clockRate: 9e4,
                rtcpFeedback: [],
                parameters: {
                  apt: 103
                }
              }
            ],
            encodings: [
              {
                ssrc: 99991113,
                rtx: {
                  ssrc: 99991114
                }
              }
            ],
            headerExtensions: [
              {
                uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                id: 1
              },
              {
                uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                id: 4
              },
              {
                uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                id: 5
              },
              {
                uri: "urn:3gpp:video-orientation",
                id: 11
              },
              {
                uri: "urn:ietf:params:rtp-hdrext:toffset",
                id: 12
              }
            ],
            rtcp: {
              cname: "wB4Ql4lrsxYLjzuN",
              reducedSize: true,
              mux: true
            }
          })
        };
      }
      default: {
        throw new TypeError(`unknown codecMimeType '${codecMimeType}'`);
      }
    }
  }
  function generateDataProducerRemoteParameters() {
    return utils2.deepFreeze({
      id: generateFakeUuid()
    });
  }
  function generateDataConsumerRemoteParameters({ id } = {}) {
    return {
      id: id ?? generateFakeUuid(),
      dataProducerId: generateFakeUuid(),
      sctpStreamParameters: utils2.deepFreeze({
        streamId: 666,
        maxPacketLifeTime: 5e3,
        maxRetransmits: void 0
      })
    };
  }
  return fakeParameters;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$4;
  hasRequiredLib = 1;
  (function(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debug = exports.testFakeParameters = exports.FakeHandler = exports.enhancedEvents = exports.ortc = exports.parseScalabilityMode = exports.detectDeviceAsync = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
    const debug_1 = requireBrowser();
    exports.debug = debug_1.default;
    exports.types = requireTypes();
    exports.version = "3.16.0";
    var Device_1 = requireDevice();
    Object.defineProperty(exports, "Device", { enumerable: true, get: function() {
      return Device_1.Device;
    } });
    Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function() {
      return Device_1.detectDevice;
    } });
    Object.defineProperty(exports, "detectDeviceAsync", { enumerable: true, get: function() {
      return Device_1.detectDeviceAsync;
    } });
    var scalabilityModes_1 = requireScalabilityModes();
    Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function() {
      return scalabilityModes_1.parse;
    } });
    exports.ortc = requireOrtc();
    exports.enhancedEvents = requireEnhancedEvents();
    var FakeHandler_1 = requireFakeHandler();
    Object.defineProperty(exports, "FakeHandler", { enumerable: true, get: function() {
      return FakeHandler_1.FakeHandler;
    } });
    exports.testFakeParameters = requireFakeParameters();
  })(lib$4);
  return lib$4;
}
var libExports = requireLib();
const index = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
let remoteVideo, localVideo;
socketHandler.streamInit = function() {
  setVideoObj();
  globalModel.connection.on("consumeReceive", async ({ params: params2 }) => {
    if (params2.error) {
      return;
    }
    consumer = await consumerTransport.consume({
      id: params2.id,
      producerId: params2.producerId,
      kind: params2.kind,
      rtpParameters: params2.rtpParameters
    });
    const { track } = consumer;
    remoteVideo.srcObject = new MediaStream([track]);
    remoteVideo.muted = true;
    remoteVideo.onloadedmetadata = () => {
      remoteVideo.play().catch((e) => {
        console.warn("Play error:", e);
      });
    };
    globalModel.connection.emit("consumerResume", {
      roomId: socketHandler.roomId,
      userKey: socketHandler.userKey
    });
  });
  globalModel.connection.on("getRtpCapabilitiesReceive", async (data) => {
    rtpCapabilities = data.rtpCapabilities;
    await createDevice(localObj);
  });
  globalModel.connection.on("startProduceStream", async (data) => {
    socketHandler.closelObj();
    getLocalStream();
  });
  globalModel.connection.on("startConsumerStream", async (data) => {
    socketHandler.closelObj();
    getRtpCapabilities(false);
  });
  globalModel.connection.on("canselStream", async (data) => {
    socketHandler.closelObj();
  });
};
function setVideoObj() {
  localVideo = document.querySelector(`#localVideo`);
  remoteVideo = document.querySelector(`#remoteVideo`);
}
socketHandler.closelObj = function() {
  remoteVideo.srcObject = null;
  localVideo.srcObject = null;
  if (consumer) {
    consumer.close();
    consumer = null;
  }
  if (consumerTransport) {
    consumerTransport.close();
    consumerTransport = null;
  }
  if (producer) {
    producer.close();
    producer = null;
  }
  if (producerTransport) {
    producerTransport.close();
    producerTransport = null;
  }
};
let device;
let rtpCapabilities;
let producerTransport;
let consumerTransport;
let producer;
let consumer;
let localObj;
let params = {
  encodings: [
    { maxBitrate: 9e5 }
  ],
  codecOptions: {
    videoGoogleStartBitrate: 1e3
  }
};
function streamSuccess(stream) {
  localVideo.srcObject = stream;
  var track = stream.getVideoTracks()[0];
  getRtpCapabilities(true);
  params.track = track;
}
function getLocalStream() {
  const audioConstraints = {
    channelCount: 1,
    sampleRate: 48e3,
    sampleSize: 16,
    echoCancellation: true,
    noiseSuppression: true,
    autoGainControl: true
  };
  const videoConstraints = {
    width: { ideal: 426 },
    height: { ideal: 240 },
    frameRate: { ideal: 15, max: 20 }
  };
  navigator.getUserMedia({
    video: videoConstraints,
    audio: audioConstraints
  }, streamSuccess, (error) => {
  });
}
async function getRtpCapabilities(local) {
  localObj = local;
  globalModel.connection.emit("getRtpCapabilities", {
    roomId: socketHandler.roomId,
    userKey: socketHandler.userKey
  });
}
async function createDevice(local) {
  try {
    device = new libExports.Device();
    await device.load({
      routerRtpCapabilities: rtpCapabilities
    });
    if (local)
      createSendTransport();
    else
      createRecvTransport();
  } catch (error) {
    console.log(error);
    if (error.name === "UnsupportedError")
      console.warn("browser not supported");
  }
}
function createSendTransport() {
  const model = {
    roomId: socketHandler.roomId,
    userKey: socketHandler.userKey,
    sender: true
  };
  globalModel.connection.emit("createWebRtcTransport", model, ({ params: params2 }) => {
    if (params2.error) {
      console.log(params2.error);
      return;
    }
    producerTransport = device.createSendTransport(params2);
    producerTransport.on("connect", async ({ dtlsParameters }, errback) => {
      try {
        await globalModel.connection.emit("transportConnect", {
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey,
          dtlsParameters
        });
        callback();
      } catch (error) {
        errback(error);
      }
    });
    producerTransport.on("produce", async (parameters, callback2, errback) => {
      try {
        await globalModel.connection.emit("transportProduce", {
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey,
          kind: parameters.kind,
          rtpParameters: parameters.rtpParameters,
          appData: parameters.appData
        }, ({ id }) => {
          callback2({ id });
        });
      } catch (error) {
        errback(error);
      }
    });
    connectSendTransport();
  });
}
async function connectSendTransport() {
  producer = await producerTransport.produce(params);
}
async function createRecvTransport() {
  const model = {
    roomId: socketHandler.roomId,
    userKey: socketHandler.userKey,
    sender: false
  };
  await globalModel.connection.emit("createWebRtcTransport", model, ({ params: params2 }) => {
    if (params2.error) {
      console.log(params2.error);
      return;
    }
    consumerTransport = device.createRecvTransport(params2);
    globalModel.connection.emit("consume", {
      roomId: socketHandler.roomId,
      userKey: socketHandler.userKey,
      rtpCapabilities: device.rtpCapabilities
    });
    consumerTransport.on("connect", async ({ dtlsParameters }, callback2, errback) => {
      try {
        await globalModel.connection.emit("transportRecvConnect", {
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey,
          dtlsParameters
        });
        callback2();
      } catch (error) {
        errback(error);
      }
    });
  });
}
socketHandler.initSoket = function() {
  let params2 = new URLSearchParams(document.location.search);
  socketHandler.roomId = params2.get("roomId");
  socketHandler.userKey = params2.get("userKey");
  socketHandler.userId = params2.get("userId");
  globalModel.connection = lookup(`${publicHubBaseUrl}/hubMafia`, {
    auth: {
      roomId: socketHandler.roomId,
      userKey: socketHandler.userKey
    }
  });
  globalModel.connection.on("connectionReceive", ({ socketId }) => {
    socketHandler.socketId = socketId;
    socketCallBack();
  });
  globalModel.connection.on("disconnect", () => {
    console.log(`---a---disconnect :`);
  });
  globalModel.connection.on("infoRoomReceive", globalModel.infoRoomReceive);
  globalModel.connection.on("userStatusReceive", globalModel.userStatusReceive);
  globalModel.connection.on("infoMainReceive", globalModel.infoMainReceive);
  globalModel.connection.on("addStickerReceive", sticker.addStickerReceive);
  globalModel.connection.on("rayegiriReceive", socketHandler.rayegiriReceive);
  globalModel.connection.on("rayeKhorojReceive", socketHandler.rayeKhorojReceive);
  globalModel.connection.on("setRayeReceive", socketHandler.setRayeReceive);
  globalModel.connection.on("defaeListReceive", socketHandler.defaeListReceive);
  globalModel.connection.on("defaeReceive", socketHandler.defaeReceive);
  globalModel.connection.on("khorojReceive", socketHandler.khorojReceive);
  globalModel.connection.on("estelamReceive", socketHandler.estelamReceive);
  globalModel.connection.on("setEstelamReceive", socketHandler.setEstelamReceive);
  globalModel.connection.on("setKalantarShotReceive", socketHandler.setKalantarShotReceive);
  globalModel.connection.on("setHadseNaghshReceive", socketHandler.setHadseNaghshReceive);
  globalModel.connection.on("chaosReceive", chaos.chaosReceive);
  globalModel.connection.on("setRayeChaosReceive", chaos.setRayeChaosReceive);
  globalModel.connection.on("addMessageReceive", main.addMessageReceive);
  globalModel.connection.on("setNightEventReceive", main.setNightEventReceive);
  globalModel.connection.on("setNegahbanReceive", main.setNegahbanReceive);
  globalModel.connection.on("nightUpdate", globalModel.nightUpdate);
  globalModel.connection.on("mobarezMsgReceive", main.mobarezMsgReceive);
  globalModel.connection.on("KaragahMsgReceive", main.KaragahMsgReceive);
  globalModel.connection.on("kharabkarMsgReceive", main.kharabkarMsgReceive);
  globalModel.connection.on("gameResponseReceive", gameresponse.gameResponseReceive);
  globalModel.connection.on("endGameReceive", gameresponse.endGameReceive);
  globalModel.connection.on("getMessage", gameresponse.getMessage);
};
function socketCallBack() {
  publicUserRow = 5;
  vm.appModel.loding = false;
  vm.changeState("main");
  main.init();
  itemclick.listen();
  socketHandler.streamInit();
}
main.stream = null;
const iconClass = {
  sticker: "icon-smileys",
  chalesh: "icon-chalesh",
  like: "icon-like",
  dislike: "icon-dislike"
};
const iconClassDisabled = {
  sticker: "icon-smileys iconDisabled",
  chalesh: "icon-chalesh iconDisabled",
  like: "icon-like iconDisabled",
  dislike: "icon-dislike iconDisabled"
};
const naghsh = {
  title: "راهنما",
  icon: "icon-information4",
  color: "#7499ac"
};
main.init = function() {
  vm.$refs.childmain.naghsh = naghsh;
  vm.$refs.childmain.iconClass = iconClassDisabled;
  globalModel.connection.on("getDefensePositionReceive", getDefensePositionReceive);
  globalModel.connection.on("startStreamReceive", startStreamReceive);
  globalModel.connection.on("endStreamReceive", endStreamReceive);
  globalModel.connection.on("addChaleshReceive", addChaleshReceive);
  globalModel.connection.on("setChaleshReceive", setChaleshReceive);
};
main.setUsers = function() {
  globalModel.user = globalModel.users.find((x) => x.id == socketHandler.userId);
  vm.$refs.childmain.user = globalModel.user;
  vm.$refs.childmain.users = globalModel.users;
  vm.$refs.childmain.naghsh = help.usersReceive(globalModel.user.type);
  if (globalModel.isChaos)
    chaos.setUsers();
};
main.nightAlert = function() {
  removeNightIconGroup();
  globalModel.isNightEvent = false;
  if (globalModel.isChaos || globalModel.room.door == 1 || globalModel.room.doorType != 3 || globalModel.user.userInGameStatus != 1) return;
  if ([7, 8].indexOf(globalModel.user.type) > -1) return;
  if ([6, 9].indexOf(globalModel.user.type) > -1 && !globalModel.groupItem.shot) return;
  const divEl = document.createElement("div");
  divEl.className = `modalBady`;
  divEl.style.textAlign = "center";
  if (globalModel.user.type == 4)
    divEl.innerHTML = `<div>از یک نفر دربرابر شلیک مافیا محافظت کنید</div>`;
  else if (globalModel.user.type == 5)
    divEl.innerHTML = `<div>استعلام یک نفر را بگیرید</div>`;
  else if (globalModel.user.type == 10) {
    const users = globalModel.users.filter((x) => [1, 10].indexOf(x.userInGameStatus) > -1);
    divEl.innerHTML = users.length >= 7 ? `<div>از قابلیت نقش 2 نفر حفاظت کنید</div>` : `<div>از قابلیت نقش 1 نفر حفاظت کنید</div>`;
  } else
    divEl.innerHTML = `<div>میتوانید یک نفر را برای شلیک انتخاب کنید</div>`;
  if (globalModel.user.type == 22)
    divEl.innerHTML += `<div>قابلیت نقش یک نفر را ازبین ببرید</div>`;
  if (globalModel.user.type == 23)
    divEl.innerHTML += `<div>نتیجه استعلام یک نفر را تغییر دهید</div>`;
  document.body.appendChild(divEl);
  setTimeout(() => {
    addNightIconGroup();
    globalModel.isNightEvent = true;
    divEl.remove();
  }, 4e3);
};
main.addMessageReceive = function(model) {
  vm.$refs.childmain.chatList.unshift(model);
};
main.addNightEvent = function(rowNum2) {
  if (globalModel.user.userInGameStatus != 1 || [7, 8].indexOf(globalModel.user.type) > -1) return;
  if ([9, 6].indexOf(globalModel.user.type) > -1 && !globalModel.groupItem.shot) return;
  const u = globalModel.users.find((x) => x.row == rowNum2);
  if (!u || [1, 10].indexOf(u.userInGameStatus) == -1) return;
  if ([22, 23].indexOf(globalModel.user.type) > -1) {
    const divEl = document.createElement("div");
    divEl.className = `modalBady 56a4sfde`;
    let i2 = `icon-sabotage`;
    if (globalModel.user.type == 23)
      i2 = `icon-smileys`;
    divEl.innerHTML = `<div class="modalTarget d-flex" style="margin-top: 0px;"><i class="icon icon-target" onclick="main.addNightEvent2(0, ${rowNum2})"></i><i class="icon ${i2}" onclick="main.addNightEvent2(1, ${rowNum2})"></i></div>`;
    document.body.appendChild(divEl);
  } else {
    main.addNightEvent2(0, rowNum2);
  }
};
main.addNightEvent2 = function(type, rowNum2) {
  const el2 = document.getElementsByClassName(`56a4sfde`) || [];
  Array.from(el2).map((x) => x.remove());
  const u = globalModel.users.find((x) => x.row == rowNum2);
  if (!u) return;
  let eventName = "setNightEvent";
  if (globalModel.user.type == 10)
    eventName = "setNegahban";
  globalModel.connection.emit(eventName, {
    targetId: u.id,
    eventType: type,
    roomId: socketHandler.roomId,
    userKey: socketHandler.userKey
  });
};
main.setNightEventReceive = function(model) {
  remove(model.type);
  model.nightEvents.map((x) => {
    const u = globalModel.users.find((u2) => u2.id == x.targetId);
    if (!u) return;
    const nightIconGroup = document.querySelector(`.nightIconGroup.el${u.row}`);
    if (!nightIconGroup) return;
    nightIconGroup.innerHTML += `<i class="nightIcon ${getIcon(x.type, x.eventType)}"></i>`;
  });
  function getIcon(type, eventType) {
    const typeIcon = `nightIconEventType${eventType} nightIconUserType${type}`;
    if (type > 21 && eventType == 1) {
      if (type == 22)
        return `${typeIcon} icon-sabotage`;
      else return `${typeIcon} icon-smileys`;
    } else if (type == 4)
      return `${typeIcon} icon-bolt-shield`;
    else if (type == 5)
      return `${typeIcon} icon-search-normal-2`;
    else return `${typeIcon} icon-target`;
  }
  function remove(type) {
    const typeIcon = `.nightIcon.nightIconUserType${type}`;
    const el = document.querySelectorAll(typeIcon) || [];
    Array.from(el).map((x) => x.remove());
  }
};
main.setNegahbanReceive = function(model) {
  const el = document.querySelectorAll(`.nightIcon.icon-bolt-shield`) || [];
  Array.from(el).map((x) => x.remove());
  model.map((x) => {
    const u = globalModel.users.find((u2) => u2.id == x.targetId);
    if (!u) return;
    const nightIconGroup = document.querySelector(`.nightIconGroup.el${u.row}`);
    if (!nightIconGroup) return;
    nightIconGroup.innerHTML = '<i class="nightIcon icon-bolt-shield"></i>';
  });
};
main.mobarezMsgReceive = function(model) {
  elModal("شما مورد حمله قرار گرفته و از خود دفاع کردید");
  globalModel.groupItem.shot = false;
};
main.KaragahMsgReceive = function(model) {
  const u = globalModel.users.find((x) => x.id == model.targetId);
  if (!u) return;
  let icon = "icon-dislike";
  let msg = '<span style="color: green;">منفی</span>';
  if (model.isMafia) {
    icon = "icon-like";
    msg = '<span style="color: red;">مثبت</span>';
  }
  const html = `<div class="itemImg"><img src="${u.info.Img}90.jpg" /></div> <div><i class="KaragahMsg ${icon}"></i></div><div>پاسخ استعلام ${u.info.UserName} ${msg} است</div>`;
  elModal(html);
};
main.kharabkarMsgReceive = function(model) {
  elModal("مافیا اجازه‌ی استفاده از نقش شما را سلب کرده بود.");
};
function getDefensePositionReceive(model) {
  main.reset();
  globalModel.activeUser = {
    index: model.activeUser,
    row: model.activeUser + 1
  };
  globalModel.room.wait = model.wait;
  main.getDefensePosition();
  main.topTimeProgress(-100);
}
function startStreamReceive(model) {
  main.reset(true);
  globalModel.room.wait = model.wait;
  main.topTimeProgress(-100);
  vm.$refs.childmain.soundDivI = true;
  main.stream = model;
  if (model.activeUser == globalModel.user.index) {
    vm.$refs.childmain.iconClass = iconClassDisabled;
    vm.$refs.childitemclick.isAddTarget = true;
    vm.$refs.childmain.cancelBtn = true;
  } else {
    vm.$refs.childmain.iconClass = iconClass;
    if (globalModel.room.door == 1)
      vm.$refs.childmain.iconClass.chalesh = "icon-chalesh iconDisabled";
    else
      vm.$refs.childmain.iconClass.chalesh = "icon-chalesh";
    vm.$refs.childitemclick.isAddTarget = false;
  }
  const user = vm.$refs.childmain.users.find((u) => u.index == model.activeUser);
}
function endStreamReceive(model) {
  main.reset();
  vm.$refs.childmain.soundDivI = false;
  socketHandler.closelObj();
  vm.$refs.childmain.iconClass = iconClassDisabled;
  vm.$refs.childitemclick.isAddTarget = false;
  vm.$refs.childmain.cancelBtn = false;
  removeChalesh();
  const el = document.getElementsByClassName(`chaleshForItem2`) || [];
  Array.from(el).map((x) => x.remove());
  main.stream = null;
}
function addChaleshReceive(model) {
  const u = globalModel.users.find((x) => x.id == model);
  chaleshReceive(u.row);
}
function setChaleshReceive(model) {
  const u = globalModel.users.find((x) => x.id == model);
  const el = document.querySelector(`.chaleshForItem.el${u.row}`);
  if (!el)
    return;
  el.classList.remove("chaleshForItem");
  el.classList.add("chaleshForItem2");
  removeChalesh();
}
function addNightIconGroup() {
  globalModel.users.map((x) => {
    const nightIconGroup = document.querySelector(`.nightIconGroup.el${x.row}`);
    if (nightIconGroup) return;
    const itemImg = document.querySelector(`.itemMain${x.row}`);
    if (itemImg) {
      const rectEl = itemImg.getBoundingClientRect();
      const el = document.createElement("div");
      el.className = `nightIconGroup el${x.row}`;
      el.style.top = `${rectEl.top}px`;
      if (x.row > 5) el.style.left = "5px";
      else el.style.right = "5px";
      document.body.appendChild(el);
    }
  });
}
function removeNightIconGroup() {
  const el = document.getElementsByClassName(`nightIconGroup`) || [];
  Array.from(el).map((x) => x.remove());
  const el2 = document.getElementsByClassName(`56a4sfde`) || [];
  Array.from(el2).map((x) => x.remove());
}
function elModal(model) {
  const divEl = document.createElement("div");
  divEl.className = `KaragahMsgBody`;
  divEl.innerHTML = model;
  document.body.appendChild(divEl);
  setTimeout(() => {
    divEl.remove();
  }, 5e3);
}
main.reset = function(itemMainFix) {
  if (!itemMainFix) {
    const mainRightElements = document.querySelectorAll('.mainTemplate [class^="itemMain"]');
    Array.from(mainRightElements).forEach((el) => {
      el.getAnimations().forEach((anim) => anim.cancel());
      el.style.position = "unset";
    });
  }
  vm.$refs.childmain.soundDivI = false;
  vm.$refs.childmain.soundDivSpan = false;
  vm.$refs.childmain.msg = {};
  resetTimer();
};
function resetTimer() {
  var _a;
  if (main.topTimeProgressTimer)
    clearTimeout(main.topTimeProgressTimer);
  main.topTimeProgressTimer = null;
  (_a = main.topTimeProgressAnimation) == null ? void 0 : _a.cancel();
  main.topTimeProgressAnimation = null;
  vm.$refs.childmain.mainTopTime = "- ----";
  vm.$refs.childmain.progressbarWidth = "0px";
}
isSetSoundDiv = false;
function setSoundDiv$1() {
  if (isSetSoundDiv) return;
  const el = document.querySelector(`.soundDiv`);
  el.style.width = "80px";
  el.style.top = `${screen.height / 4 - 25}px`;
  el.style.left = `${screen.width / 2 - 40}px`;
}
main.getDefensePosition = function(duration) {
  main.reset();
  const el = document.querySelector(`.mainTemplate .itemMain${globalModel.activeUser.row}`);
  const rectEl = el.getBoundingClientRect();
  el.style.position = "fixed";
  el.style.width = "60px";
  const top = screen.height / 4;
  const left = screen.width / 2 - rectEl.width / 2;
  const animation2 = el.animate([
    { top: `${rectEl.top}px`, left: `${rectEl.left}px` },
    { top: `${top}px`, left: `${left}px` }
  ], {
    duration: duration ? duration : 400,
    easing: "ease-in-out",
    fill: "forwards"
  });
  setSoundDiv$1();
  animation2.onfinish = () => {
  };
};
main.topTimeProgress = function(i) {
  if (i == -100) {
    i = globalModel.room.wait;
    const progressbar = document.querySelector(".aw213sdaf div");
    progressbar.style.width = `100%`;
    main.topTimeProgressAnimation = progressbar.animate([
      { width: `100%` },
      { width: `0%` }
    ], {
      duration: globalModel.room.wait * 1e3,
      easing: "linear",
      fill: "forwards"
    });
  }
  if (i == 0) {
    main.reset(true);
    return;
  }
  const newTime = i - 1;
  vm.$refs.childmain.mainTopTime = `${i} ثانیه`;
  main.topTimeProgressTimer = setTimeout(() => {
    main.startStrimInt--;
    main.topTimeProgress(newTime);
  }, 1e3);
};
main.Component = function(app2) {
  app2.component("main-component", {
    template: "#main-template",
    data() {
      return {
        iconClass: {},
        mainTopTime: "- ----",
        naghsh: {},
        door: "-",
        progressbarWidth: "0px",
        soundDivI: false,
        cancelBtn: false,
        raye: false,
        user: {},
        users: [],
        msg: {},
        chatList: [],
        chatMessage: "",
        isChat: false
      };
    },
    props: {
      appModel: {
        type: Object,
        required: true,
        default: () => ({})
      }
    },
    methods: {
      init() {
      },
      setCancel() {
        globalModel.connection.emit("setCancel", {
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      },
      addChalesh() {
        var _a;
        if (!main.stream || !((_a = globalModel.user) == null ? void 0 : _a.id)) return;
        if (main.stream.activeUser == globalModel.user.index) return;
        globalModel.connection.emit("addChalesh", {
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      },
      setRaye() {
        if (!globalModel.activeUser || !globalModel.activeUser.type) return;
        if (globalModel.activeUser.type != "rayeDefae" && globalModel.activeUser.type != "rayeKhoroj") return;
        globalModel.connection.emit("setRaye", {
          type: globalModel.activeUser.type,
          index: globalModel.activeUser.index,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      },
      addMessage() {
        if (!globalModel.room.doorType != 3 && globalModel.user.type < 20) return;
        globalModel.connection.emit("addMessage", {
          message: this.chatMessage,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
        this.chatMessage = "";
      }
    }
  });
  app2.component("mainitem-component", {
    template: "#mainitem-template",
    data() {
      return {};
    },
    props: {
      left: Boolean,
      users: {
        type: Array
      },
      appModel: {
        type: Object,
        required: true,
        default: () => ({})
      }
    },
    methods: {
      itemStatus(item) {
        if (item) {
          if (this.appModel.nightMode && (item.userInGameStatus == 1 || item.userInGameStatus == 10)) {
            const user = globalModel.users.find((x) => x.id == item.id);
            const icon = item.userInGameStatus == 10 ? `${user.nightIcon} ofline` : user.nightIcon;
            return icon;
          }
          switch (item.userInGameStatus) {
            case 1:
              return "a6s5d4q";
            case 10:
              return "imgStatus icon-ofline";
            case 2:
            case 11:
              return "imgStatus icon-death";
          }
        }
        return "imgStatus icon-ofline";
      }
    }
  });
};
const Mafia_COMMENT0 = `
<p>بازی رنگ و راز 5 نفر بازی شرکت کننده دارد</p><p>نقش‌ها: 2 نقاش، 1 بازپرس، 1 استاد، و 1 جاسوس</p><p>شما باید تلاش کنید بوسیله طراحی و گفتگو جاسوس را بیابید</p>
<hr>
<p>استاد موضوع نقاشی را انتخاب کرده و به همه (به‌جز جاسوس) اعلام می‌کند</p><p>جاسوس از طراحی‌ها تلاش می‌کند موضوع را حدس بزند و طرح خودش را بکشد.</p><p>شرکت‌کنندگان از طرح خود و ارتباط آن با موضوع دفاع می‌کنند</p><p>در زمان دفاع, موضوع برای جاسوس مشخص میشود</p>
<hr><p>این بازی در 1 دور آشنایی, 1 دور طراحی و نهایتا 3 دور دفاع برگزار میشود</p>`;
const Mafia_COMMENT4 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT5 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT6 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT7 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT8 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT9 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT10 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT21 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT22 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const Mafia_COMMENT23 = `
<p>موضوع نقاشی تنها در دور دفاع از طرح برای جاسوس مشخص میشود.</p>
<p>در صورت خروج جاسوس از بازی بوسله رای‌گیری, در صورت حدس درست نقش استاد , جاسوس برنده بازی خواهد بود</p>`;
const HELP_Mafia_COMMENT = [
  {
    "type": "0",
    "title": "راهنما",
    "icon": "icon-information4",
    "comment": Mafia_COMMENT0
  },
  {
    "type": "4",
    "title": "آهنگر",
    "icon": "icon-ahangar",
    "comment": Mafia_COMMENT4
  },
  {
    "type": "5",
    "title": "کاراگاه",
    "icon": "icon-karagah",
    "comment": Mafia_COMMENT5
  },
  {
    "type": "6",
    "title": "شکارچی",
    "icon": "icon-shekarchi",
    "comment": Mafia_COMMENT6
  },
  {
    "type": "7",
    "title": "کلانتر",
    "icon": "icon-kalantar",
    "comment": Mafia_COMMENT7
  },
  {
    "type": "8",
    "title": "رویین‌تن",
    "icon": "icon-rointan",
    "comment": Mafia_COMMENT8
  },
  {
    "type": "9",
    "title": "مبارز",
    "icon": "icon-mobarez",
    "comment": Mafia_COMMENT9
  },
  {
    "type": "10",
    "title": "نگهبان",
    "icon": "icon-zendanban",
    "comment": Mafia_COMMENT10
  },
  {
    "type": "21",
    "title": "رییس مافیا",
    "icon": "icon-mafia2",
    "comment": Mafia_COMMENT21
  },
  {
    "type": "22",
    "title": "خرابکار",
    "icon": "icon-mafia1",
    "comment": Mafia_COMMENT22
  },
  {
    "type": "23",
    "title": "تغییردهنده",
    "icon": "icon-mafia3",
    "comment": Mafia_COMMENT23
  }
];
let isShowCard = false;
function showCard() {
  if (isShowCard) return;
  isShowCard = true;
  vm.$refs.childhelp.isShowCard = true;
  const el = document.querySelector(`.naghshCard`);
  el.top = `50%`;
  setTimeout(() => {
    const animation2 = el.animate([
      { top: `50%`, transform: "translate(-50%, -50%) scale(1)" },
      { top: `14px`, transform: "translate(-50%, -50%) scale(0.1)" }
    ], {
      duration: 400,
      easing: "ease-in-out"
    });
    animation2.onfinish = () => {
      vm.$refs.childhelp.isShowCard = false;
    };
  }, 5e3);
}
help.find = function(type) {
  return HELP_Mafia_COMMENT.find((h) => h.type == type);
};
help.usersReceive = function(type) {
  const helpItem = HELP_Mafia_COMMENT.find((h) => h.type == type);
  vm.$refs.childhelp.selectItem = helpItem;
  vm.$refs.childhelp.selectType = helpItem.type;
  showCard();
  return helpItem;
};
help.Component = function(app2) {
  app2.component("help-component", {
    template: "#help-template",
    data() {
      return {
        helpComment: HELP_Mafia_COMMENT,
        myItem: {},
        selectItem: {},
        selectType: 0,
        isShowCard: true
      };
    },
    props: {
      appModel: {
        type: Object,
        required: true,
        default: () => ({})
      }
    },
    created() {
    },
    methods: {
      init() {
      },
      changeSelectType(item) {
        this.selectItem = item;
        this.selectType = item.type;
      }
    }
  });
};
chaos.setRayeChaosReceive = function(model) {
  const elements = document.querySelectorAll(".raiechaosItem");
  elements.forEach((element) => {
    element.remove();
  });
  const user = globalModel.users.find((x) => x.id == model.userId);
  const el = document.querySelector(`.chaosItem${user.row} .itemImg`);
  if (!el)
    return;
  const divEl = document.createElement("div");
  divEl.className = `raiechaosItem imgStatus icon-tarazo`;
  el.appendChild(divEl);
};
chaos.chaosReceive = function(model) {
  if (model.type != "start")
    reset();
  if (model.type == "chaos") {
    globalModel.isNightEvent = false;
    vm.appModel.nightMode = false;
    vm.$refs.childchaos.users = globalModel.users.filter((x) => x.userInGameStatus == 1 || x.userInGameStatus == 10);
    globalModel.isChaos = true;
    vm.changeState("chaos");
    vm.$refs.childchaos.msg1 = "آخرین گفتگو";
    vm.$refs.childchaos.msg2 = "درصورت عدم انتخاب پس از آخرین گفتگو برنده بصورت تصادفی انتخاب میشود";
  }
  if (model.type == "wait") wait(model);
  if (model.type == "start") start(model);
  if (model.type == "end") end(model);
  if (model.type == "resultChaosWait") resultChaosWait(model);
  if (model.type == "resultChaos") resultChaos(model);
  if (model.type != "end")
    progressTime$1(model.wait);
};
function wait(model) {
  chaos.activeUser = {
    index: model.activeUser,
    row: model.activeUser + 1
  };
  getDefensePosition();
}
function start(model) {
  vm.$refs.childchaos.soundDivI = true;
}
function end(model) {
  vm.$refs.childchaos.soundDivI = false;
  socketHandler.closelObj();
  chaos.activeUser = {};
}
function resultChaosWait(model) {
  vm.$refs.childchaos.exit = true;
  vm.$refs.childchaos.msg1 = "انتخاب";
  vm.$refs.childchaos.msg2 = "یک نفر را برای خروج انتخاب کنید";
}
function resultChaos(model) {
  const user = globalModel.users.find((x) => x.id == model.id);
  if (!user) return;
  let time = model.wait * 1e3;
  const divEl = document.createElement("div");
  divEl.className = `modalBady`;
  divEl.style.textAlign = "center";
  divEl.innerHTML = `<div><div class="itemImg"><img src="${user.info.Img}90.jpg"></div><div class="userName">${user.info.UserName}</div></div><div>از بازی خارج شد</div>`;
  document.body.appendChild(divEl);
  setTimeout(() => {
    divEl.remove();
  }, time);
}
function getDefensePosition() {
  const el = document.querySelector(`.mainTemplate .chaosItem${chaos.activeUser.row}`);
  const rectEl = el.getBoundingClientRect();
  el.style.position = "fixed";
  el.style.width = "60px";
  const top = screen.height / 4;
  const left = screen.width / 2 - rectEl.width / 2;
  el.animate([
    { top: `${rectEl.top}px`, left: `${rectEl.left}px` },
    { top: `${top}px`, left: `${left}px` }
  ], {
    duration: 400,
    easing: "ease-in-out",
    fill: "forwards"
  });
  setSoundDiv();
}
function reset() {
  const mainRightElements = document.querySelectorAll('.mainTemplate [class^="chaosItem"]');
  Array.from(mainRightElements).forEach((el) => {
    el.getAnimations().forEach((anim) => anim.cancel());
    el.style.position = "unset";
  });
  vm.$refs.childchaos.soundDivI = false;
  vm.$refs.childchaos.exit = false;
}
chaos.setUsers = function() {
  vm.$refs.childchaos.users = globalModel.users.filter((x) => x.userInGameStatus == 1 || x.userInGameStatus == 10);
};
let animation = null;
function progressTime$1(time) {
  const el = document.querySelector(`.ap218daf div`);
  if (!el)
    return;
  if (animation)
    animation == null ? void 0 : animation.cancel();
  el.style.width = `100%`;
  animation = el.animate([
    { width: `100%` },
    { width: `0%` }
  ], {
    duration: time * 1e3,
    easing: "linear",
    fill: "forwards"
  });
  animation.onfinish = () => {
    el.style.width = `0px`;
  };
}
isSetSoundDiv = false;
function setSoundDiv() {
  if (isSetSoundDiv) return;
  const el = document.querySelector(`.soundDiv2`);
  el.style.width = "80px";
  el.style.top = `${screen.height / 4 - 25}px`;
  el.style.left = `${screen.width / 2 - 40}px`;
}
chaos.Component = function(app2) {
  chaos.activeUser = {};
  app2.component("chaos-component", {
    template: "#chaos-template",
    data() {
      return {
        progressbarWidth: "0px",
        soundDivI: false,
        exit: false,
        users: [],
        msg1: "",
        msg2: ""
      };
    },
    props: {
      appModel: {
        type: Object,
        required: true,
        default: () => ({})
      }
    },
    methods: {
      init() {
      },
      itemStatus(item) {
        if (item) {
          switch (item.userInGameStatus) {
            case 1:
              return "a6s5d4q";
            case 10:
              return "imgStatus icon-ofline";
            case 2:
            case 11:
              return "imgStatus icon-death";
          }
        }
        return "imgStatus icon-ofline";
      },
      itemClick(id) {
        if (!this.exit) return;
        globalModel.connection.emit("setRayeChaos", {
          userId: id,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      }
    }
  });
};
sticker.reset = function() {
};
sticker.isAddSticker = false;
sticker.addStickerReceive = async function(model) {
  try {
    const u = globalModel.users.find((x) => x.id == model.id);
    await addStickerVideo(model.t, u.row);
  } catch (error) {
  }
};
sticker.handleUpdate = function(text) {
  var _a;
  if (sticker.isAddSticker || !main.stream || !((_a = globalModel.user) == null ? void 0 : _a.id)) return;
  if (main.stream.activeUser == globalModel.user.index) return;
  sticker.isAddSticker = true;
  globalModel.connection.emit("addSticker", {
    t: text,
    roomId: socketHandler.roomId,
    userKey: socketHandler.userKey
  });
  setTimeout(() => {
    sticker.isAddSticker = false;
  }, 2e3);
};
sticker.toggleTab = function() {
  var _a;
  const el = document.querySelector(".stickerMain");
  if (el.style.display == "block") {
    el.style.display = "none";
    return;
  }
  if (!main.stream || !((_a = globalModel.user) == null ? void 0 : _a.id)) return;
  if (main.stream.activeUser == globalModel.user.index) return;
  el.style.display = "block";
};
sticker.Component = function(app2) {
  app2.component("sticker-component", {
    template: "#sticker-template",
    data() {
      return {
        icons: [
          "😎",
          "🙂",
          "😊",
          "😀",
          "😆",
          "😂",
          "😜",
          "🥹",
          "🤐",
          "😏",
          "🙄",
          "😑",
          "😲",
          "😮",
          "🤨",
          "😕",
          "😟",
          "😔",
          "😭",
          "🙁",
          "☹️",
          "😒",
          "😠",
          "😡",
          "😉",
          "😙",
          "😍",
          "🥳",
          "🙂‍↕️",
          "🤕",
          "🤒",
          "🥶",
          "🤮",
          "🫠",
          "🥴",
          "😵‍💫",
          "😖",
          "🤥",
          "🤯",
          "😮‍💨",
          "😈",
          "🫡",
          "🤔",
          "🤫",
          "🥱",
          "😱",
          "👻",
          "💩",
          "👀",
          "💯",
          "❗️",
          "❓",
          "⁉️",
          "👏🏼",
          "👋🏼",
          "✌",
          "🤝🏻",
          "🏳️",
          "💞",
          "💔",
          "🌹",
          "🥀",
          "💐",
          "💡",
          "🎉",
          "💣",
          "💥",
          "🥇",
          "🎯",
          "🐣",
          "🪳",
          "🐂",
          "🦈",
          "🦕",
          "🦖",
          "🐉",
          "🫏",
          "🐮",
          "🐢",
          "🦍"
        ],
        texts: [
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "e10",
          "e11",
          "e12",
          "e13",
          "e14",
          "e15",
          "e16",
          "e17",
          "e18",
          "e19",
          "e20",
          "e21",
          "e22",
          "e23",
          "e24",
          "e25",
          "e26",
          "e27",
          "e28",
          "e29",
          "e30",
          "e31",
          "e32",
          "e33",
          "e34",
          "e35",
          "e36",
          "e37",
          "e38",
          "e39",
          "e40",
          "e41",
          "e42",
          "e43",
          "e44",
          "e45",
          "s1",
          "s2",
          "s3",
          "s4",
          "s5",
          "s6",
          "s7",
          "s8",
          "s9",
          "s10",
          "s11",
          "s12",
          "s13",
          "s14",
          "s15",
          "s16",
          "s17",
          "s18",
          "s19",
          "s20",
          "s21",
          "s22",
          "s23",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "h7",
          "h8",
          "h9",
          "h10",
          "h11"
        ]
      };
    },
    methods: {
      click(i) {
        sticker.toggleTab();
        var text = this.texts[i];
        sticker.handleUpdate(text);
      }
    }
  });
};
itemclick.reset = function() {
  removeItemIcon();
};
function removeItemIcon() {
  const elements = document.querySelectorAll(".bazporsiForItem");
  elements.forEach((element) => {
    element.remove();
  });
}
let rowNum = -1;
function itemMainClick(i) {
  rowNum = i;
  vm.$refs.childitemclick.isMy = false;
  if (i == globalModel.user.row)
    vm.$refs.childitemclick.isMy = true;
  if (globalModel.isNightEvent) {
    main.addNightEvent(rowNum);
    return;
  }
  if (globalModel.gameName == "rangOraz") {
    let b = rangOrazClick(i);
    if (b)
      return;
  }
  if (globalModel.gameName == "afsonVajeh") {
    afsonVajehClick(i);
  }
  if (globalModel.gameName == "mafia") {
    mafiaClick(i);
    if (globalModel.khorojHadseNaghsh == true) return;
  }
  if (globalModel.gameName == "rangOraz")
    vm.$refs.childitemclick.rangOrazClick(i);
  if (globalModel.gameName == "afsonVajeh" || globalModel.gameName == "mafia")
    vm.$refs.childitemclick.modal = true;
  if (globalModel.gameName == "nabardKhande")
    vm.$refs.childitemclick.info();
}
function rangOrazClick(i) {
  var _a;
  if (globalModel.hadseNaghsh && !vm.$refs.childitemclick.isMy) {
    const user = vm.$refs.childmain.users.find((x) => x.row == i);
    globalModel.connection.emit("setHadseNaghsh", {
      userId: user.id,
      roomId: socketHandler.roomId,
      userKey: socketHandler.userKey
    });
    return true;
  }
  vm.$refs.childitemclick.isShowOstad = false;
  if (globalModel.user.type == 2 && !globalModel.room.isShowOstad)
    vm.$refs.childitemclick.isShowOstad = true;
  if ((_a = globalModel.bazpors) == null ? void 0 : _a.select) {
    const user = vm.$refs.childmain.users.find((x) => x.row == i);
    globalModel.connection.emit("setBazporsi", {
      userId: user.id,
      roomId: socketHandler.roomId,
      userKey: socketHandler.userKey
    });
    return true;
  }
  return false;
}
function afsonVajehClick(i) {
  if (main.stream != null && main.stream.activeUser == globalModel.user.index) {
    vm.$refs.childitemclick.afson = { ...globalModel.groupItem };
  } else
    vm.$refs.childitemclick.afson = null;
}
let hadseNaghshList = null;
function mafiaClick(i) {
  if (hadseNaghshList == null) {
    hadseNaghshList = [];
    vm.$refs.childhelp.helpComment.map((x) => {
      if (x.type < 20 && x.type > 0)
        hadseNaghshList.push({ type: x.type, title: x.title, icon: x.icon });
    });
  }
  if (globalModel.khorojHadseNaghsh == true) {
    vm.$refs.childitemclick.mafia = {
      isHadseNaghshList: true,
      hadseNaghshList
    };
    return;
  }
  const model = {};
  if (globalModel.room.doorType == 1 && globalModel.room.door > 1 && globalModel.user.userInGameStatus == 1) {
    if (globalModel.user.type == 7 && globalModel.room.door > 2 && globalModel.groupItem.shot)
      model.kalantarShot = true;
    if (globalModel.user.type > 20 && globalModel.groupItem.hadseNaghsh) {
      model.hadseNaghsh = true;
      model.isHadseNaghshList = false;
      model.hadseNaghshList = hadseNaghshList;
    }
  }
  vm.$refs.childitemclick.mafia = model;
}
function addTargetReceive(model) {
  const user = vm.$refs.childmain.users.find((x) => x.id == model.id);
  if (!user)
    return;
  const chaleshForItemEl = document.querySelector(`.targetForItem.el${user.row}`);
  if (chaleshForItemEl)
    return;
  const selector = `.itemMain${user.row}`;
  const itemMain = document.querySelector(selector);
  const rectEl = itemMain.getBoundingClientRect();
  const divEl = document.createElement("div");
  let c = `targetForItem el${user.row}`;
  if (user.row < publicUserRow + 1) {
    c += " target1";
    divEl.style.left = `${rectEl.left - 25}px`;
  } else {
    c += " target2";
    divEl.style.left = `${rectEl.right}px`;
  }
  divEl.style.top = `${rectEl.top + 10}px`;
  c += model.type == 0 ? " targetColor1" : " targetColor2";
  divEl.className = c;
  mainTemplate.appendChild(divEl);
  setTimeout(() => {
    divEl.remove();
  }, 1400);
}
itemclick.listen = function() {
  vm.$refs.childitemclick.gameName = globalModel.gameName;
  if (globalModel.gameName != "nabardKhande") {
    globalModel.connection.on("addTargetReceive", addTargetReceive);
  }
  if (globalModel.gameName == "rangOraz") {
    globalModel.connection.on("setBazporsiReceive", (model) => {
      removeItemIcon();
      if ((model == null ? void 0 : model.length) > 0) {
        const users = vm.$refs.childmain.users.filter((x) => model.includes(x.id)) || [];
        users.map((x) => {
          const el = document.querySelector(`.itemMain${x.row} .itemImg`);
          if (!el)
            return;
          const divEl = document.createElement("div");
          divEl.className = `bazporsiForItem imgStatus icon-badge-police`;
          el.appendChild(divEl);
        });
      }
    });
  }
};
function addTarget(type) {
  if (!vm.$refs.childitemclick.isAddTarget)
    return;
  const user = vm.$refs.childmain.users.find((x) => x.row == rowNum);
  if (!user)
    return;
  globalModel.connection.emit("addTarget", {
    userId: user.id,
    type,
    roomId: socketHandler.roomId,
    userKey: socketHandler.userKey
  });
}
itemclick.Component = function(app2) {
  app2.config.globalProperties.itemMainClick = itemMainClick;
  app2.component("itemclick-component", {
    template: "#itemclick-template",
    data() {
      return {
        gameName: "",
        itemIndex: -1,
        modal: false,
        userInfo: null,
        isAddTarget: false,
        isMy: false,
        isShowOstad: false,
        afson: null,
        mafia: null
      };
    },
    props: {},
    methods: {
      rangOrazClick(i) {
        this.itemIndex = i;
        if (this.isAddTarget || this.isShowOstad && this.isMy) {
          this.modal = true;
        } else {
          this.info();
        }
      },
      target(type) {
        addTarget(type);
      },
      info() {
        this.userInfo = vm.$refs.childmain.users.find((x) => x.row == rowNum);
      },
      showOstad() {
        globalModel.connection.emit("setShowOstad", {
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      },
      addGun() {
        this.modal = false;
        const user = vm.$refs.childmain.users.find((x) => x.row == rowNum);
        globalModel.connection.emit("addGun", {
          userId: user.id,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      },
      addTalk() {
        this.modal = false;
        const user = vm.$refs.childmain.users.find((x) => x.row == rowNum);
        globalModel.connection.emit("addTalk", {
          userId: user.id,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      },
      setKalantarShot() {
        this.modal = false;
        const user = vm.$refs.childmain.users.find((x) => x.row == rowNum);
        globalModel.connection.emit("setKalantarShot", {
          userId: user.id,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      },
      setHadseNaghsh(m) {
        this.mafia.isHadseNaghshList = false;
        const user = vm.$refs.childmain.users.find((x) => x.row == rowNum);
        if ([1, 10].indexOf(user.userInGameStatus) == -1) return;
        let eventName = globalModel.khorojHadseNaghsh == true ? "setHadseNaghshKhoroj" : "setHadseNaghsh";
        globalModel.connection.emit(eventName, {
          userId: user.id,
          type: m.type,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
      }
    }
  });
};
function progressTime(t) {
  const el = document.querySelector(`.awq78f7af div`);
  if (!el)
    return;
  el.style.width = `100%`;
  const animation2 = el.animate([
    { width: `100%` },
    { width: `0%` }
  ], {
    duration: t * 1e3,
    easing: "linear",
    fill: "forwards"
  });
  animation2.onfinish = () => {
    el.style.width = `0px`;
  };
}
function setWinner(w) {
  if (globalModel.gameName == "rangOraz") {
    if (w == 1)
      vm.$refs.childGameresponse.winner = "تیم نقاش‌ها";
    else
      vm.$refs.childGameresponse.winner = "جاسوس";
  }
  if (w == 2)
    vm.$refs.childGameresponse.winnerColor = "var(--NaghshSiahColor)";
  if (globalModel.gameName == "afsonVajeh") {
    if (w == 1) {
      vm.$refs.childGameresponse.winner = "گروه آبی";
      vm.$refs.childGameresponse.winnerColor = "#30ccff";
    } else {
      vm.$refs.childGameresponse.winner = "گروه قرمز";
      vm.$refs.childGameresponse.winnerColor = "#f35a9f";
    }
  }
  if (globalModel.gameName == "mafia") {
    if (w == 1) {
      vm.$refs.childGameresponse.winner = "شهروند‌ها";
    } else {
      vm.$refs.childGameresponse.winner = "مافیا";
    }
  }
  if (globalModel.gameName == "nabardKhande") {
    if (w == 1) {
      vm.$refs.childGameresponse.winner = "گروه آبی";
      vm.$refs.childGameresponse.winnerColor = "rgb(48, 204, 255)";
    } else if (w == 2) {
      vm.$refs.childGameresponse.winner = "گروه سبز";
      vm.$refs.childGameresponse.winnerColor = "rgb(130, 243, 90)";
    } else if (w == 3) {
      vm.$refs.childGameresponse.winner = "گروه قرمز";
      vm.$refs.childGameresponse.winnerColor = " rgb(243, 90, 159)";
    }
  }
}
gameresponse.getMessage = function(model) {
  var _a, _b, _c, _d;
  const user = vm.$refs.childmain.users.find((u) => u.id == model.userId);
  const my = user.id == globalModel.user.id;
  const imgHtml = `<div class="chatImg"><div class="roomListUserImg"><div class="roomTopUserImg"><img src="${(_a = user.info) == null ? void 0 : _a.Img}90.jpg"></div></div><div class="chatUserName">${(_b = user.info) == null ? void 0 : _b.UserName}</div></div>`;
  const msgHtml = `<div class="chatText"><div class="chatBox"><div class="chatInfo">${(_c = user.info) == null ? void 0 : _c.FirstName} ${(_d = user.info) == null ? void 0 : _d.UserName}</div><div class="chatMsg">${model.msg}</div></div></div>`;
  const html = `<div class="chatMain${my ? " myText" : ""} d-flex">${my ? msgHtml + imgHtml : imgHtml + msgHtml}</div>`;
  vm.$refs.childGameresponse.messages.push(html);
  scrollEl(".sdfe89r-main", false);
};
gameresponse.endGameReceive = function(model) {
};
gameresponse.gameResponseReceive = function(model) {
  globalModel.gameResponse = model;
  vm.changeState("gameresponse");
  progressTime(model.wait);
};
gameresponse.Component = function(app2) {
  app2.component("gameresponse-component", {
    template: "#gameresponse-template",
    data() {
      return {
        message: "",
        winnerColor: "var(--NaghshSefidColor)",
        isSendMessage: false,
        winner: "",
        users: [],
        messages: []
      };
    },
    props: {},
    methods: {
      init() {
        setTimeout(() => {
          setWinner(globalModel.gameResponse.winner);
          this.addUser();
        }, 700);
      },
      addUser() {
        globalModel.gameResponse.users.forEach((x, index2) => {
          setTimeout(() => {
            const user = vm.$refs.childmain.users.find((u) => u.id == x.id);
            const helpItem = help.find(x.type);
            this.users.push({
              img: user.info.Img,
              userName: user.info.UserName,
              icon: helpItem == null ? void 0 : helpItem.icon,
              title: helpItem == null ? void 0 : helpItem.title,
              color: (helpItem == null ? void 0 : helpItem.color) ? helpItem == null ? void 0 : helpItem.color : void 0
            });
            if (index2 + 1 == globalModel.gameResponse.users.length)
              this.isSendMessage = true;
          }, 700 * (index2 + 1));
        });
      },
      addMessage() {
        if (this.message.length > 50)
          this.message = this.message.slice(0, 50);
        globalModel.connection.emit("setMessage", {
          message: this.message,
          roomId: socketHandler.roomId,
          userKey: socketHandler.userKey
        });
        this.message = "";
      }
    }
  });
};
const app = Vue.createApp({
  data() {
    return {
      appModel: {
        state: "_state",
        loding: true,
        nightMode: false
      }
    };
  },
  created() {
    this.$nextTick(() => {
      setMainTemplate();
    });
  },
  methods: {
    changeState(state) {
      if (this.appModel.state == state) return;
      switch (state) {
        case "main":
          vm.$refs.childmain.init();
          break;
        case "gameresponse":
          vm.$refs.childGameresponse.init();
          break;
        case "chaos":
          vm.$refs.childchaos.init();
          break;
      }
      this.appModel.state = state;
    }
  }
});
main.Component(app);
help.Component(app);
chaos.Component(app);
sticker.Component(app);
itemclick.Component(app);
gameresponse.Component(app);
document.addEventListener("DOMContentLoaded", () => {
  vm = app.mount("#app");
  socketHandler.initSoket();
});
